<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Form和ModelForm组件' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Form和ModelForm组件</center></div><div class='banquan'>原文出处:本文由博客园博主changxin7提供。<br/>
原文连接:https://www.cnblogs.com/changxin7/p/11616775.html</div><br>
    <h1 id="一-form介绍">一 Form介绍</h1>
<p>　　</p>
<p>　　我们之前在HTML页面中利用form表单向后端提交数据时，都会写一些获取用户输入的标签并且用form标签把它们包起来。</p>
<p>　　与此同时我们在好多场景下都需要对用户的输入做校验，比如校验用户是否输入，输入的长度和格式等正不正确。如果用户输入的内容有错误就需要在页面上相应的位置显示对应的错误信息.。</p>
<p>　　Django form组件就实现了上面所述的功能。</p>
<p>　　总结一下，其实form组件的主要功能如下:</p>
<p>　　　　生成页面可用的HTML标签</p>
<p>　　　　对用户提交的数据进行校验</p>
<p>　　　　保留上次输入内容</p>
<p>　　</p>
<h2 id="普通方式手写注册功能">普通方式手写注册功能</h2>
<h3 id="views.py">views.py</h3>
<pre><code><code># 注册
def register(request):
    error_msg = &quot;&quot;
    if request.method == &quot;POST&quot;:
        username = request.POST.get(&quot;name&quot;)
        pwd = request.POST.get(&quot;pwd&quot;)
        # 对注册信息做校验
        if len(username) &lt; 6:
            # 用户长度小于6位
            error_msg = &quot;用户名长度不能小于6位&quot;
        else:
            # 将用户名和密码存到数据库
            return HttpResponse(&quot;注册成功&quot;)
    return render(request, &quot;register.html&quot;, {&quot;error_msg&quot;: error_msg})</code></pre>
<h3 id="login.html">login.html</h3>
<pre><code><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;注册页面&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action=&quot;/reg/&quot; method=&quot;post&quot;&gt;
    {% csrf_token %}
    &lt;p&gt;
        用户名:
        &lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;
    &lt;/p&gt;
    &lt;p&gt;
        密码：
        &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;
    &lt;/p&gt;
    &lt;p&gt;
        &lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;
        &lt;p style=&quot;color: red&quot;&gt;{{ error_msg }}&lt;/p&gt;
    &lt;/p&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<h2 id="使用form组件实现注册功能">使用form组件实现注册功能</h2>
<h3 id="views.py-1">views.py</h3>
<p>　　　　　　先定义好一个RegForm类：</p>
<pre><code><code>from django import forms

# 按照Django form组件的要求自己写一个类
class RegForm(forms.Form):
    name = forms.CharField(label=&quot;用户名&quot;)  #form字段的名称写的是什么，那么前端生成input标签的时候，input标签的name属性的值就是什么
    pwd = forms.CharField(label=&quot;密码&quot;)</code></pre>
<p>　　　　　　再写一个视图函数：</p>
<pre><code><code># 使用form组件实现注册方式
def register2(request):
    form_obj = RegForm()
    if request.method == &quot;POST&quot;:
        # 实例化form对象的时候，把post提交过来的数据直接传进去
        form_obj = RegForm(data=request.POST)  #既然传过来的input标签的name属性值和form类对应的字段名是一样的，所以接过来后，form就取出对应的form字段名相同的数据进行form校验
        # 调用form_obj校验数据的方法
        if form_obj.is_valid():
            return HttpResponse(&quot;注册成功&quot;)
    return render(request, &quot;register2.html&quot;, {&quot;form_obj&quot;: form_obj})</code></pre>
<h3 id="login2.html">login2.html</h3>
<pre><code><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;注册2&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;form action=&quot;/reg2/&quot; method=&quot;post&quot; novalidate autocomplete=&quot;off&quot;&gt;  #novalidate 告诉前端form表单，不要对输入的内容做校验
        {% csrf_token %}        #{{ form_obj.as_p }}  直接写个这个，下面的用户名和密码的标签不自己写，你看看效果
        &lt;div&gt;
            &lt;label for=&quot;{{ form_obj.name.id_for_label }}&quot;&gt;{{ form_obj.name.label }}&lt;/label&gt;
            {{ form_obj.name }} {{ form_obj.name.errors.0 }}  #errors是这个字段所有的错误，我就用其中一个错误提示就可以了，再错了再提示，并且不是给你生成ul标签了，单纯的是错误文本           {{ form_obj.errors }} #这是全局的所有错误，找对应字段的错误，就要form_obj.字段名
        &lt;/div&gt;
        &lt;div&gt;
            &lt;label for=&quot;{{ form_obj.pwd.id_for_label }}&quot;&gt;{{ form_obj.pwd.label }}&lt;/label&gt;
            {{ form_obj.pwd }} {{ form_obj.pwd.errors.0 }}
        &lt;/div&gt;
        &lt;div&gt;
            &lt;input type=&quot;submit&quot; class=&quot;btn btn-success&quot; value=&quot;注册&quot;&gt;
        &lt;/div&gt;
    &lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>　　　　看网页效果发现 也验证了form的功能：<br />
　　　　　　前端页面是form类的对象生成的 --&gt;生成HTML标签功能<br />
　　　　　　当用户名和密码输入为空或输错之后 页面都会提示 --&gt;用户提交校验功能<br />
　　　　　　当用户输错之后 再次输入 上次的内容还保留在input框 --&gt;保留上次输入内容</p>
<h1 id="二-form常用字段与插件">二 Form常用字段与插件</h1>
<p>　　</p>
<p>　　创建Form类时，主要涉及到 【字段】 和 【插件】，字段用于对用户请求数据的验证，插件用于自动生成HTML;</p>
<h2 id="initial">initial</h2>
<p>　　　　初始值，input框里面的初始值。</p>
<pre><code><code>class LoginForm(forms.Form):
    username = forms.CharField(  
        min_length=8,
        label=&quot;用户名&quot;,
        initial=&quot;张三&quot;  # 设置默认值
    )
    pwd = forms.CharField(min_length=6, label=&quot;密码&quot;)</code></pre>
<h2 id="error_messages">error_messages</h2>
<p>　　　　重写错误信息。</p>
<pre><code><code>class LoginForm(forms.Form):
    username = forms.CharField(
        min_length=8,
        label=&quot;用户名&quot;,
        initial=&quot;张三&quot;,
        error_messages={
            &quot;required&quot;: &quot;不能为空&quot;,
            &quot;invalid&quot;: &quot;格式错误&quot;,
            &quot;min_length&quot;: &quot;用户名最短8位&quot;
        }
    )
    pwd = forms.CharField(min_length=6, label=&quot;密码&quot;)</code></pre>
<h2 id="password">password</h2>
<pre><code><code>class LoginForm(forms.Form):
    ...
    pwd = forms.CharField(
        min_length=6,
        label=&quot;密码&quot;,
        widget=forms.widgets.PasswordInput(attrs={&#39;class&#39;: &#39;c1&#39;}, render_value=True) #这个密码字段和其他字段不一样，默认在前端输入数据错误的时候，点击提交之后，默认是不保存的原来数据的，但是可以通过这个render_value=True让这个字段在前端保留用户输入的数据
    )</code></pre>
<h2 id="radioselect">radioSelect</h2>
<p>　　　　单radio值为字符串</p>
<pre><code><code>class LoginForm(forms.Form):
    username = forms.CharField(  #其他选择框或者输入框，基本都是在这个CharField的基础上通过插件来搞的
        min_length=8,
        label=&quot;用户名&quot;,
        initial=&quot;张三&quot;,
        error_messages={
            &quot;required&quot;: &quot;不能为空&quot;,
            &quot;invalid&quot;: &quot;格式错误&quot;,
            &quot;min_length&quot;: &quot;用户名最短8位&quot;
        }
    )
    pwd = forms.CharField(min_length=6, label=&quot;密码&quot;)
    gender = forms.fields.ChoiceField(
        choices=((1, &quot;男&quot;), (2, &quot;女&quot;), (3, &quot;保密&quot;)),
        label=&quot;性别&quot;,
        initial=3,
        widget=forms.widgets.RadioSelect()
    )</code></pre>
<h2 id="单选select">单选Select</h2>
<pre><code><code>class LoginForm(forms.Form):
    ...
    hobby = forms.fields.ChoiceField(  #注意，单选框用的是ChoiceField，并且里面的插件是Select，不然验证的时候会报错， Select a valid choice的错误。
        choices=((1, &quot;篮球&quot;), (2, &quot;足球&quot;), (3, &quot;双色球&quot;), ),
        label=&quot;爱好&quot;,
        initial=3,
        widget=forms.widgets.Select()
    )</code></pre>
<h2 id="多选select">多选Select</h2>
<pre><code><code>class LoginForm(forms.Form):
    ...
    hobby = forms.fields.MultipleChoiceField( #多选框的时候用MultipleChoiceField，并且里面的插件用的是SelectMultiple，不然验证的时候会报错。
        choices=((1, &quot;篮球&quot;), (2, &quot;足球&quot;), (3, &quot;双色球&quot;), ),
        label=&quot;爱好&quot;,
        initial=[1, 3],
        widget=forms.widgets.SelectMultiple()
    )</code></pre>
<h2 id="单选checkbox">单选checkbox</h2>
<pre><code><code>class LoginForm(forms.Form):
    ...
    keep = forms.fields.ChoiceField(
        label=&quot;是否记住密码&quot;,
        initial=&quot;checked&quot;,
        widget=forms.widgets.CheckboxInput()
    )</code></pre>
<p>　　单选checkbox示例:</p>
<pre><code><code>#单选的checkbox
    class TestForm2(forms.Form):
        keep = forms.ChoiceField(
            choices=(
                (&#39;True&#39;,1),
                (&#39;False&#39;,0),
            ),

            label=&quot;是否7天内自动登录&quot;,
            initial=&quot;1&quot;,
            widget=forms.widgets.CheckboxInput(), 
        )
    选中:&#39;True&#39;   #form只是帮我们做校验,校验选择内容的时候,就是看在没在我们的choices里面,里面有这个值,表示合法,没有就不合法
    没选中:&#39;False&#39;
    ---保存到数据库里面  keep:&#39;True&#39;
    if keep == &#39;True&#39;:
        session 设置有效期7天
    else:
        pass</code></pre>
<h2 id="多选checkbox">多选checkbox</h2>
<pre><code><code>class LoginForm(forms.Form):
    ...
    hobby = forms.fields.MultipleChoiceField(
        choices=((1, &quot;篮球&quot;), (2, &quot;足球&quot;), (3, &quot;双色球&quot;),),
        label=&quot;爱好&quot;,
        initial=[1, 3],
        widget=forms.widgets.CheckboxSelectMultiple()
    )</code></pre>
<h2 id="date类型">date类型</h2>
<pre><code><code>from django import forms
from django.forms import widgets
class BookForm(forms.Form):
    date = forms.DateField(widget=widgets.TextInput(attrs={&#39;type&#39;:&#39;date&#39;}))  #必须指定type，不然不能渲染成选择时间的input框</code></pre>
<h2 id="choice字段注意事项">choice字段注意事项</h2>
<p>　　　　在使用选择标签时，需要注意choices的选项可以配置从数据库中获取，但是由于是静态字段 获取的值无法实时更新，需要重写构造方法从而实现choice实时更新。</p>
<p>　　　　方式一：</p>
<pre><code><code>from django.forms import Form
from django.forms import widgets
from django.forms import fields

 
class MyForm(Form):
 
    user = fields.ChoiceField(
        # choices=((1, &#39;上海&#39;), (2, &#39;北京&#39;),),
        initial=2,
        widget=widgets.Select
    )
 
    def __init__(self, *args, **kwargs):
        super(MyForm,self).__init__(*args, **kwargs) #注意重写init方法的时候，*args和**kwargs一定要给人家写上，不然会出问题，并且验证总是不能通过，还不显示报错信息
        # self.fields[&#39;user&#39;].choices = ((1, &#39;上海&#39;), (2, &#39;北京&#39;),)
        # 或
        self.fields[&#39;user&#39;].choices = models.Classes.objects.all().values_list(&#39;id&#39;,&#39;caption&#39;)</code></pre>
<p>　　　　方式二：</p>
<pre><code><code>from django import forms
from django.forms import fields
from django.forms import models as form_model

 
class FInfo(forms.Form):　　
    authors = forms.ModelMultipleChoiceField(queryset=models.NNewType.objects.all())  # 多选    #或者下面这种方式，通过forms里面的models中提供的方法也是一样的。
    authors = form_model.ModelMultipleChoiceField(queryset=models.NNewType.objects.all())  # 多选
    #authors = form_model.ModelChoiceField(queryset=models.NNewType.objects.all())  # 单选    #或者，forms.ModelChoiceField(queryset=models.Publisth.objects.all(),widget=forms.widgets.Select()) 单选    #
   authors = forms.ModelMultipleChoiceField(    queryset=models.Author.objects.all(),    widget = forms.widgets.Select(attrs={&#39;class&#39;: &#39;form-control&#39;}   ))
   #如果用这种方式，别忘了model表中，NNEWType的__str__方法要写上，不然选择框里面是一个个的object对象
</code></pre>
<p>　</p>
<h1 id="三-form所有内置字段">三 Form所有内置字段</h1>
<p>内置字段：</p>
<pre><code><code>Field
    required=True,               是否允许为空
    widget=None,                 HTML插件
    label=None,                  用于生成Label标签或显示内容
    initial=None,                初始值
    help_text=&#39;&#39;,                帮助信息(在标签旁边显示)
    error_messages=None,         错误信息 {&#39;required&#39;: &#39;不能为空&#39;, &#39;invalid&#39;: &#39;格式错误&#39;}
    validators=[],               自定义验证规则
    localize=False,              是否支持本地化
    disabled=False,              是否可以编辑
    label_suffix=None            Label内容后缀
 
 
CharField(Field)
    max_length=None,             最大长度
    min_length=None,             最小长度
    strip=True                   是否移除用户输入空白
 
IntegerField(Field)
    max_value=None,              最大值
    min_value=None,              最小值
 
FloatField(IntegerField)
    ...
 
DecimalField(IntegerField)
    max_value=None,              最大值
    min_value=None,              最小值
    max_digits=None,             总长度
    decimal_places=None,         小数位长度
 
BaseTemporalField(Field)
    input_formats=None          时间格式化   
 
DateField(BaseTemporalField)    格式：2015-09-01
TimeField(BaseTemporalField)    格式：11:12
DateTimeField(BaseTemporalField)格式：2015-09-01 11:12
 
DurationField(Field)            时间间隔：%d %H:%M:%S.%f
    ...
 
RegexField(CharField)
    regex,                      自定制正则表达式
    max_length=None,            最大长度
    min_length=None,            最小长度
    error_message=None,         忽略，错误信息使用 error_messages={&#39;invalid&#39;: &#39;...&#39;}
 
EmailField(CharField)      
    ...
 
FileField(Field)
    allow_empty_file=False     是否允许空文件
 
ImageField(FileField)      
    ...
    注：需要PIL模块，pip3 install Pillow
    以上两个字典使用时，需要注意两点：
        - form表单中 enctype=&quot;multipart/form-data&quot;
        - view函数中 obj = MyForm(request.POST, request.FILES)
 
URLField(Field)
    ...
 
 
BooleanField(Field)  
    ...
 
NullBooleanField(BooleanField)
    ...
 
ChoiceField(Field)
    ...
    choices=(),                选项，如：choices = ((0,&#39;上海&#39;),(1,&#39;北京&#39;),)
    required=True,             是否必填
    widget=None,               插件，默认select插件
    label=None,                Label内容
    initial=None,              初始值
    help_text=&#39;&#39;,              帮助提示
 
 
ModelChoiceField(ChoiceField)
    ...                        django.forms.models.ModelChoiceField
    queryset,                  # 查询数据库中的数据
    empty_label=&quot;---------&quot;,   # 默认空显示内容
    to_field_name=None,        # HTML中value的值对应的字段
    limit_choices_to=None      # ModelForm中对queryset二次筛选
     
ModelMultipleChoiceField(ModelChoiceField)
    ...                        django.forms.models.ModelMultipleChoiceField
 
 
     
TypedChoiceField(ChoiceField)
    coerce = lambda val: val   对选中的值进行一次转换
    empty_value= &#39;&#39;            空值的默认值
 
MultipleChoiceField(ChoiceField)
    ...
 
TypedMultipleChoiceField(MultipleChoiceField)
    coerce = lambda val: val   对选中的每一个值进行一次转换
    empty_value= &#39;&#39;            空值的默认值
 
ComboField(Field)
    fields=()                  使用多个验证，如下：即验证最大长度20，又验证邮箱格式
                               fields.ComboField(fields=[fields.CharField(max_length=20), fields.EmailField(),])
 
MultiValueField(Field)
    PS: 抽象类，子类中可以实现聚合多个字典去匹配一个值，要配合MultiWidget使用
 
SplitDateTimeField(MultiValueField)
    input_date_formats=None,   格式列表：[&#39;%Y--%m--%d&#39;, &#39;%m%d/%Y&#39;, &#39;%m/%d/%y&#39;]
    input_time_formats=None    格式列表：[&#39;%H:%M:%S&#39;, &#39;%H:%M:%S.%f&#39;, &#39;%H:%M&#39;]
 
FilePathField(ChoiceField)     文件选项，目录下文件显示在页面中
    path,                      文件夹路径
    match=None,                正则匹配
    recursive=False,           递归下面的文件夹
    allow_files=True,          允许文件
    allow_folders=False,       允许文件夹
    required=True,
    widget=None,
    label=None,
    initial=None,
    help_text=&#39;&#39;
 
GenericIPAddressField
    protocol=&#39;both&#39;,           both,ipv4,ipv6支持的IP格式
    unpack_ipv4=False          解析ipv4地址，如果是::ffff:192.0.2.1时候，可解析为192.0.2.1， PS：protocol必须为both才能启用
 
SlugField(CharField)           数字，字母，下划线，减号（连字符）
    ...
 
UUIDField(CharField)           uuid类型
复制代码
</code></pre>
<h1 id="四-字段校验">四 字段校验</h1>
<h2 id="regexvalidator验证器">RegexValidator验证器</h2>
<pre><code><code>from django.forms import Form
from django.forms import widgets
from django.forms import fields
from django.core.validators import RegexValidator
 
class MyForm(Form):
    user = fields.CharField(
        validators=[RegexValidator(r&#39;^[0-9]+$&#39;, &#39;请输入数字&#39;), RegexValidator(r&#39;^159[0-9]+$&#39;, &#39;数字必须以159开头&#39;)],
    )
</code></pre>
<h2 id="自定义验证函数">自定义验证函数</h2>
<pre><code><code>import re
from django.forms import Form
from django.forms import widgets
from django.forms import fields
from django.core.exceptions import ValidationError
 
 
# 自定义验证规则
def mobile_validate(value):
    mobile_re = re.compile(r&#39;^(13[0-9]|15[012356789]|17[678]|18[0-9]|14[57])[0-9]{8}$&#39;)
    if not mobile_re.match(value):
        raise ValidationError(&#39;手机号码格式错误&#39;)  #自定义验证规则的时候，如果不符合你的规则，需要自己发起错误
 
 
class PublishForm(Form):
 
 
    title = fields.CharField(max_length=20,
                            min_length=5,
                            error_messages={&#39;required&#39;: &#39;标题不能为空&#39;,
                                            &#39;min_length&#39;: &#39;标题最少为5个字符&#39;,
                                            &#39;max_length&#39;: &#39;标题最多为20个字符&#39;},
                            widget=widgets.TextInput(attrs={&#39;class&#39;: &quot;form-control&quot;,
                                                          &#39;placeholder&#39;: &#39;标题5-20个字符&#39;}))
 
 
    # 使用自定义验证规则
    phone = fields.CharField(validators=[mobile_validate, ],
                            error_messages={&#39;required&#39;: &#39;手机不能为空&#39;},
                            widget=widgets.TextInput(attrs={&#39;class&#39;: &quot;form-control&quot;,
                                                          &#39;placeholder&#39;: u&#39;手机号码&#39;}))
 
    email = fields.EmailField(required=False,
                            error_messages={&#39;required&#39;: u&#39;邮箱不能为空&#39;,&#39;invalid&#39;: u&#39;邮箱格式错误&#39;},
                            widget=widgets.TextInput(attrs={&#39;class&#39;: &quot;form-control&quot;, &#39;placeholder&#39;: u&#39;邮箱&#39;}))
</code></pre>
<h1 id="五-hook钩子方法">五 Hook钩子方法</h1>
<p>　　除了上面两种方式，我们还可以在Form类中定义钩子函数，来实现自定义的验证功能。</p>
<h2 id="局部钩子">局部钩子</h2>
<p>　　　　我们在Fom类中定义 clean_字段名() 方法，就能够实现对特定字段进行校验。</p>
<p>　　　　举个例子：</p>
<pre><code><code>class LoginForm(forms.Form):
    username = forms.CharField(
        min_length=8,
        label=&quot;用户名&quot;,
        initial=&quot;张三&quot;,
        error_messages={
            &quot;required&quot;: &quot;不能为空&quot;,
            &quot;invalid&quot;: &quot;格式错误&quot;,
            &quot;min_length&quot;: &quot;用户名最短8位&quot;
        },
        widget=forms.widgets.TextInput(attrs={&quot;class&quot;: &quot;form-control&quot;})
    )
    ...
    # 定义局部钩子，用来校验username字段,之前的校验股则还在，给你提供了一个添加一些校验功能的钩子
    def clean_username(self):
        value = self.cleaned_data.get(&quot;username&quot;)
        if &quot;666&quot; in value:
            raise ValidationError(&quot;光喊666是不行的&quot;)
        else:
            return value
</code></pre>
<h2 id="全局钩子">全局钩子</h2>
<p>　　　　我们在Fom类中定义 clean() 方法，就能够实现对字段进行全局校验，字段全部验证完，局部钩子也全部执行完之后，执行这个全局钩子校验。</p>
<pre><code><code>class LoginForm(forms.Form):
    ...
    password = forms.CharField(
        min_length=6,
        label=&quot;密码&quot;,
        widget=forms.widgets.PasswordInput(attrs={&#39;class&#39;: &#39;form-control&#39;}, render_value=True)
    )
    re_password = forms.CharField(
        min_length=6,
        label=&quot;确认密码&quot;,
        widget=forms.widgets.PasswordInput(attrs={&#39;class&#39;: &#39;form-control&#39;}, render_value=True)
    )
    ...
    # 定义全局的钩子，用来校验密码和确认密码字段是否相同，执行全局钩子的时候，cleaned_data里面肯定是有了通过前面验证的所有数据
    def clean(self):
        password_value = self.cleaned_data.get(&#39;password&#39;)
        re_password_value = self.cleaned_data.get(&#39;re_password&#39;)
        if password_value == re_password_value:
            return self.cleaned_data #全局钩子要返回所有的数据
        else:
            self.add_error(&#39;re_password&#39;, &#39;两次密码不一致&#39;) #在re_password这个字段的错误列表中加上一个错误，并且clean_data里面会自动清除这个re_password的值，所以打印clean_data的时候会看不到它
            raise ValidationError(&#39;两次密码不一致&#39;)
</code></pre>
<h1 id="六-进阶补充">六 进阶补充</h1>
<h2 id="应用bootstrap样式">应用Bootstrap样式</h2>
<p>　　　　Django form应用Bootstrap样式简单示例：</p>
<pre><code><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;&gt;
  &lt;meta http-equiv=&quot;x-ua-compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;/static/bootstrap/css/bootstrap.min.css&quot;&gt;
  &lt;title&gt;login&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class=&quot;container&quot;&gt;
  &lt;div class=&quot;row&quot;&gt;
    &lt;form action=&quot;/login2/&quot; method=&quot;post&quot; novalidate class=&quot;form-horizontal&quot;&gt;
      {% csrf_token %}
      &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;{{ form_obj.username.id_for_label }}&quot;
               class=&quot;col-md-2 control-label&quot;&gt;{{ form_obj.username.label }}&lt;/label&gt;
        &lt;div class=&quot;col-md-10&quot;&gt;
          {{ form_obj.username }}
          &lt;span class=&quot;help-block&quot;&gt;{{ form_obj.username.errors.0 }}&lt;/span&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;form-group&quot;&gt;
        &lt;label for=&quot;{{ form_obj.pwd.id_for_label }}&quot; class=&quot;col-md-2 control-label&quot;&gt;{{ form_obj.pwd.label }}&lt;/label&gt;
        &lt;div class=&quot;col-md-10&quot;&gt;
          {{ form_obj.pwd }}
          &lt;span class=&quot;help-block&quot;&gt;{{ form_obj.pwd.errors.0 }}&lt;/span&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;form-group&quot;&gt;
      &lt;label class=&quot;col-md-2 control-label&quot;&gt;{{ form_obj.gender.label }}&lt;/label&gt;
        &lt;div class=&quot;col-md-10&quot;&gt;
          &lt;div class=&quot;radio&quot;&gt;
            {% for radio in form_obj.gender %}
              &lt;label for=&quot;{{ radio.id_for_label }}&quot;&gt;
                {{ radio.tag }}{{ radio.choice_label }}
              &lt;/label&gt;
            {% endfor %}
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div class=&quot;form-group&quot;&gt;
        &lt;div class=&quot;col-md-offset-2 col-md-10&quot;&gt;
          &lt;button type=&quot;submit&quot; class=&quot;btn btn-default&quot;&gt;注册&lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/form&gt;
  &lt;/div&gt;
&lt;/div&gt;

&lt;script src=&quot;/static/jquery-3.2.1.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;/static/bootstrap/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="批量添加样式">批量添加样式</h2>
<p>　　　　可通过重写form类的init方法来实现。</p>
<pre><code><code>class LoginForm(forms.Form):
    username = forms.CharField(
        min_length=8,
        label=&quot;用户名&quot;,
        initial=&quot;张三&quot;,
        error_messages={
            &quot;required&quot;: &quot;不能为空&quot;,
            &quot;invalid&quot;: &quot;格式错误&quot;,
            &quot;min_length&quot;: &quot;用户名最短8位&quot;
        }
    ...

    def __init__(self, *args, **kwargs):
        super(LoginForm, self).__init__(*args, **kwargs)
        for field in iter(self.fields):
            self.fields[field].widget.attrs.update({
                &#39;class&#39;: &#39;form-control&#39;
            })
</code></pre>
<p>简单写一个小项目：book表的添加和数据展示</p>
<p>views.py内容如下：</p>
<pre><code><code>from django.shortcuts import render,HttpResponse,redirect
from app01 import models
from django import forms
# Create your views here.

class BookForm(forms.Form):
    title = forms.CharField(
        max_length=16,
        label=&#39;书名:&#39;,
        initial=&#39;zhang&#39;,
        # widget = forms.widgets.PasswordInput(attrs={&#39;class&#39;: &#39;form-control&#39;},render_value=True),
        widget = forms.widgets.TextInput(attrs={&#39;class&#39;: &#39;form-control&#39;},),

    )
    # title2 = forms.CharField(
    #     max_length=16,
    #     label=&#39;书名:&#39;,
    #     initial=&#39;zhang&#39;,
    #     # widget = forms.widgets.PasswordInput(attrs={&#39;class&#39;: &#39;form-control&#39;},render_value=True),
    #     widget=forms.widgets.TextInput(attrs={&#39;class&#39;: &#39;form-control&#39;}, ),
    #
    # )
    sex = forms.ChoiceField(
        choices=(
            (&#39;1&#39;,&#39;男&#39;),
            (&#39;2&#39;,&#39;女&#39;),
        )
        ,
        label=&#39;性别:&#39;,
        # widget=forms.widgets.RadioSelect(),
        # widget=forms.widgets.RadioSelect(),
        # widget=forms.widgets.SelectMultiple(attrs={&#39;class&#39;:&#39;form-control&#39;}),
        widget=forms.widgets.Select(attrs={&#39;class&#39;:&#39;form-control&#39;}),
        # widget=forms.widgets.CheckboxInput(),
        # widget=forms.widgets.CheckboxSelectMultiple(),
    )
    publishDate = forms.DateField(
        label=&#39;出版日期:&#39;,
        widget=forms.widgets.TextInput(attrs={&#39;type&#39;:&#39;date&#39;,&#39;class&#39;:&#39;form-control&#39;}),
    )
    price=forms.DecimalField(
        max_digits=5,
        decimal_places=2,
        label=&#39;书籍的价格:&#39;,
        widget=forms.widgets.NumberInput(attrs={&#39;class&#39;: &#39;form-control&#39;}
    ))

    # publish = forms.ModelChoiceField(
    #     label=&#39;出版社:&#39;,
    #     queryset=models.Publish.objects.all(),
    #     widget=forms.widgets.Select(attrs={&#39;class&#39;: &#39;form-control&#39;}
    # ))
    publish_id = forms.ChoiceField(
        label=&#39;出版社:&#39;,
        widget=forms.widgets.Select(attrs={&#39;class&#39;: &#39;form-control&#39;}
    ))
    authors = forms.ModelMultipleChoiceField(

        queryset=models.Author.objects.all(),
        widget = forms.widgets.SelectMultiple(attrs={&#39;class&#39;: &#39;form-control&#39;}
    ))

    def __init__(self,*args, **kwargs):
        super().__init__(*args, **kwargs)
        self.fields[&#39;publish_id&#39;].choices = models.Publish.objects.values_list(&#39;pk&#39;,&#39;name&#39;)


def index(request):
    if request.method == &#39;GET&#39;:
        form_obj = BookForm()

        return render(request,&#39;index.html&#39;,{&#39;form_obj&#39;:form_obj})

    else:
        print(request.POST)
        form_obj = BookForm(request.POST)
        print(form_obj.is_valid())
        print(form_obj.errors)
        if form_obj.is_valid():
            print(form_obj.cleaned_data)
            authors_obj = form_obj.cleaned_data.pop(&#39;authors&#39;)
            new_book_obj = models.Book.objects.create(**form_obj.cleaned_data)
            new_book_obj.authors.add(*authors_obj)
            return redirect(&#39;show&#39;)

        else:
            print(form_obj.errors)
            return render(request,&#39;index.html&#39;,{&#39;form_obj&#39;:form_obj})


def show(request):

    book_objs = models.Book.objects.all()

    return render(request,&#39;show.html&#39;,{&#39;book_objs&#39;:book_objs})

def edit_book(request,n):


    return HttpResponse(&#39;欢迎来到编辑页面&#39;)


def delete_book(request,n):
    return HttpResponse(&#39;欢迎来到删除页面&#39;)
</code></pre>
<p>　　urls.py内容如下</p>
<pre><code><code>from django.conf.urls import url
from django.contrib import admin
from app01 import views
urlpatterns = [
    url(r&#39;^admin/&#39;, admin.site.urls),
    url(r&#39;^index/&#39;, views.index,name=&#39;index&#39;),
    url(r&#39;^show/&#39;, views.show,name=&#39;show&#39;),
    url(r&#39;^edit_book/(\d+)/&#39;, views.edit_book,name=&#39;edit_book&#39;),
    url(r&#39;^delete_book/(\d+)/&#39;, views.delete_book,name=&#39;delete_book&#39;),
]
</code></pre>
<p>　　index.html内容如下：</p>
<pre><code><code>{% load static %}
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;{% static &#39;bootstrap-3.3.0-dist/dist/css/bootstrap.min.css&#39; %}&quot;&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1&gt;展示页面&lt;/h1&gt;
{#&lt;div&gt;#}
{#    {{ form_obj.as_p }}#}
{##}
{#&lt;/div&gt;#}

{#{% for field in form_obj %}#}
{#    &lt;div&gt;#}
{#        {{ field }}#}
{#    &lt;/div&gt;#}
{##}
{#{% endfor %}#}

&lt;div class=&quot;container-fluid&quot;&gt;
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-md-6 col-md-offset-3&quot;&gt;
            &lt;form action=&quot;&quot; novalidate method=&quot;post&quot;&gt;
                {% for field in form_obj %}
                    &lt;div class=&quot;form-group {% if field.errors.0 %}has-error{% endif %}&quot;&gt;
                        &lt;label for=&quot;{{ field.id_for_label }}&quot;&gt;{{ field.label }}&lt;/label&gt;
                        {{ field }}
                        &lt;span class=&quot;text-danger&quot;&gt;{{ field.errors.0 }}&lt;/span&gt;
                    &lt;/div&gt;
                {% endfor %}


                {#                &lt;div class=&quot;form-group&quot;&gt;#}
                {#                    &lt;label for=&quot;{{ form_obj.sex.id_for_label }}&quot;&gt;{{ form_obj.sex.label }}&lt;/label&gt;#}
                {#                    {{ form_obj.sex }}#}
                {#                    {{ form_obj.sex.errors.0 }}#}
                {#                &lt;/div&gt;#}
                {#            &lt;div class=&quot;form-group&quot;&gt;#}
                {#                    &lt;label for=&quot;{{ form_obj.publishDate.id_for_label }}&quot;&gt;{{ form_obj.publishDate.label }}&lt;/label&gt;#}
                {#                    {{ form_obj.publishDate }}#}
                {#                    {{ form_obj.publishDate.errors.0 }}#}
                {#                &lt;/div&gt;#}
                {#                &lt;div class=&quot;form-group&quot;&gt;#}
                {#                    &lt;label for=&quot;{{ form_obj.price.id_for_label }}&quot;&gt;{{ form_obj.price.label }}&lt;/label&gt;#}
                {#                    {{ form_obj.price }}#}
                {#                    &lt;span class=&quot;text-danger&quot;&gt;{{ form_obj.price.errors.0 }}&lt;/span&gt;#}
                {#                &lt;/div&gt;#}
                {#            &lt;div class=&quot;form-group&quot;&gt;#}
                {#                    &lt;label for=&quot;{{ form_obj.publish.id_for_label }}&quot;&gt;{{ form_obj.publish.label }}&lt;/label&gt;#}
                {#                    {{ form_obj.publish }}#}
                {#                    &lt;span class=&quot;text-danger&quot;&gt;{{ form_obj.publish.errors.0 }}&lt;/span&gt;#}
                {#                &lt;/div&gt;#}
                {#            &lt;div class=&quot;form-group&quot;&gt;#}
                {#                    &lt;label for=&quot;{{ form_obj.authors.id_for_label }}&quot;&gt;{{ form_obj.authors.label }}&lt;/label&gt;#}
                {#                    {{ form_obj.authors }}#}
                {#                    &lt;span class=&quot;text-danger&quot;&gt;{{ form_obj.authors.errors.0 }}&lt;/span&gt;#}
                {#                &lt;/div&gt;#}
                &lt;input type=&quot;submit&quot;&gt;
            &lt;/form&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;


&lt;div&gt;


&lt;/div&gt;


&lt;/body&gt;
&lt;script src=&quot;{% static &#39;bootstrap-3.3.0-dist/dist/jQuery/jquery-3.1.1.js&#39; %}&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;{% static &#39;bootstrap-3.3.0-dist/dist/js/bootstrap.min.js&#39; %}&quot;&gt;&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p>　　show.html内容如下</p>
<pre><code><code>{% load static %}
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;{% static &#39;bootstrap-3.3.0-dist/dist/css/bootstrap.min.css&#39; %}&quot;&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1&gt;数据展示&lt;/h1&gt;
&lt;div class=&quot;container-fluid&quot;&gt;
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-md-6 col-md-offset-3&quot;&gt;
            &lt;table class=&quot;table&quot;&gt;
                &lt;thead&gt;
                    &lt;tr&gt;
                        &lt;th&gt;id&lt;/th&gt;
                        &lt;th&gt;title&lt;/th&gt;
                        &lt;th&gt;性别&lt;/th&gt;
                        &lt;th&gt;出版日期&lt;/th&gt;
                        &lt;th&gt;出版社&lt;/th&gt;
                        &lt;th&gt;作者&lt;/th&gt;
                        &lt;th&gt;操作&lt;/th&gt;
                    &lt;/tr&gt;
                &lt;/thead&gt;
                &lt;tbody&gt;
                    {% for book_obj in book_objs %}
                         &lt;tr&gt;
                            &lt;td&gt;{{ book_obj.pk }}&lt;/td&gt;
                            &lt;td&gt;{{ book_obj.title }}&lt;/td&gt;
                            &lt;td&gt;{{ book_obj.get_sex_display }}&lt;/td&gt;
                            &lt;td&gt;{{ book_obj.publishDate|date:&#39;Y-d-m&#39; }}&lt;/td&gt;
                            &lt;td&gt;{{ book_obj.publish.name }}&lt;/td&gt;
                            &lt;td&gt;
                                {% for author in book_obj.authors.all %}
                                    {{ author.name }}
                                {% endfor %}

                            &lt;/td&gt;
                            &lt;td&gt;
                                &lt;a class=&quot;btn btn-warning&quot; href=&quot;{% url &#39;edit_book&#39; book_obj.pk  %}&quot;&gt;编辑&lt;/a&gt;
                                &lt;a class=&quot;btn btn-danger&quot; href=&quot;{% url &#39;delete_book&#39; book_obj.pk  %}&quot;&gt;删除&lt;/a&gt;
                            &lt;/td&gt;
                         &lt;/tr&gt;
                    {% endfor %}
                &lt;/tbody&gt;
            &lt;/table&gt;
        &lt;/div&gt;
    &lt;/div&gt;

&lt;/div&gt;

&lt;/body&gt;
&lt;script src=&quot;{% static &#39;bootstrap-3.3.0-dist/dist/jQuery/jquery-3.1.1.js&#39; %}&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;{% static &#39;bootstrap-3.3.0-dist/dist/js/bootstrap.min.js&#39; %}&quot;&gt;&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p>　　别忘了在settings.py中配置静态文件</p>
<pre><code><code>STATIC_URL = &#39;/static/&#39;
STATICFILES_DIRS = [
    os.path.join(BASE_DIR,&#39;statics&#39;),
]
</code></pre>
<p>　　别忘了去下载一个bootstrap和jquery然后在上面的html文件中引入一下。</p>
<p>　　models.py文件内容如下：</p>
<pre><code><code>from django.db import models

# Create your models here.


from django.db import models

# Create your models here.


class Author(models.Model):
    nid = models.AutoField(primary_key=True)
    name=models.CharField( max_length=32)
    age=models.IntegerField()
    authorDetail=models.OneToOneField(to=&quot;AuthorDetail&quot;,to_field=&quot;nid&quot;)
    def __str__(self):
        return self.name
class AuthorDetail(models.Model):

    nid = models.AutoField(primary_key=True)
    birthday=models.DateField()
    telephone=models.BigIntegerField()
    addr=models.CharField( max_length=64)

class Publish(models.Model):
    nid = models.AutoField(primary_key=True)
    name=models.CharField( max_length=32)
    city=models.CharField( max_length=32)
    email=models.EmailField()
    def __str__(self):
        return self.name

class Book(models.Model):

    nid = models.AutoField(primary_key=True)
    title = models.CharField( max_length=32)
    sex_choice = (
        (1,&#39;男&#39;),
        (2,&#39;女&#39;),
    )
    sex = models.IntegerField(choices=sex_choice,default=1)
    publishDate=models.DateField()
    price=models.DecimalField(max_digits=5,decimal_places=2)
    publish=models.ForeignKey(to=&quot;Publish&quot;,to_field=&quot;nid&quot;)
    authors=models.ManyToManyField(to=&#39;Author&#39;,)
    def __str__(self):
        return self.title
</code></pre>
<p>　　别忘了给每个表添加一些数据。</p>
<h1 id="七-modelform">七 ModelForm</h1>
<p>　　通常在Django项目中，我们编写的大部分都是与Django 的模型紧密映射的表单。 举个例子，你也许会有个Book 模型，并且你还想创建一个form表单用来添加和编辑书籍信息到这个模型中。 在这种情况下，在form表单中定义字段将是冗余的，因为我们已经在模型中定义了那些字段。</p>
<p>　　基于这个原因，Django 提供一个辅助类来让我们可以从Django 的模型创建Form，这就是ModelForm。</p>
<h2 id="modelform定义">modelForm定义</h2>
<p>　　　　form与model的终极结合，会根据你model中的字段转换成对应的form字段，并且并你生成标签等操作。</p>
<p>　　　　比如你的models中的表是下面的内容：</p>
<pre><code><code>class Book(models.Model):

    nid = models.AutoField(primary_key=True)
    title = models.CharField( max_length=32)
    publishDate=models.DateField()
    price=models.DecimalField(max_digits=5,decimal_places=2)
    publish=models.ForeignKey(to=&quot;Publish&quot;,to_field=&quot;nid&quot;)
    authors=models.ManyToManyField(to=&#39;Author&#39;,)
    def __str__(self):
        return self.title
</code></pre>
<p>　　</p>
<p>　　　　modelform类的写法。</p>
<pre><code><code>class BookForm(forms.ModelForm):

    class Meta:
        model = models.Book
        fields = &quot;__all__&quot;
        labels = {
            &quot;title&quot;: &quot;书名&quot;,
            &quot;price&quot;: &quot;价格&quot;
        }
        widgets = {
            &quot;password&quot;: forms.widgets.PasswordInput(attrs={&quot;class&quot;: &quot;c1&quot;}),
            &quot;publishDate&quot;: forms.widgets.DateInput(attrs={&quot;type&quot;: &quot;date&quot;}),
        }
</code></pre>
<h2 id="class-meta下常用参数">class Meta下常用参数：</h2>
<pre><code><code>model = models.Book  # 对应的Model中的类
fields = &quot;__all__&quot;  # 字段，如果是__all__,就是表示列出所有的字段
exclude = None  # 排除的字段
labels = None  # 提示信息
help_texts = None  # 帮助提示信息
widgets = None  # 自定义插件
error_messages = None  # 自定义错误信息
error_messages = {    &#39;title&#39;:{&#39;required&#39;:&#39;不能为空&#39;,...} #每个字段的所有的错误都可以写，...是省略的意思，复制黏贴我代码的时候别忘了删了...}
 
</code></pre>
<p>　　</p>
<p>　　批量添加样式：和form的一样</p>
<pre><code><code>class BookForm(forms.ModelForm):    #password = forms.CharField(min_length=10) #可以重写字段，会覆盖modelform中的这个字段，那么modelform下面关于这个字段的设置就会被覆盖，比如果设置插件啊，error_messages啊等等，
    r_password = forms.CharField() #想多验证一些字段可以单独拿出来写，按照form的写法，写在Meta的上面或者下面都可以
    class Meta:
        model = models.Book
        # fields = [&#39;title&#39;,&#39;price&#39;]
        fields = &quot;__all__&quot; #[&#39;title,&#39;price&#39;] 指定字段生成form
        # exclude=[&#39;title&#39;,] #排除字段
        labels = {
            &quot;title&quot;: &quot;书名&quot;,
            &quot;price&quot;: &quot;价格&quot;
        }
        error_messages = {
            &#39;title&#39;:{&#39;required&#39;:&#39;不能为空&#39;,} #每个字段的错误都可以写
        }
    #如果models中的字段和咱们需要验证的字段对不齐的是，比如注册时，咱们需要验证密码和确认密码两个字段数据，但是后端数据库就保存一个数据就行，那么验证是两个，数据保存是一个，就可以再接着写form字段
    r_password = forms.CharField()。    #同样的，如果想做一些特殊的验证定制，那么和form一昂，也是那两个钩子（全局和局部），写法也是form那个的写法，直接在咱们的类里面写：    #局部钩子：    def clean_title(self):        pass　　#全局钩子    def clean(self):        pass
    def __init__(self,*args,**kwargs): #批量操作
        super().__init__(*args,**kwargs)
        for field in self.fields:            #field.error_messages = {&#39;required&#39;:&#39;不能为空&#39;} #批量添加错误信息,这是都一样的错误，不一样的还是要单独写。
            self.fields[field].widget.attrs.update({&#39;class&#39;:&#39;form-control&#39;})
</code></pre>
<h2 id="modelform的验证">ModelForm的验证</h2>
<p>　　　　与普通的Form表单验证类型类似，ModelForm表单的验证在调用is_valid() 或访问errors 属性时隐式调用。</p>
<p>　　　　我们可以像使用Form类一样自定义局部钩子方法和全局钩子方法来实现自定义的校验规则。</p>
<p>　　　　如果我们不重写具体字段并设置validators属性的话，ModelForm是按照模型中字段的validators来校验的。</p>
<h2 id="save方法">save()方法</h2>
<p>　　　　每个ModelForm还具有一个save()方法。 这个方法根据表单绑定的数据创建并保存数据库对象。 ModelForm的子类可以接受现有的模型实例作为关键字参数instance；如果提供此功能，则save()将更新该实例。 如果没有提供，save() 将创建模型的一个新实例：</p>
<pre><code><code>&gt;&gt;&gt; from myapp.models import Book
&gt;&gt;&gt; from myapp.forms import BookForm

# 根据POST数据创建一个新的form对象
&gt;&gt;&gt; form_obj = BookForm(request.POST)

# 创建书籍对象
&gt;&gt;&gt; new_ book = form_obj.save()

# 基于一个书籍对象创建form对象
&gt;&gt;&gt; edit_obj = Book.objects.get(id=1)
# 使用POST提交的数据更新书籍对象
&gt;&gt;&gt; form_obj = BookForm(request.POST, instance=edit_obj)
&gt;&gt;&gt; form_obj.save()
</code></pre>
<p>　　之前我们通过form组件来保存书籍表数据的时候的写法：</p>
<pre><code><code>def index(request):
    if request.method == &#39;GET&#39;:
        form_obj = BookForm()

        return render(request,&#39;index.html&#39;,{&#39;form_obj&#39;:form_obj})

    else:
        form_obj = BookForm(request.POST)
        if form_obj.is_valid():
            # authors_obj = form_obj.cleaned_data.pop(&#39;authors&#39;)
            # new_book_obj = models.Book.objects.create(**form_obj.cleaned_data)
            # new_book_obj.authors.add(*authors_obj)
            form_obj.save()  #因为我们再Meta中指定了是哪张表，所以它会自动识别，不管是外键还是多对多等，都会自行处理保存，它完成的就是上面三句话做的事情，并且还有就是如果你验证的数据比你后端数据表中的字段多，那么他自会自动剔除多余的不需要保存的字段，比如那个重复确认密码就不要保存
            return redirect(&#39;show&#39;)

        else:
            print(form_obj.errors)
            return render(request,&#39;index.html&#39;,{&#39;form_obj&#39;:form_obj})
</code></pre>
<p>比如说我们图书管理系统页面之前是这样写的</p>
<pre><code><code>{% load static %}
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;{% static &#39;bootstrap-3.3.0-dist/dist/css/bootstrap.min.css&#39; %}&quot;&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1&gt;编辑页面&lt;/h1&gt;
&lt;div class=&quot;container-fluid&quot;&gt;
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-md-6 col-md-offset-3&quot;&gt;
            &lt;form action=&quot;&quot;&gt;
                &lt;div class=&quot;form-group&quot;&gt;
                    &lt;label for=&quot;title&quot;&gt;书名&lt;/label&gt;
                    &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;title&quot; placeholder=&quot;title&quot; value=&quot;{{ book_obj.title }}&quot;&gt;

                &lt;/div&gt;
                &lt;div class=&quot;form-group&quot;&gt;
                    &lt;label for=&quot;publishDate&quot;&gt;出版日期&lt;/label&gt;
                    &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;publishDate&quot; placeholder=&quot;publishDate&quot; value=&quot;{{ book_obj.publishDate|date:&#39;Y-m-d&#39; }}&quot;&gt;

                &lt;/div&gt;
                &lt;div class=&quot;form-group&quot;&gt;
                    &lt;label for=&quot;price&quot;&gt;价格&lt;/label&gt;
                    &lt;input type=&quot;number&quot; class=&quot;form-control&quot; id=&quot;price&quot; placeholder=&quot;price&quot; value=&quot;{{ book_obj.price }}&quot;&gt;

                &lt;/div&gt;
                &lt;div class=&quot;form-group&quot;&gt;
                    &lt;label for=&quot;publish&quot;&gt;书名&lt;/label&gt;
                    &lt;select name=&quot;publish&quot; id=&quot;publish&quot; class=&quot;form-control&quot;&gt;
                        {% for publish in all_publish %}
                                {% if publish == book_obj.publish %}
                                    &lt;option value=&quot;{{ publish.id }}&quot; selected&gt;{{ publish.name }}&lt;/option&gt;
                                {% else %}
                                    &lt;option value=&quot;{{ publish.id }}&quot;&gt;{{ publish.name }}&lt;/option&gt;
                                {% endif %}
                        {% endfor %}

                    &lt;/select&gt;

                &lt;/div&gt;
                &lt;div class=&quot;form-group&quot;&gt;
                    &lt;label for=&quot;authors&quot;&gt;书名&lt;/label&gt;
                    &lt;select name=&quot;authors&quot; id=&quot;authors&quot; multiple class=&quot;form-control&quot;&gt;
                        {% for author in all_authors %}
                            {% if author in book_obj.authors.all %}
                                &lt;option value=&quot;{{ author.id }}&quot; selected&gt;{{ author.name }}&lt;/option&gt;
                            {% else %}
                                 &lt;option value=&quot;{{ author.id }}&quot; &gt;{{ author.name }}&lt;/option&gt;
                            {% endif %}
                        {% endfor %}

                    &lt;/select&gt;

                &lt;/div&gt;
            &lt;/form&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;


&lt;/body&gt;
&lt;script src=&quot;{% static &#39;bootstrap-3.3.0-dist/dist/jQuery/jquery-3.1.1.js&#39; %}&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;{% static &#39;bootstrap-3.3.0-dist/dist/js/bootstrap.min.js&#39; %}&quot;&gt;&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p>views.py是这样写的：</p>
<pre><code><code>def edit_book(request,n):

    book_obj = models.Book.objects.filter(pk=n).first()
    if request.method == &#39;GET&#39;:
        all_authors = models.Author.objects.all() #
        all_publish = models.Publish.objects.all()

        return render(request,&#39;edit_book.html&#39;,{&#39;book_obj&#39;:book_obj,&#39;all_authors&#39;:all_authors,&#39;all_publish&#39;:all_publish})
</code></pre>
<p>改成使用modelform之后，我们这样写：</p>
<pre><code><code>{% load static %}
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
    &lt;link rel=&quot;stylesheet&quot; href=&quot;{% static &#39;bootstrap-3.3.0-dist/dist/css/bootstrap.min.css&#39; %}&quot;&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1&gt;编辑页面&lt;/h1&gt;
&lt;div class=&quot;container-fluid&quot;&gt;
    &lt;div class=&quot;row&quot;&gt;
        &lt;div class=&quot;col-md-6 col-md-offset-3&quot;&gt;
            &lt;form action=&quot;{% url &#39;edit_book&#39; n %}&quot; novalidate method=&quot;post&quot;&gt;
                {% csrf_token %}
                {% for field in form %}
                    &lt;div class=&quot;form-group&quot;&gt;
                        &lt;label for=&quot;{{ field.id_for_label }}&quot;&gt;{{ field.label }}&lt;/label&gt;
                        {{ field }}
                        &lt;span class=&quot;text-danger&quot;&gt;{{ field.errors.0 }}&lt;/span&gt;
                    &lt;/div&gt;
                {% endfor %}

                &lt;div class=&quot;form-group&quot;&gt;
                    &lt;input type=&quot;submit&quot; class=&quot;btn btn-primary pull-right&quot;&gt;
                &lt;/div&gt;

            &lt;/form&gt;

        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;


&lt;/body&gt;
&lt;script src=&quot;{% static &#39;bootstrap-3.3.0-dist/dist/jQuery/jquery-3.1.1.js&#39; %}&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;{% static &#39;bootstrap-3.3.0-dist/dist/js/bootstrap.min.js&#39; %}&quot;&gt;&lt;/script&gt;
&lt;/html&gt;
</code></pre>
<p>views.py这样写：</p>
<pre><code><code>def edit_book(request,n):

    book_obj = models.Book.objects.filter(pk=n).first()
    if request.method == &#39;GET&#39;:
        # all_authors = models.Author.objects.all() #
        # all_publish = models.Publish.objects.all()

        form = BookForm(instance=book_obj)

        return render(request,&#39;edit_book.html&#39;,{&#39;form&#39;:form,&#39;n&#39;:n}) #传递的这个n参数是给form表单提交数据的是的action的url用的，因为它需要一个参数来识别是更新的哪条记录

    else:
        form = BookForm(request.POST,instance=book_obj) #必须指定instance，不然我们调用save方法的是又变成了添加操作
        if form.is_valid():
            form.save()
            return redirect(&#39;show&#39;)
        else:
            return render(request,&#39;edit_book.html&#39;,{&#39;form&#39;:form,&#39;n&#39;:n})
</code></pre>
<h2 id="创建modelform">创建modelform</h2>
<p>　　这是一个神奇的组件，通过名字我们可以看出来，这个组件的功能就是把model和form组合起来，先来一个简单的例子来看一下这个东西怎么用：比如我们的数据库中有这样一张学生表，字段有姓名，年龄，爱好，邮箱，电话，住址，注册时间等等一大堆信息，现在让你写一个创建学生的页面，你的后台应该怎么写呢？首先我们会在前端一个一个罗列出这些字段，让用户去填写，然后我们从后天一个一个接收用户的输入，创建一个新的学生对象，保存其实，重点不是这些，而是合法性验证，我们需要在前端判断用户输入是否合法，比如姓名必须在多少字符以内，电话号码必须是多少位的数字，邮箱必须是邮箱的格式这些当然可以一点一点手动写限制，各种判断，这毫无问题，除了麻烦我们现在有个更优雅（以后在Python相关的内容里，要多用“优雅”这个词，并且养成习惯）的方法：ModelForm先来简单的，生硬的把它用上，再来加验证条件。</p>
<pre><code><code>#首先导入ModelForm

from django.forms import ModelForm
#在视图函数中，定义一个类，比如就叫StudentList，这个类要继承ModelForm，在这个类中再写一个原类Meta（规定写法，并注意首字母是大写的）
#在这个原类中，有以下属性（部分）：

class StudentList(ModelForm):
    class Meta:
        model =Student #对应的Model中的类
        fields = &quot;__all__&quot; #字段，如果是__all__,就是表示列出所有的字段
        exclude = None #排除的字段
        #error_messages用法：
        error_messages = {
        &#39;name&#39;:{&#39;required&#39;:&quot;用户名不能为空&quot;,},
        &#39;age&#39;:{&#39;required&#39;:&quot;年龄不能为空&quot;,},
        }
        #widgets用法,比如把输入用户名的input框给为Textarea
        #首先得导入模块
        from django.forms import widgets as wid #因为重名，所以起个别名
        widgets = {
        &quot;name&quot;:wid.Textarea(attrs={&quot;class&quot;:&quot;c1&quot;}) #还可以自定义属性
        }
        #labels，自定义在前端显示的名字
        labels= {
        &quot;name&quot;:&quot;用户名&quot;
        }
</code></pre>
<p>　　　　然后在url对应的视图函数中实例化这个类，把这个对象传给前端</p>
<pre><code><code>def student(request):

    if request.method == &#39;GET&#39;:
        student_list = StudentList()
        return render(request,&#39;student.html&#39;,{&#39;student_list&#39;:student_list})
        
</code></pre>
<p>　　　　然后前端只需要 {{ student_list.as_p }} 一下，所有的字段就都出来了，可以用as_p显示全部，也可以通过for循环这<br />
　　　　student_list，拿到的是一个个input框，现在我们就不用as_p，手动把这些input框搞出来，as_p拿到的页面太丑。<br />
　　　　首先 for循环这个student_list，拿到student对象，直接在前端打印这个student，是个input框student.label ，拿到数据库中每个字段的verbose_name ,如果没有设置这个属性，拿到的默认就是字段名，还可以通过student.errors.0 拿到错误信息有了这些，我们就可以通过bootstrap，自己拼出来想要的样式了，比如：</p>
<pre><code><code>&lt;body&gt;
&lt;div class=&quot;container&quot;&gt;
    &lt;h1&gt;student&lt;/h1&gt;
    &lt;form method=&quot;POST&quot; novalidate&gt;
        {% csrf_token %}
        {# {{ student_list.as_p }}#}
        {% for student in student_list %}
            &lt;div class=&quot;form-group col-md-6&quot;&gt;
                {# 拿到数据字段的verbose_name,没有就默认显示字段名 #}
                &lt;label class=&quot;col-md-3 control-label&quot;&gt;{{ student.label }}&lt;/label&gt;
                &lt;div class=&quot;col-md-9&quot; style=&quot;position: relative;&quot;&gt;{{ student }}&lt;/div&gt;
            &lt;/div&gt;
        {% endfor %}
        &lt;div class=&quot;col-md-2 col-md-offset-10&quot;&gt;
            &lt;input type=&quot;submit&quot; value=&quot;提交&quot; class=&quot;btn-primary&quot;&gt;
        &lt;/div&gt;
    &lt;/form&gt;
&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<p>　　　　现在还缺一个input框的form-contral样式，可以考虑在后台的widget里面添加<br />
　　　　比如这样：</p>
<pre><code><code>from django.forms import widgets as wid #因为重名，所以起个别名
widgets = {
&quot;name&quot;:wid.TextInput(attrs={&#39;class&#39;:&#39;form-control&#39;}),
&quot;age&quot;:wid.NumberInput(attrs={&#39;class&#39;:&#39;form-control&#39;}),
&quot;email&quot;:wid.EmailInput(attrs={&#39;class&#39;:&#39;form-control&#39;})
}
</code></pre>
<p>　　　　当然也可以在js中，找到所有的input框，加上这个样式，也行。</p>
<h2 id="添加纪录">添加纪录</h2>
<p>　　　　保存数据的时候，不用挨个取数据了，只需要save一下</p>
<pre><code><code>def student(request):

    if request.method == &#39;GET&#39;:
         student_list = StudentList()
         return render(request,&#39;student.html&#39;,{&#39;student_list&#39;:student_list})
    else:
         student_list = StudentList(request.POST)
         if student_list.is_valid():
         student_list.save()
         return redirect(request,&#39;student_list.html&#39;,{&#39;student_list&#39;:student_list})
</code></pre>
<h2 id="编辑数据">编辑数据</h2>
<p>　　　　如果不用ModelForm，编辑的时候得显示之前的数据吧，还得挨个取一遍值，如果ModelForm，只需要加一个instance=obj（obj是要修改的数据库的一条数据的对象）就可以得到同样的效果<br />
　　　　保存的时候要注意，一定要注意有这个对象（instance=obj），否则不知道更新哪一个数据<br />
　　　　代码示例：</p>
<pre><code><code>from django.shortcuts import render,HttpResponse,redirect
from django.forms import ModelForm
# Create your views here.
from app01 import models
def test(request):
    # model_form = models.Student
    model_form = models.Student.objects.all()
    return render(request,&#39;test.html&#39;,{&#39;model_form&#39;:model_form})

class StudentList(ModelForm):
    class Meta:
        model = models.Student #对应的Model中的类
        fields = &quot;__all__&quot; #字段，如果是__all__,就是表示列出所有的字段
        exclude = None #排除的字段
        labels = None #提示信息
        help_texts = None #帮助提示信息
        widgets = None #自定义插件
        error_messages = None #自定义错误信息
        #error_messages用法：
        error_messages = {
        &#39;name&#39;:{&#39;required&#39;:&quot;用户名不能为空&quot;,},
        &#39;age&#39;:{&#39;required&#39;:&quot;年龄不能为空&quot;,},
        }
        #widgets用法,比如把输入用户名的input框给为Textarea
        #首先得导入模块
        from django.forms import widgets as wid #因为重名，所以起个别名
        widgets = {
        &quot;name&quot;:wid.Textarea
        }
        #labels，自定义在前端显示的名字
        labels= {
        &quot;name&quot;:&quot;用户名&quot;
        }
def student(request):
    if request.method == &#39;GET&#39;:
        student_list = StudentList()
        return render(request,&#39;student.html&#39;,{&#39;student_list&#39;:student_list})
    else:
        student_list = StudentList(request.POST)
        if student_list.is_valid():
            student_list.save()
            return render(request,&#39;student.html&#39;,{&#39;student_list&#39;:student_list})

def student_edit(request,pk):
    obj = models.Student.objects.filter(pk=pk).first()
    if not obj:
        return redirect(&#39;test&#39;)
    if request.method == &quot;GET&quot;:
        student_list = StudentList(instance=obj)
        return render(request,&#39;student_edit.html&#39;,{&#39;student_list&#39;:student_list})
    else:
        student_list = StudentList(request.POST,instance=obj)
        if student_list.is_valid():
            student_list.save()
            return render(request,&#39;student_edit.html&#39;,{&#39;student_list&#39;:student_list})
</code></pre>
<p>　　总结： 从上边可以看到ModelForm用起来是非常方便的，比如增加修改之类的操作。但是也带来额外不好的地方，model和form之间耦合了。如果不耦合的话，mf.save()方法也无法直接提交保存。 但是耦合的话使用场景通常局限用于小程序，写大程序就最好不用了。</p>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>