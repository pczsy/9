<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修python — lambda表达式与内置函数' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>python — lambda表达式与内置函数</center></div><div class='banquan'>原文出处:本文由博客园博主一直努力的小羊提供。<br/>
原文连接:https://www.cnblogs.com/yangjie0906/p/11215765.html</div><br>
    <div class="toc">
    <p class="toc-title">目录</p>
    <div class="toc-list">
        <ul>
        <li><a href="#lambda表达式-匿名函数">1 lambda表达式 （匿名函数）</a></li>
        <li><a href="#内置函数">2 内置函数</a></li>
        </ul>
    </div>
</div>
<h3 id="lambda表达式-匿名函数">1 lambda表达式 （匿名函数）</h3>
<p>用于表示简单的函数</p>
<p>lambda表达式，为了解决简单函数的情况：</p>
<pre><code><code>def func(a1,a2):       =====&gt; func = lambda a1,a2:a1+a2  # 函数直接得到返回值，这里隐藏了return
    return a1+a2       简化</code></pre>
<pre><code><code># 三元运算，为了解决简单的if else的情况，如：
if 1 == 1:
    a = 123
else:
    a = 456

a =  123  if 1 == 1 else 456

# lambda表达式，为了解决简单函数的情况，如：
def func(a1,a2):
    return a1 + 100 

func = lambda a1,a2: a1+100</code></pre>
<pre><code><code>func1 = lambda : 100 

func2 = lambda x1: x1 * 10

func3 = lambda *args,**kwargs: len(args) + len(kwargs)

DATA = 100
func4 = lambda a1: a1 + DATA
v = func4(1)
print(v)

DATA = 100
def func():
    DATA = 1000
    func4 = lambda a1: a1 + DATA
    v = func4(1)
    print(v)
func()

func5 = lambda n1,n2: n1 if n1 &gt; n2 else n2
v = func5(1111,2)
print(v)</code></pre>
<p>lambda表达式只能用一行来表示函数，只能用参数来作为变量。</p>
<p>练习题</p>
<pre><code><code># 练习题1
USER_LIST = []
def func0(x):
    v = USER_LIST.append(x)
    return v 

result = func0(&#39;alex&#39;)
print(result)


# 练习题2

def func0(x):
    v = x.strip()
    return v 

result = func0(&#39; alex &#39;)
print(result)

############## 总结：列表所有方法基本上都是返回None；字符串的所有方法基本上都是返回新值 #################
# 练习题3
USER_LIST = []
func1 = lambda x: USER_LIST.append(x)

v1 = func1(&#39;alex&#39;)
print(v1)
print(USER_LIST)

# 练习题4
func1 = lambda x: x.split(&#39;l&#39;)

v1 = func1(&#39;alex&#39;)
print(v1)

# 练习题5
func_list = [lambda x:x.strip(), lambda y:y+199,lambda x,y:x+y]

v1 = func_list[0](&#39;alex &#39;)
print(v1)

v2 = func_list[1](100)
print(v2)

v3 = func_list[2](1,2)
print(v3)</code></pre>
<p>总结：</p>
<p>列表所有方法基本上都是返回None，字符串的所有方法基本上都是返回新值。</p>
<h3 id="内置函数">2 内置函数</h3>
<p>函数分为：自定义函数 和 内置函数</p>
<p>目前python的内置函数分为几大类：</p>
<ul>
<li><p>1.强制转换</p>
<p>bool() / int() / str() / list() / dict() /tuple() / set()</p></li>
<li><p>2.输入输出</p>
<p>print() / input()</p></li>
<li><p>3.其他</p>
<p>len() / open() / id() / range() / type()</p></li>
<li><p>4.数学相关</p>
<ul>
<li><ol>
<li><p>abs() 绝对值</p>
<pre><code><code>v = abs(-1)
print(v)   # 1</code></pre></li>
<li><p>float() 转换成浮点型（小数）</p>
<pre><code><code>v = 55
v1 = float(v)
print(v1)    # 55.0</code></pre></li>
<li><p>max() 找到最大值</p>
<pre><code><code>v = [1,2,33,5,9]
result = max(v)
print(result)   # 33</code></pre></li>
<li><p>min() 找到最小值</p>
<pre><code><code>v = [1,2,311,11,8]
v2 = min(v)
print(v2)  # 1</code></pre></li>
<li><p>sum() 求和</p>
<pre><code><code>v = [1,2,311,11,9]
v1 = sum(v)
print(v1)  # 334</code></pre></li>
<li><p>divmod() 两数相除的商和余数</p>
<pre><code><code>a,b = divmod(1001,5)
print(a,b)   # 200  1</code></pre>
<p>补充：字符串格式化：'你少妻-%s' %(i,) ------&gt;后面%(i,)如果括号中只有一个变量，可以写成：'你少妻-%s' %i</p>
<pre><code><code># 练习题  请通过分页对数据进行展示
&quot;&quot;&quot;
要求：
    每页显示10条数据
    让用户输入要查看的页面：页码
&quot;&quot;&quot;

USER_LIST = []
for i in range(1,836):
    temp = {&#39;name&#39;:&#39;你少妻-%s&#39; %i,&#39;email&#39;:&#39;123%s@qq.com&#39; %i }
    USER_LIST.append(temp)

# 数据总条数
total_count = len(USER_LIST)

# 每页显示10条
per_page_count= 10

# 总页码数
max_page_num,a = divmod(total_count,per_page_count)
if a&gt;0:
    max_page_num += 1

while True:
    pager = int(input(&#39;要查看第几页：&#39;))
    if pager &lt; 1 or pager &gt; max_page_num:
        print(&#39;页码不合法，必须是 1 ~ %s&#39; %max_page_num )
    else:
        &quot;&quot;&quot;
        # 第1页：USER_LIST[0:10] -&gt; 0123456789
        # 第2页：USER_LIST[10:20]
        # 第3页：USER_LIST[20:30]
        ...
        &quot;&quot;&quot;
        start = (pager-1) * per_page_count
        end = pager * per_page_count
        data = USER_LIST[start:end]
        for item in data:
            print(item)</code></pre></li>
</ol>
<ul>
<li><p>7.pow</p>
<p>pow(x,y) 表示x的y次方</p>
<pre><code><code>v = pow(2,3)
print(v)   # 8</code></pre></li>
<li><p>8.round 保留小数点后几位小数，还会四舍五入。</p>
<pre><code><code>V = round(1.127,1/2)
print(v)   # 1.1 / 1.13</code></pre></li>
</ul></li>
</ul></li>
<li><p>5.进制转换相关</p>
<ul>
<li><p>bin() 将十进制转换成二进制</p>
<pre><code><code>num = 13
v1 = bin(num)
print(v1)  # 0b1101</code></pre></li>
<li><p>oct() 将十进制转换成八进制</p>
<pre><code><code>num = 8
v1 = oct(num)
print(v1)  # 0o10</code></pre></li>
<li><p>int() 将其他的进制转换成十进制</p>
<pre><code><code># 二进制转化成十进制
v1 = &#39;0b1101&#39;
result = int(v1,base=2)
print(result)  # 13

# 八进制转化成十进制
v1 = &#39;0o1101&#39;
result = int(v1,base=8)
print(result)

# 十六进制转化成十进制
v1 = &#39;0x1101&#39;
result = int(v1,base=16)
print(result)</code></pre></li>
<li><p>hex() 将十进制转换成十六进制</p>
<pre><code><code>num = 16
v1 = hex(num)
print(v1)  # 0x10</code></pre>
<p>练习题</p>
<pre><code><code># 1字节等于8位
# IP: 192.168.12.79  -&gt;  001010010 . 001010010 . 001010010 . 001010010

# 1. 请将 ip = &quot;192.168.12.79&quot; 中的每个十进制数转换成二进制并通过,连接起来生成一个新的字符串。
ip = &quot;192.168.12.79&quot;
ip_list = ip.split(&#39;.&#39;) # [&#39;192&#39;,&#39;168&#39;,&#39;12&#39;,&#39;79&#39;]
result = []
for item in ip_list:
    result.append(bin(int(item)))
print(&#39;,&#39;.join(result))


# 2. 请将 ip = &quot;192.168.12.79&quot; 中的每个十进制数转换成二进制: 
#          0010100100001010010001010010001010010 -&gt; 十进制的值。

# 3232238671

ip = &quot;192.168.12.79&quot;
ip1 = ip.split(&#39;.&#39;)
lis = []
for i in ip1: 
    lis.append(bin(int(i)))
# val = &#39;,&#39;.join(lis)
# b = val.replace(&#39;0b&#39;, &#39;&#39;)
# b1 = b.split(&#39;,&#39;)
b1 = &#39;,&#39;.join(lis).replace(&#39;0b&#39;, &#39;&#39;).split(&#39;,&#39;)
e = []
#f or c in b1:
for c in &#39;,&#39;.join(lis).replace(&#39;0b&#39;, &#39;&#39;).split(&#39;,&#39;):
    if len(c) &lt; 8:
        val = 8 - len(c)
        d = list(c)
        d.insert(0,&#39;0&#39; * val)
        d1 = &#39;&#39;.join(d)
        e.append(d1)
    else:
        e.append(c)
f = &#39;&#39;.join(e)
f1 = int(f,base = 2 )
print(f1)</code></pre></li>
</ul></li>
<li><p>6.编码相关</p>
<ul>
<li><p>chr 将十进制数字转换成Unicode编码中的对应字符串</p>
<pre><code><code>v = chr(65)
print(v)   # A</code></pre></li>
<li><p>ord 根据字符在Unicode编码中找到其对应的十进制</p>
<pre><code><code>v = ord(&#39;中&#39;)
print(v)    # 20013</code></pre></li>
<li><p>应用：</p>
<pre><code><code>import random

v = random.randint(65,90)
print(v)   # 随机获得65~90之间的数字


import random

data = []
for i in range(6)
    v = random.randint(65,90)
    data.append(chr(v))
print(&#39;&#39;.join(data))   # 6位随机字符串验证码


import random

def get_random_code(length=6):
    data = []
    for i in range(length):
        v = random.randint(65,90)
        data.append(chr(v))

    return  &#39;&#39;.join(data)


code = get_random_code()
print(code)    # 6位随机字符串验证码</code></pre>
<pre><code><code>import random # 导入一个模块 

v = random.randint(起始,终止) # 得到一个随机数</code></pre></li>
</ul></li>
<li><p>7.高级一点的内置函数</p>
<ul>
<li><p>map 循环每个元素（第二个参数），然后让每个元素执行函数（第一个参数），将每个函数执行的结果保存到新的列表中，并返回。</p>
<pre><code><code>V1 = [11,22,33,44]
# map(x,v1) 第一个参数必须是函数，第二个参数必须是可迭代类型（可以被for循环的）
def func(arg):
    print(arg)
# map(func,v1)    # 执行后并不打印arg,这是py3的一个特性，py3现在还不执行以后会执行
result = map(func,v1)  # 然后将函数的返回值添加到一个[]中

# print(result)  py2会直接返回列表
# print(result)  py3不会，会得到一个对象/东西，想返回列表的话需要强制转换成列表

print(list(ruselt))  # result得到的是一个对象&lt;map.objecta……&gt;，需要list()才能打印列表</code></pre>
<pre><code><code>v1 = [11,22,33,44]
result = map(lambda x:x+100,v1)
print(list(result)) # 特殊</code></pre></li>
<li><p>filter</p>
<p>result = filter(函数，参数)</p>
<pre><code><code>v1 = [11,22,33,&#39;asd&#39;,44,&#39;xf&#39;]

def func(x):
    if type(x) == int:
        return True
    return False
result = filter(func,v1) # [11,22,33,44]
print(list(result))


result = filter(lambda x: True if type(x) == int else False ,v1)
print(list(result))

result = filter(lambda x: type(x) == int ,v1)
print(list(result))</code></pre></li>
<li><p>reduce 累计得到一个结果</p>
<p>reduce现在不在py3的内置函数种了 ，但py2的内置函数里包含。</p>
<pre><code><code>import functools
v1 = [&#39;wo&#39;,&#39;hao&#39;,&#39;e&#39;]

def func(x,y):
    return x+y
result = functools.reduce(func,v1) 
print(result)

result = functools.reduce(lambda x,y:x+y,v1)
print(result)</code></pre></li>
</ul></li>
<li><p>8.类相关的</p>
<ul>
<li><ol>
<li><p>type，查看类型</p>
<pre><code><code>class Foo:
    pass

obj = Foo()

if type(obj) == Foo:
    print(&#39;obj是Foo类的对象&#39;)</code></pre></li>
<li><p>issubclass</p>
<p>判断某个类是不是另一个类或其基类的子类。</p>
<p>issubclass(类1，类2) 类1—&gt;子类名，类2—&gt;基类名</p>
<pre><code><code>class Base:
    pass

class Base1(Base):
    pass

class Foo(Base1):
    pass

class Bar:
    pass

print(issubclass(Bar,Base))
print(issubclass(Foo,Base))</code></pre></li>
<li><h4 id="isinstance">isinstance</h4>
<p>判断某个对象是否是某个类或其基类的实例（对象）</p>
<pre><code><code>class Base(object):
    pass

class Foo(Base):
    pass

obj = Foo()

print(isinstance(obj,Foo))  # 判断obj是否是Foo类或其基类的实例（对象）
print(isinstance(obj,Base)) # 判断obj是否是Foo类或其基类的实例（对象）</code></pre></li>
<li><h3 id="super">super</h3>
<pre><code><code>class Base(object):
    def func(self):
        print(&#39;base.func&#39;)
        return 123


class Foo(Base):
    def func(self):
        v1 = super().func()
        print(&#39;foo.func&#39;,v1)

obj = Foo()
obj.func()
# super().func() 去父类中找func方法并执行</code></pre>
<pre><code><code>class Bar(object):
    def func(self):
        print(&#39;bar.func&#39;)
        return 123

class Base(Bar):
    pass

class Foo(Base):
    def func(self):
        v1 = super().func()
        print(&#39;foo.func&#39;,v1)

obj = Foo()
obj.func()
# super().func() 根据类的继承关系，按照顺序挨个找func方法并执行(找到第一个就不在找了)</code></pre>
<pre><code><code>class Base(object): # Base -&gt; object
    def func(self):
        super().func()
        print(&#39;base.func&#39;)

class Bar(object):
    def func(self):
        print(&#39;bar.func&#39;)

class Foo(Base,Bar): # Foo -&gt; Base -&gt; Bar
    pass

obj = Foo()
obj.func()

# 多继承
# super().func() 根据self对象所属类的继承关系，按照顺序挨个找func方法并执行(找到第一个就不在找了)</code></pre>
<p>super().要查找的方法</p>
<p>super().func() 根据self对象所属类的继承关系（从左向右依次查找），按照顺序挨个找func方法并执行(找到第一个就不再找了)</p>
<p>super 遵循mro顺序查找上一个类的</p>
<p>supper().func()不是查找父类，而是根据mro顺序，找到自己对应的下一个类</p></li>
</ol></li>
</ul></li>
</ul>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>