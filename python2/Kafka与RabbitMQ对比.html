<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Kafka与RabbitMQ对比' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Kafka与RabbitMQ对比</center></div><div class='banquan'>原文出处:本文由博客园博主Infi_chu提供。<br/>
原文连接:https://www.cnblogs.com/Infi-chu/p/11378006.html</div><br>
    <p>&nbsp;Infi-chu:</p>
<p><a href="http://www.cnblogs.com/Infi-chu/" target="_blank">http://www.cnblogs.com/Infi-chu/</a></p>
<p>&nbsp;</p>
<p>Kafka是LinkedIn在2012年发布的开源的消息发布订阅系统，他主要用于处理活跃的流式数据、大数据量的数据处理上</p>
<p>RabbitMQ由Erlang语言开发，主要用在实时的对可靠性要求较高的消息传递上</p>
<p>1.架构模型</p>
<ul>
<li>RabbitMQ遵循AMQP协议，RabbitMQ的borker由Exchange、Binding和Queue组成，其中Exchange和Binding组成了消息的路由键，客户端Producer通过连接channel和server进行通信，Consumer从queue获取消息进行消费，有消息确认机制</li>
<li>Kafka遵循从一般的MQ结构，producer、broker、consumer为中心，消息的消费信息保存在客户端consumer上，consumer根据消费的点，从broker上批量pull数据，无消息确认机制</li>
</ul>
<p>2.吞吐量</p>
<ul>
<li>RabbitMQ吞吐量较低，RabbitMQ支持对消息的可靠传递，支持事物，不支持批量的操作，基于存储的可靠性要求存储可以采用内存或硬盘</li>
<li>Kafka吞吐量较高，内部采用消息的批量处理，zero-copy机制，数据的存储和获取时候本地磁盘顺序批量操作，复杂度为o(1)，消息处理效率较高</li>
</ul>
<p>3.可用性</p>
<ul>
<li>RabbitMQ支持miror和queue，当主queue失效时，miror queue接管</li>
<li>Kafka的broker支持主备模式</li>
</ul>
<p>4.负载均衡</p>
<ul>
<li>RabbitMQ的负载均衡需要单独的loadbalance进行支持</li>
<li>Kafka采用zookeeper对集群中的broker、consumer进行管理，可以注册topic到zookeeper上；通过zookeeper的协调机制，producer保存对应的topic的broker信息，可以随机或轮询发送到broker上，并且producer可以基于语义指定分片，消息发送到broker的某个分片上</li>
</ul>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>