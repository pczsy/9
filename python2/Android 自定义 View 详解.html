<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Android 自定义 View 详解' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Android 自定义 View 详解</center></div><div class='banquan'>原文出处:本文由博客园博主huansky提供。<br/>
原文连接:https://www.cnblogs.com/huansky/p/11808234.html</div><br>
    <h3>View 的绘制系列文章：</h3>
<ul>
<li>
<h3><span style="color: #ff0000;"><a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/huansky/p/11911549.html"><span style="color: #ff0000;">Android View 绘制流程之 DecorView 与 ViewRootImpl</span></a></span></h3>
</li>
<li>
<h3><span style="color: #ff0000;"><a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/huansky/p/11920454.html"><span style="color: #ff0000;">Android View 的绘制流程之 Measure 过程详解 (一)</span></a></span></h3>
</li>
<li>
<h3><span style="color: #ff0000;"><a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/huansky/p/12000771.html"><span style="color: #ff0000;">Android View 的绘制流程之 Layout 和 Draw 过程详解 (二)</span></a></span></h3>
</li>
<li>
<h3><span style="color: #ff0000;"><a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/huansky/p/9656394.html"><span style="color: #ff0000;">Android View 的事件分发原理解析</span></a></span></h3>
</li>
</ul>
<ul>
<li>
<h3><span style="color: #ff0000;"><a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/huansky/p/9656394.html"></a><a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/huansky/p/11808234.html"><span style="color: #ff0000;">Android 自定义 View 详解</span></a></span></h3>
</li>
</ul>
<p>对于 Android 开发者来说，原生控件往往无法满足要求，需要开发者自定义一些控件，因此，需要去了解自定义 view 的实现原理。这样即使碰到需要自定义控件的时候，也可以游刃有余。</p>
<div>
<h1 style="background-color: #33cccc;">基础知识</h1>
<h2 style="background-color: #33ccff;">自定义 View 分类</h2>
<p>自定义 View 的实现方式有以下几种：</p>
<table style="height: 127px; width: 666px;" border="0">
<tbody>
<tr>
<td>类型</td>
<td>定义</td>
</tr>
<tr>
<td>自定义组合控件</td>
<td>多个控件组合成为一个新的控件，方便多处复用</td>
</tr>
<tr>
<td>继承系统 View 控件</td>
<td>继承自TextView等系统控件，在系统控件的基础功能上进行扩展</td>
</tr>
<tr>
<td>继承 View</td>
<td>不复用系统控件逻辑，继承View进行功能定义</td>
</tr>
<tr>
<td>继承系统 ViewGroup</td>
<td>继承自LinearLayout等系统控件，在系统控件的基础功能上进行扩展</td>
</tr>
<tr>
<td>继承 View ViewGroup</td>
<td>不复用系统控件逻辑，继承ViewGroup进行功能定义</td>
</tr>
</tbody>
</table>
<p>从上到下越来越难，需要的了解的知识也是越来越多的。</p>
<h3 style="background-color: #33ffff;">构造函数</h3>
<p>当我们在自定义 View 的时候，构造函数都是不可缺少，需要对构造函数进行重写，构造函数有多个，至少要重写其中一个才行。例如我们新建&nbsp;MyTextView：</p>
<div class="cnblogs_code">
<pre><code>   <br /><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> MyTextView <span style="color: #0000ff;">extends</span> View {<br /><span style="color: #008000;">　　/**</span><span style="color: #008000;">
     * 在java代码里new的时候会用到
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> context
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span><span style="color: #000000;"> MyTextView(Context context) {
        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">(context);
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 在xml布局文件中使用时自动调用
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> context
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span><span style="color: #000000;"> MyTextView(Context context, @Nullable AttributeSet attrs) {
        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">(context, attrs);</span><span style="color: #000000;">
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 不会自动调用，如果有默认style时，在第二个构造函数中调用
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> context
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> attrs
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> defStyleAttr
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> MyTextView(Context context, @Nullable AttributeSet attrs, <span style="color: #0000ff;">int</span><span style="color: #000000;"> defStyleAttr) {
        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">(context, attrs, defStyleAttr);
    }


    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 只有在API版本&gt;21时才会用到
     * 不会自动调用，如果有默认style时，在第二个构造函数中调用
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> context
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> attrs
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> defStyleAttr
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> defStyleRes
     </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    @RequiresApi(api </span>=<span style="color: #000000;"> Build.VERSION_CODES.LOLLIPOP)
    </span><span style="color: #0000ff;">public</span> MyTextView(Context context, @Nullable AttributeSet attrs, <span style="color: #0000ff;">int</span> defStyleAttr, <span style="color: #0000ff;">int</span><span style="color: #000000;"> defStyleRes) {
        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">(context, attrs, defStyleAttr, defStyleRes);
    }<br />}</span></pre>
</div>
<p>对于每一种构造函数的作用，都已经再代码里面写出来了。</p>
<h3 style="background-color: #33ffff;">自定义属性</h3>
<p>写过布局的同学都知道，系统控件的属性在 xml 中都是以 android 开头的。对于自定义 View，也可以自定义属性，在 xml 中使用。</p>
<div>
<div>
<p>Android 自定义属性可分为以下几步:</p>
<ol>
<li>
<p>自定义一个 View</p>
</li>
<li>
<p>编写 values/attrs.xml，在其中编写 styleable 和 item 等标签元素</p>
</li>
<li>
<p>在布局文件中 View 使用自定义的属性（注意 namespace）</p>
</li>
<li>
<p>在 View 的构造方法中通过 TypedArray 获取</p>
</li>
</ol></div>
e.g&nbsp; 还是以上面的&nbsp;MyTextView 做演示：<br /><br /></div>
<div>首先我在&nbsp;activity_main.xml 中引入了 MyTextView:</div>
<div>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">&lt;?</span><span style="color: #ff00ff;">xml version="1.0" encoding="utf-8"</span><span style="color: #0000ff;">?&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">android.support.constraint.ConstraintLayout </span><span style="color: #ff0000;">xmlns:android</span><span style="color: #0000ff;">="http://schemas.android.com/apk/res/android"</span><span style="color: #ff0000;">
    xmlns:app</span><span style="color: #0000ff;">="http://schemas.android.com/apk/res-auto"</span><span style="color: #ff0000;">
    xmlns:tools</span><span style="color: #0000ff;">="http://schemas.android.com/tools"</span><span style="color: #ff0000;">
    android:layout_width</span><span style="color: #0000ff;">="match_parent"</span><span style="color: #ff0000;">
    android:layout_height</span><span style="color: #0000ff;">="match_parent"</span><span style="color: #ff0000;">
    tools:context</span><span style="color: #0000ff;">=".MainActivity"</span><span style="color: #0000ff;">&gt;</span>

    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">com.example.myapplication.MyTextView
        </span><span style="color: #ff0000;">android:layout_width</span><span style="color: #0000ff;">="100dp"</span><span style="color: #ff0000;">
        android:layout_height</span><span style="color: #0000ff;">="200dp"</span><span style="color: #ff0000;">
        app:testAttr</span><span style="color: #0000ff;">="520"</span><span style="color: #ff0000;">
        app:text</span><span style="color: #0000ff;">="helloWorld"</span> <span style="color: #0000ff;">/&gt;</span>

<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">android.support.constraint.ConstraintLayout</span><span style="color: #0000ff;">&gt;</span></pre>
</div>
<p>然后我在&nbsp;values/attrs.xml 中添加自定义属性：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">&lt;?</span><span style="color: #ff00ff;">xml version="1.0" encoding="utf-8"</span><span style="color: #0000ff;">?&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">resources</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">declare-styleable </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">="test"</span><span style="color: #0000ff;">&gt;</span>
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">attr </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">="text"</span><span style="color: #ff0000;"> format</span><span style="color: #0000ff;">="string"</span> <span style="color: #0000ff;">/&gt;</span>
        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">attr </span><span style="color: #ff0000;">name</span><span style="color: #0000ff;">="testAttr"</span><span style="color: #ff0000;"> format</span><span style="color: #0000ff;">="integer"</span> <span style="color: #0000ff;">/&gt;</span>
    <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">declare-styleable</span><span style="color: #0000ff;">&gt;</span>
<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">resources</span><span style="color: #0000ff;">&gt;</span></pre>
</div>
<p>记得在构造函数里面说过，xml 布局会调用第二个构造函数，因此在这个构造函数里面获取属性和解析：</p>
</div>
<div class="cnblogs_code">
<pre><code>   <span style="color: #008000;">/**</span><span style="color: #008000;">
     * 在xml布局文件中使用时自动调用
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> context
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span><span style="color: #000000;"> MyTextView(Context context, @Nullable AttributeSet attrs) {
        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">(context, attrs);
        TypedArray ta </span>=<span style="color: #000000;"> context.obtainStyledAttributes(attrs, R.styleable.test);
        </span><span style="color: #0000ff;">int</span> textAttr = ta.getInteger(R.styleable.test_testAttr, -1<span style="color: #000000;">);
        String text </span>=<span style="color: #000000;"> ta.getString(R.styleable.test_text);
        Log.d(TAG, </span>" text = " + text + ", textAttr = " +<span style="color: #000000;"> textAttr);<br /><span style="color: #008000;">　　　　　// toast 显示获取的属性值
</span>        Toast.makeText(context, text </span>+ " " +<span style="color: #000000;"> textAttr, Toast.LENGTH_LONG).show();
        ta.recycle();
    }</span></pre>
</div>
<p>注意当你在引用自定义属性的时候，记得加上 name 前缀，否则会引用不到。</p>
<p>这里本想截图 log 的，奈何就是不显示，就搞成 toast 了。</p>
<p>当然，你还可以自定义很多其他属性，包括 color, string,&nbsp;integer, boolean, flag，甚至是混合等。</p>
<h1 style="background-color: #33cccc;">自定义组合控件</h1>
<p>自定义组合控件就是将多个控件组合成为一个新的控件，主要解决多次重复使用同一类型的布局。如我们顶部的 HeaderView 以及 dailog 等，我们都可以把他们组合成一个新的控件。</p>
<div>
<p>我们通过一个自定义 MyView1 实例来了解自定义组合控件的用法。</p>
<p>xml 布局&nbsp;</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">&lt;?</span><span style="color: #ff00ff;">xml version="1.0" encoding="utf-8"</span><span style="color: #0000ff;">?&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">merge </span><span style="color: #ff0000;">xmlns:android</span><span style="color: #0000ff;">="http://schemas.android.com/apk/res/android"</span><span style="color: #ff0000;">
    android:layout_width</span><span style="color: #0000ff;">="wrap_content"</span><span style="color: #ff0000;">
    android:layout_height</span><span style="color: #0000ff;">="wrap_content"</span><span style="color: #0000ff;">&gt;</span>
    
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">TextView
        </span><span style="color: #ff0000;">android:id</span><span style="color: #0000ff;">="@+id/feed_item_com_cont_title"</span><span style="color: #ff0000;">
        android:layout_width</span><span style="color: #0000ff;">="wrap_content"</span><span style="color: #ff0000;">
        android:layout_height</span><span style="color: #0000ff;">="wrap_content"</span><span style="color: #ff0000;">
        android:ellipsize</span><span style="color: #0000ff;">="end"</span><span style="color: #ff0000;">
        android:includeFontPadding</span><span style="color: #0000ff;">="false"</span><span style="color: #ff0000;">
        android:maxLines</span><span style="color: #0000ff;">="2"</span><span style="color: #ff0000;">
        android:text</span><span style="color: #0000ff;">="title"</span> <span style="color: #0000ff;">/&gt;</span>

    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">TextView
        </span><span style="color: #ff0000;">android:id</span><span style="color: #0000ff;">="@+id/feed_item_com_cont_desc"</span><span style="color: #ff0000;">
        android:layout_width</span><span style="color: #0000ff;">="wrap_content"</span><span style="color: #ff0000;">
        android:layout_height</span><span style="color: #0000ff;">="wrap_content"</span><span style="color: #ff0000;">
        android:layout_below</span><span style="color: #0000ff;">="@id/feed_item_com_cont_title"</span><span style="color: #ff0000;">
        android:ellipsize</span><span style="color: #0000ff;">="end"</span><span style="color: #ff0000;">
        android:includeFontPadding</span><span style="color: #0000ff;">="false"</span><span style="color: #ff0000;">
        android:maxLines</span><span style="color: #0000ff;">="2"</span><span style="color: #ff0000;">
        android:text</span><span style="color: #0000ff;">="desc"</span> <span style="color: #0000ff;">/&gt;</span>

<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">merge</span><span style="color: #0000ff;">&gt;</span></pre>
</div>
<p>&nbsp;自定义 View 代码 ：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.example.myapplication;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> android.content.Context;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> android.util.AttributeSet;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> android.view.LayoutInflater;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> android.view.View;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> android.widget.RelativeLayout;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> android.widget.TextView;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> MyView1 <span style="color: #0000ff;">extends</span><span style="color: #000000;"> RelativeLayout {

    </span><span style="color: #008000;">/**</span><span style="color: #008000;"> 标题 </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span><span style="color: #000000;"> TextView mTitle;
    </span><span style="color: #008000;">/**</span><span style="color: #008000;"> 描述 </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span><span style="color: #000000;"> TextView mDesc;

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> MyView1(Context context) {
        </span><span style="color: #0000ff;">this</span>(context, <span style="color: #0000ff;">null</span><span style="color: #000000;">);
    }

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> MyView1(Context context, AttributeSet attrs) {
        </span><span style="color: #0000ff;">this</span>(context, attrs, 0<span style="color: #000000;">);
    }

    </span><span style="color: #0000ff;">public</span> MyView1(Context context, AttributeSet attrs, <span style="color: #0000ff;">int</span><span style="color: #000000;"> defStyleAttr) {
        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">(context, attrs, defStyleAttr);
        initView(context);
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 初使化界面视图
     *
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> context 上下文环境
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> initView(Context context) {
        View rootView </span>= LayoutInflater.from(getContext()).inflate(R.layout.my_view1, <span style="color: #0000ff;">this</span><span style="color: #000000;">);

        mDesc </span>=<span style="color: #000000;"> rootView.findViewById(R.id.feed_item_com_cont_desc);
        mTitle </span>=<span style="color: #000000;"> rootView.findViewById(R.id.feed_item_com_cont_title);
    }
}</span></pre>
</div>
<p>在布局当中引用该控件&nbsp;</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">&lt;?</span><span style="color: #ff00ff;">xml version="1.0" encoding="utf-8"</span><span style="color: #0000ff;">?&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">LinearLayout </span><span style="color: #ff0000;">xmlns:android</span><span style="color: #0000ff;">="http://schemas.android.com/apk/res/android"</span><span style="color: #ff0000;">
    xmlns:app</span><span style="color: #0000ff;">="http://schemas.android.com/apk/res-auto"</span><span style="color: #ff0000;">
    xmlns:tools</span><span style="color: #0000ff;">="http://schemas.android.com/tools"</span><span style="color: #ff0000;">
    android:layout_width</span><span style="color: #0000ff;">="match_parent"</span><span style="color: #ff0000;">
    android:layout_height</span><span style="color: #0000ff;">="match_parent"</span><span style="color: #ff0000;">
    android:orientation</span><span style="color: #0000ff;">="vertical"</span><span style="color: #ff0000;">
    tools:context</span><span style="color: #0000ff;">=".MainActivity"</span><span style="color: #0000ff;">&gt;</span>

    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">TextView
        </span><span style="color: #ff0000;">android:id</span><span style="color: #0000ff;">="@+id/text"</span><span style="color: #ff0000;">
        android:layout_width</span><span style="color: #0000ff;">="100dp"</span><span style="color: #ff0000;">
        android:layout_height</span><span style="color: #0000ff;">="100dp"</span><span style="color: #ff0000;">
        android:clickable</span><span style="color: #0000ff;">="true"</span><span style="color: #ff0000;">
        android:enabled</span><span style="color: #0000ff;">="false"</span><span style="color: #ff0000;">
        android:focusable</span><span style="color: #0000ff;">="true"</span><span style="color: #ff0000;">
        android:text</span><span style="color: #0000ff;">="trsfnjsfksjfnjsdfjksdhfjksdjkfhdsfsdddddddddddddddddddddddddd"</span> <span style="color: #0000ff;">/&gt;</span>

    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">com.example.myapplication.MyTextView
        </span><span style="color: #ff0000;">android:id</span><span style="color: #0000ff;">="@+id/myview"</span><span style="color: #ff0000;">
        android:layout_width</span><span style="color: #0000ff;">="100dp"</span><span style="color: #ff0000;">
        android:layout_height</span><span style="color: #0000ff;">="200dp"</span><span style="color: #ff0000;">
        android:clickable</span><span style="color: #0000ff;">="true"</span><span style="color: #ff0000;">
        android:enabled</span><span style="color: #0000ff;">="false"</span><span style="color: #ff0000;">
        android:focusable</span><span style="color: #0000ff;">="true"</span><span style="color: #ff0000;">
        app:testAttr</span><span style="color: #0000ff;">="520"</span><span style="color: #ff0000;">
        app:text</span><span style="color: #0000ff;">="helloWorld"</span> <span style="color: #0000ff;">/&gt;</span>

    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">com.example.myapplication.MyView1
        </span><span style="color: #ff0000;">android:layout_width</span><span style="color: #0000ff;">="wrap_content"</span><span style="color: #ff0000;">
        android:layout_height</span><span style="color: #0000ff;">="wrap_content"</span> <span style="color: #0000ff;">/&gt;</span>

<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">LinearLayout</span><span style="color: #0000ff;">&gt;</span></pre>
</div>
<p>最终效果如下图所示 ：</p>
<p><img src="./images/Android 自定义 View 详解0.png" alt="" width="250" height="312" />&nbsp;</p>
<div>
<div>
<h1 style="background-color: #33cccc;">继承系统控件</h1>
<p>继承系统的控件可以分为继承 View子类（如 TextView 等）和继承 ViewGroup 子类(如 LinearLayout 等)，根据业务需求的不同，实现的方式也会有比较大的差异。这里介绍一个比较简单的，继承自View的实现方式。</p>
<p><strong>业务需求：为文字设置背景，并在布局中间添加一条横线。</strong></p>
<p>因为这种实现方式会复用系统的逻辑，大多数情况下我们希望复用系统的&nbsp;<code>onMeaseur&nbsp;</code>和&nbsp;<code>onLayout&nbsp;</code>流程，所以我们只需要重写&nbsp;<code>onDraw&nbsp;</code>方法 。实现非常简单，话不多说，直接上代码。</p>
</div>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">package</span><span style="color: #000000;"> com.example.myapplication;

</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> android.content.Context;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> android.graphics.Canvas;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> android.graphics.LinearGradient;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> android.graphics.Shader;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> android.text.TextPaint;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> android.util.AttributeSet;
</span><span style="color: #0000ff;">import</span><span style="color: #000000;"> android.widget.TextView;


</span><span style="color: #0000ff;">import</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> android.support.v4.content.ContextCompat.getColor;

</span><span style="color: #008000;">/**</span><span style="color: #008000;">
 * 包含分割线的textView
 * 文字左右两边有一条渐变的分割线
 * 样式如下：
 * &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash; 文字 &mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> DividingLineTextView <span style="color: #0000ff;">extends</span><span style="color: #000000;"> TextView {
    </span><span style="color: #008000;">/**</span><span style="color: #008000;"> 线性渐变 </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span><span style="color: #000000;"> LinearGradient mLinearGradient;
    </span><span style="color: #008000;">/**</span><span style="color: #008000;"> textPaint </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span><span style="color: #000000;"> TextPaint mPaint;
    </span><span style="color: #008000;">/**</span><span style="color: #008000;"> 文字 </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> String mText = ""<span style="color: #000000;">;
    </span><span style="color: #008000;">/**</span><span style="color: #008000;"> 屏幕宽度 </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> mScreenWidth;
    </span><span style="color: #008000;">/**</span><span style="color: #008000;"> 开始颜色 </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> mStartColor;
    </span><span style="color: #008000;">/**</span><span style="color: #008000;"> 结束颜色 </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> mEndColor;
    </span><span style="color: #008000;">/**</span><span style="color: #008000;"> 字体大小 </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> mTextSize;


    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 构造函数
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> DividingLineTextView(Context context, AttributeSet attrs, <span style="color: #0000ff;">int</span><span style="color: #000000;"> defStyle) {
        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">(context, attrs, defStyle);
        mTextSize </span>=<span style="color: #000000;"> getResources().getDimensionPixelSize(R.dimen.text_size);
        mScreenWidth </span>=<span style="color: #000000;"> getCalculateWidth(getContext());
        mStartColor </span>=<span style="color: #000000;"> getColor(getContext(), R.color.colorAccent);
        mEndColor </span>=<span style="color: #000000;"> getColor(getContext(), R.color.colorPrimary);
        mLinearGradient </span>= <span style="color: #0000ff;">new</span> LinearGradient(0, 0, mScreenWidth, 0<span style="color: #000000;">,
                </span><span style="color: #0000ff;">new</span> <span style="color: #0000ff;">int</span><span style="color: #000000;">[]{mStartColor, mEndColor, mStartColor},
                </span><span style="color: #0000ff;">new</span> <span style="color: #0000ff;">float</span>[]{0, 0.5f<span style="color: #000000;">, 1f},
                Shader.TileMode.CLAMP);
        mPaint </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> TextPaint();
    }

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> DividingLineTextView(Context context, AttributeSet attrs) {
        </span><span style="color: #0000ff;">this</span>(context, attrs, 0<span style="color: #000000;">);
    }

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> DividingLineTextView(Context context) {
        </span><span style="color: #0000ff;">this</span>(context, <span style="color: #0000ff;">null</span><span style="color: #000000;">);
    }

    @Override
    </span><span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> onDraw(Canvas canvas) {
        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">.onDraw(canvas);
        mPaint.setAntiAlias(</span><span style="color: #0000ff;">true</span><span style="color: #000000;">);
        mPaint.setTextSize(mTextSize);
        </span><span style="color: #0000ff;">int</span> len =<span style="color: #000000;"> getTextLength(mText, mPaint);
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 文字绘制起始坐标</span>
        <span style="color: #0000ff;">int</span> sx = mScreenWidth / 2 - len / 2<span style="color: #000000;">;
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 文字绘制结束坐标</span>
        <span style="color: #0000ff;">int</span> ex = mScreenWidth / 2 + len / 2<span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> height =<span style="color: #000000;"> getMeasuredHeight();
        mPaint.setShader(mLinearGradient);
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 绘制左边分界线，从左边开始：左边距15dp， 右边距距离文字15dp</span>
        canvas.drawLine(mTextSize, height / 2, sx - mTextSize, height / 2<span style="color: #000000;">, mPaint);
        mPaint.setShader(mLinearGradient);
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 绘制右边分界线，从文字右边开始：左边距距离文字15dp，右边距15dp</span>
        canvas.drawLine(ex + mTextSize, height / 2<span style="color: #000000;">,
                mScreenWidth </span>- mTextSize, height / 2<span style="color: #000000;">, mPaint);
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 返回指定文字的宽度，单位px
     *
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> str   要测量的文字
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> paint 绘制此文字的画笔
     * </span><span style="color: #808080;">@return</span><span style="color: #008000;"> 返回文字的宽度，单位px
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> getTextLength(String str, TextPaint paint) {
        </span><span style="color: #0000ff;">return</span> (<span style="color: #0000ff;">int</span><span style="color: #000000;">) paint.measureText(str);
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 更新文字
     *
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> text 文字
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> update(String text) {
        mText </span>=<span style="color: #000000;"> text;
        setText(mText);
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 刷新重绘</span>
<span style="color: #000000;">        requestLayout();
    }


    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 获取需要计算的宽度，取屏幕高宽较小值，
     *
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> context context
     * </span><span style="color: #808080;">@return</span><span style="color: #008000;"> 屏幕宽度值
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> getCalculateWidth(Context context) {
        </span><span style="color: #0000ff;">int</span> height =<span style="color: #000000;"> context.getResources().getDisplayMetrics().heightPixels;
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 动态屏幕宽度，在折叠屏手机上宽度在分屏时会发生变化</span>
        <span style="color: #0000ff;">int</span> Width =<span style="color: #000000;"> context.getResources().getDisplayMetrics().widthPixels;

        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> Math.min(Width, height);
    }
}</span></pre>
</div>
<p>对于 View 的绘制还需要对&nbsp;<code>Paint()</code>、<code>canvas&nbsp;</code>以及&nbsp;<code>Path&nbsp;</code>的使用有所了解，不清楚的可以稍微了解一下。&nbsp;</p>
<p>看下布局里面的引用：</p>
<p>xml 布局&nbsp;</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">&lt;?</span><span style="color: #ff00ff;">xml version="1.0" encoding="utf-8"</span><span style="color: #0000ff;">?&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">LinearLayout </span><span style="color: #ff0000;">xmlns:android</span><span style="color: #0000ff;">="http://schemas.android.com/apk/res/android"</span><span style="color: #ff0000;">
    xmlns:app</span><span style="color: #0000ff;">="http://schemas.android.com/apk/res-auto"</span><span style="color: #ff0000;">
    xmlns:tools</span><span style="color: #0000ff;">="http://schemas.android.com/tools"</span><span style="color: #ff0000;">
    android:layout_width</span><span style="color: #0000ff;">="match_parent"</span><span style="color: #ff0000;">
    android:layout_height</span><span style="color: #0000ff;">="match_parent"</span><span style="color: #ff0000;">
    android:orientation</span><span style="color: #0000ff;">="vertical"</span><span style="color: #ff0000;">
    tools:context</span><span style="color: #0000ff;">=".MainActivity"</span><span style="color: #0000ff;">&gt;</span><span style="color: #008000;">

   // ...... 跟前面一样忽视
    </span><span style="color: #0000ff;">&lt;</span><span style="color: #800000;">com.example.myapplication.DividingLineTextView
        </span><span style="color: #ff0000;">android:id</span><span style="color: #0000ff;">="@+id/divide"</span><span style="color: #ff0000;">
        android:layout_width</span><span style="color: #0000ff;">="match_parent"</span><span style="color: #ff0000;">
        android:layout_height</span><span style="color: #0000ff;">="wrap_content"</span><span style="color: #ff0000;">
        android:gravity</span><span style="color: #0000ff;">="center"</span> <span style="color: #0000ff;">/&gt;</span>

<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">LinearLayout</span><span style="color: #0000ff;">&gt;</span></pre>
</div>
<p>&nbsp;</p>
activty 里面代码如下 ：<br />
<div class="cnblogs_code">
<pre><code>  <span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> onCreate(Bundle savedInstanceState) {
        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        DividingLineTextView te </span>=<span style="color: #000000;"> findViewById(R.id.divide);
        te.update(</span>"DividingLineTextView"<span style="color: #000000;">);
  }</span></pre>
</div>
<p>这里通过 update() 对来重新绘制，确保边线在文字的两边。视觉效果如下：</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/Android 自定义 View 详解1.png" alt="" width="285" height="370" /></p>
<p>&nbsp;</p>
<h1 style="background-color: #33cccc;">直接继承View</h1>
<div>
<div>
<p>直接继承 View 会比上一种实现方复杂一些，这种方法的使用情景下，完全不需要复用系统控件的逻辑，除了要重写&nbsp;<code>onDraw&nbsp;</code>外还需要对&nbsp;<code>onMeasure&nbsp;</code>方法进行重写。</p>
<p><strong>我们用自定义 View 来绘制一个正方形。</strong></p>
<p>首先定义构造方法，以及做一些初始化操作</p>
</div>
<div class="cnblogs_code">
<pre><code>ublic <span style="color: #0000ff;">class</span> RectView <span style="color: #0000ff;">extends</span><span style="color: #000000;"> View{
    </span><span style="color: #008000;">//</span><span style="color: #008000;">定义画笔</span>
    <span style="color: #0000ff;">private</span> Paint mPaint = <span style="color: #0000ff;">new</span><span style="color: #000000;"> Paint();

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 实现构造方法
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> context
     </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">public</span><span style="color: #000000;"> RectView(Context context) {
        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">(context);
        init();
    }

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> RectView(Context context, @Nullable AttributeSet attrs) {
        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">(context, attrs);
        init();
    }

    </span><span style="color: #0000ff;">public</span> RectView(Context context, @Nullable AttributeSet attrs, <span style="color: #0000ff;">int</span><span style="color: #000000;"> defStyleAttr) {
        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">(context, attrs, defStyleAttr);
        init();
    }

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> init() {
        mPaint.setColor(Color.BLUE);

    }

}</span></pre>
</div>
<p>&nbsp;重写 draw 方法，绘制正方形，注意对 padding 属性进行设置：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 重写draw方法
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> canvas
     </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    @Override
    </span><span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> onDraw(Canvas canvas) {
        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">.onDraw(canvas);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">获取各个编剧的padding值</span>
        <span style="color: #0000ff;">int</span> paddingLeft =<span style="color: #000000;"> getPaddingLeft();
        </span><span style="color: #0000ff;">int</span> paddingRight =<span style="color: #000000;"> getPaddingRight();
        </span><span style="color: #0000ff;">int</span> paddingTop =<span style="color: #000000;"> getPaddingTop();
        </span><span style="color: #0000ff;">int</span> paddingBottom =<span style="color: #000000;"> getPaddingBottom();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">获取绘制的View的宽度</span>
        <span style="color: #0000ff;">int</span> width = getWidth()-paddingLeft-<span style="color: #000000;">paddingRight;
        </span><span style="color: #008000;">//</span><span style="color: #008000;">获取绘制的View的高度</span>
        <span style="color: #0000ff;">int</span> height = getHeight()-paddingTop-<span style="color: #000000;">paddingBottom;
        </span><span style="color: #008000;">//</span><span style="color: #008000;">绘制View，左上角坐标（0+paddingLeft,0+paddingTop），右下角坐标（width+paddingLeft,height+paddingTop）</span>
        canvas.drawRect(0+paddingLeft,0+paddingTop,width+paddingLeft,height+<span style="color: #000000;">paddingTop,mPaint);
    }</span></pre>
</div>
<p>在 View 的源码当中并没有对&nbsp;<code>AT_MOST&nbsp;</code>和&nbsp;<code>EXACTLY&nbsp;</code>两个模式做出区分，也就是说 View 在&nbsp;<code>wrap_content&nbsp;</code>和&nbsp;<code>match_parent&nbsp;</code>两个模式下是完全相同的，都会是&nbsp;<code>match_parent</code>，显然这与我们平时用的 View 不同，所以我们要重写&nbsp;<code>onMeasure&nbsp;</code>方法。</p>
<div>
<div class="cnblogs_code">
<pre><code>    <span style="color: #008000;">/**</span><span style="color: #008000;">
     * 重写onMeasure方法
     *
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> widthMeasureSpec
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> heightMeasureSpec
     </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    @Override
    </span><span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">void</span> onMeasure(<span style="color: #0000ff;">int</span> widthMeasureSpec, <span style="color: #0000ff;">int</span><span style="color: #000000;"> heightMeasureSpec) {
        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">.onMeasure(widthMeasureSpec, heightMeasureSpec);
        </span><span style="color: #0000ff;">int</span> widthSize =<span style="color: #000000;"> MeasureSpec.getSize(widthMeasureSpec);
        </span><span style="color: #0000ff;">int</span> widthMode =<span style="color: #000000;"> MeasureSpec.getMode(widthMeasureSpec);
        </span><span style="color: #0000ff;">int</span> heightSize =<span style="color: #000000;"> MeasureSpec.getSize(heightMeasureSpec);
        </span><span style="color: #0000ff;">int</span> heightMode =<span style="color: #000000;"> MeasureSpec.getMode(heightMeasureSpec);

        </span><span style="color: #008000;">//</span><span style="color: #008000;">处理wrap_contentde情况</span>
        <span style="color: #0000ff;">if</span> (widthMode == MeasureSpec.AT_MOST &amp;&amp; heightMode ==<span style="color: #000000;"> MeasureSpec.AT_MOST) {
            setMeasuredDimension(</span>300, 300<span style="color: #000000;">);
        } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (widthMode ==<span style="color: #000000;"> MeasureSpec.AT_MOST) {
            setMeasuredDimension(</span>300<span style="color: #000000;">, heightSize);
        } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (heightMode ==<span style="color: #000000;"> MeasureSpec.AT_MOST) {
            setMeasuredDimension(widthSize, </span>300<span style="color: #000000;">);
        }
    }</span></pre>
</div>
<p>&nbsp;最终效果如图所示：</p>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/Android 自定义 View 详解2.png" alt="" width="357" height="400" /></p>
<p>可以发现，我们设置的是 wrap_content，但是最后还是有尺寸的。</p>
<p>整个过程大致如下，直接继承 View 时需要有几点注意：</p>
<div>
<div><ol>
<li>
<p>在 onDraw 当中对 padding 属性进行处理。</p>
</li>
<li>
<p>在 onMeasure 过程中对 wrap_content 属性进行处理。</p>
</li>
<li>
<p>至少要有一个构造方法。</p>
</li>
</ol></div>
</div>
</div>
<div>
<div>
<h1 style="background-color: #33cccc;">继承ViewGroup</h1>
<p>自定义 ViewGroup 的过程相对复杂一些，因为除了要对自身的大小和位置进行测量之外，还需要对子 View 的测量参数负责。</p>
<h2 style="background-color: #33ccff;">需求实例</h2>
<p><strong>实现一个类似于 Viewpager 的可左右滑动的布局。</strong></p>
<p>布局文件：</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">&lt;?</span><span style="color: #ff00ff;">xml version="1.0" encoding="utf-8"</span><span style="color: #0000ff;">?&gt;</span>
<span style="color: #0000ff;">&lt;</span><span style="color: #800000;">LinearLayout </span><span style="color: #ff0000;">xmlns:android</span><span style="color: #0000ff;">="http://schemas.android.com/apk/res/android"</span><span style="color: #ff0000;">
    xmlns:app</span><span style="color: #0000ff;">="http://schemas.android.com/apk/res-auto"</span><span style="color: #ff0000;">
    xmlns:tools</span><span style="color: #0000ff;">="http://schemas.android.com/tools"</span><span style="color: #ff0000;">
    android:layout_width</span><span style="color: #0000ff;">="match_parent"</span><span style="color: #ff0000;">
    android:layout_height</span><span style="color: #0000ff;">="match_parent"</span><span style="color: #ff0000;">
    android:orientation</span><span style="color: #0000ff;">="vertical"</span><span style="color: #ff0000;">
    tools:context</span><span style="color: #0000ff;">=".MainActivity"</span><span style="color: #0000ff;">&gt;</span>
    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">com.example.myapplication.MyHorizonView
        </span><span style="color: #ff0000;">android:layout_width</span><span style="color: #0000ff;">="wrap_content"</span><span style="color: #ff0000;">
        android:background</span><span style="color: #0000ff;">="@color/colorAccent"</span><span style="color: #ff0000;">
        android:layout_height</span><span style="color: #0000ff;">="400dp"</span><span style="color: #0000ff;">&gt;</span>

        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">ListView
            </span><span style="color: #ff0000;">android:id</span><span style="color: #0000ff;">="@+id/list1"</span><span style="color: #ff0000;">
            android:layout_width</span><span style="color: #0000ff;">="match_parent"</span><span style="color: #ff0000;">
            android:layout_height</span><span style="color: #0000ff;">="match_parent"</span><span style="color: #ff0000;">
            android:background</span><span style="color: #0000ff;">="@color/colorAccent"</span> <span style="color: #0000ff;">/&gt;</span>

        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">ListView
            </span><span style="color: #ff0000;">android:id</span><span style="color: #0000ff;">="@+id/list2"</span><span style="color: #ff0000;">
            android:layout_width</span><span style="color: #0000ff;">="match_parent"</span><span style="color: #ff0000;">
            android:layout_height</span><span style="color: #0000ff;">="match_parent"</span><span style="color: #ff0000;">
            android:background</span><span style="color: #0000ff;">="@color/colorPrimary"</span> <span style="color: #0000ff;">/&gt;</span>

        <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">ListView
            </span><span style="color: #ff0000;">android:id</span><span style="color: #0000ff;">="@+id/list3"</span><span style="color: #ff0000;">
            android:layout_width</span><span style="color: #0000ff;">="match_parent"</span><span style="color: #ff0000;">
            android:layout_height</span><span style="color: #0000ff;">="match_parent"</span><span style="color: #ff0000;">
            android:background</span><span style="color: #0000ff;">="@color/colorPrimaryDark"</span> <span style="color: #0000ff;">/&gt;</span>

    <span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">com.example.myapplication.MyHorizonView</span><span style="color: #0000ff;">&gt;</span>

    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">TextView
        </span><span style="color: #ff0000;">android:id</span><span style="color: #0000ff;">="@+id/text"</span><span style="color: #ff0000;">
        android:layout_width</span><span style="color: #0000ff;">="100dp"</span><span style="color: #ff0000;">
        android:layout_height</span><span style="color: #0000ff;">="100dp"</span><span style="color: #ff0000;">
        android:clickable</span><span style="color: #0000ff;">="true"</span><span style="color: #ff0000;">
        android:focusable</span><span style="color: #0000ff;">="true"</span><span style="color: #ff0000;">
        android:text</span><span style="color: #0000ff;">="trsfnjsfksjfnjsdfjksdhfjksdjkfhdsfsdddddddddddddddddddddddddd"</span> <span style="color: #0000ff;">/&gt;</span>

    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">com.example.myapplication.MyTextView
        </span><span style="color: #ff0000;">android:id</span><span style="color: #0000ff;">="@+id/myview"</span><span style="color: #ff0000;">
        android:layout_width</span><span style="color: #0000ff;">="1dp"</span><span style="color: #ff0000;">
        android:layout_height</span><span style="color: #0000ff;">="2dp"</span><span style="color: #ff0000;">
        android:clickable</span><span style="color: #0000ff;">="true"</span><span style="color: #ff0000;">
        android:enabled</span><span style="color: #0000ff;">="false"</span><span style="color: #ff0000;">
        android:focusable</span><span style="color: #0000ff;">="true"</span><span style="color: #ff0000;">
        app:testAttr</span><span style="color: #0000ff;">="520"</span><span style="color: #ff0000;">
        app:text</span><span style="color: #0000ff;">="helloWorld"</span> <span style="color: #0000ff;">/&gt;</span>

    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">com.example.myapplication.RectView
        </span><span style="color: #ff0000;">android:layout_width</span><span style="color: #0000ff;">="wrap_content"</span><span style="color: #ff0000;">
        android:layout_height</span><span style="color: #0000ff;">="wrap_content"</span> <span style="color: #0000ff;">/&gt;</span>

    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">com.example.myapplication.MyView1
        </span><span style="color: #ff0000;">android:layout_width</span><span style="color: #0000ff;">="wrap_content"</span><span style="color: #ff0000;">
        android:layout_height</span><span style="color: #0000ff;">="wrap_content"</span> <span style="color: #0000ff;">/&gt;</span>

    <span style="color: #0000ff;">&lt;</span><span style="color: #800000;">com.example.myapplication.DividingLineTextView
        </span><span style="color: #ff0000;">android:id</span><span style="color: #0000ff;">="@+id/divide"</span><span style="color: #ff0000;">
        android:layout_width</span><span style="color: #0000ff;">="match_parent"</span><span style="color: #ff0000;">
        android:layout_height</span><span style="color: #0000ff;">="wrap_content"</span><span style="color: #ff0000;">
        android:gravity</span><span style="color: #0000ff;">="center"</span> <span style="color: #0000ff;">/&gt;</span>


<span style="color: #0000ff;">&lt;/</span><span style="color: #800000;">LinearLayout</span><span style="color: #0000ff;">&gt;</span></pre>
</div>
<p>一个 ViewGroup 里面放入 3 个 ListView，注意 ViewGroup 设置的宽是 wrap_conten，在测量的时候，会对 wrap_content 设置成与父 View 的大小一致，具体实现逻辑可看后面的代码。</p>
<p>代码比较多，我们结合注释分析。</p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> MyHorizonView <span style="color: #0000ff;">extends</span><span style="color: #000000;"> ViewGroup {

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> String TAG = "HorizontaiView"<span style="color: #000000;">;
    </span><span style="color: #0000ff;">private</span> List&lt;View&gt; mMatchedChildrenList = <span style="color: #0000ff;">new</span> ArrayList&lt;&gt;<span style="color: #000000;">();


    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> MyHorizonView(Context context) {
        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">(context);
    }

    </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> MyHorizonView(Context context, AttributeSet attributes) {
        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">(context, attributes);
    }

    </span><span style="color: #0000ff;">public</span> MyHorizonView(Context context, AttributeSet attributes, <span style="color: #0000ff;">int</span><span style="color: #000000;"> defStyleAttr) {
        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">(context, attributes, defStyleAttr);
    }

    @Override
    </span><span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">void</span> onLayout(<span style="color: #0000ff;">boolean</span> changed, <span style="color: #0000ff;">int</span> l, <span style="color: #0000ff;">int</span> t, <span style="color: #0000ff;">int</span> r, <span style="color: #0000ff;">int</span><span style="color: #000000;"> b) {
        </span><span style="color: #0000ff;">int</span> childCount =<span style="color: #000000;"> getChildCount();
        </span><span style="color: #0000ff;">int</span> left = 0<span style="color: #000000;">;
        View child;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; childCount; i++<span style="color: #000000;">) {
            child </span>=<span style="color: #000000;"> getChildAt(i);
            </span><span style="color: #0000ff;">if</span> (child.getVisibility() !=<span style="color: #000000;"> View.GONE) {
                </span><span style="color: #0000ff;">int</span> childWidth =<span style="color: #000000;"> child.getMeasuredWidth();
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> 因为是水平滑动的，所以以宽度来适配</span>
                child.layout(left, 0, left +<span style="color: #000000;"> childWidth, child.getMeasuredHeight());
                left </span>+=<span style="color: #000000;"> childWidth;
            }
        }
    }

    @Override
    </span><span style="color: #0000ff;">protected</span> <span style="color: #0000ff;">void</span> onMeasure(<span style="color: #0000ff;">int</span> widthMeasureSpec, <span style="color: #0000ff;">int</span><span style="color: #000000;"> heightMeasureSpec) {
        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">.onMeasure(widthMeasureSpec, heightMeasureSpec);
        mMatchedChildrenList.clear();
        </span><span style="color: #0000ff;">int</span> widthSpecMode =<span style="color: #000000;"> MeasureSpec.getMode(widthMeasureSpec);
        </span><span style="color: #0000ff;">int</span> widthSpecSize =<span style="color: #000000;"> MeasureSpec.getSize(widthMeasureSpec);
        </span><span style="color: #0000ff;">int</span> heightSpecMode =<span style="color: #000000;"> MeasureSpec.getMode(heightMeasureSpec);
        </span><span style="color: #0000ff;">int</span> heightSpecSize =<span style="color: #000000;"> MeasureSpec.getSize(heightMeasureSpec);
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果不是确定的的值，说明是 AT_MOST,与父 View 同宽高</span>
        <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">boolean</span> measureMatchParentChildren = heightSpecMode != MeasureSpec.EXACTLY ||<span style="color: #000000;">
                widthSpecMode </span>!=<span style="color: #000000;"> MeasureSpec.EXACTLY;
        </span><span style="color: #0000ff;">int</span> childCount =<span style="color: #000000;"> getChildCount();
        View child;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; childCount; i++<span style="color: #000000;">) {
            child </span>=<span style="color: #000000;"> getChildAt(i);
            </span><span style="color: #0000ff;">if</span> (child.getVisibility() !=<span style="color: #000000;"> View.GONE) {
                </span><span style="color: #0000ff;">final</span> LayoutParams layoutParams =<span style="color: #000000;"> child.getLayoutParams();
                measureChild(child, widthMeasureSpec, heightMeasureSpec);
                </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (measureMatchParentChildren) {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 需要先计算出父 View 的高度来再来测量子 view</span>
                    <span style="color: #0000ff;">if</span> (layoutParams.width ==<span style="color: #000000;"> LayoutParams.MATCH_PARENT
                            </span>|| layoutParams.height ==<span style="color: #000000;"> LayoutParams.MATCH_PARENT) {
                        mMatchedChildrenList.add(child);
                    }
                }
            }
        }

        </span><span style="color: #0000ff;">if</span> (widthSpecMode == MeasureSpec.AT_MOST &amp;&amp; heightSpecMode ==<span style="color: #000000;"> MeasureSpec.AT_MOST) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果宽高都是AT_MOST的话，即都是wrap_content布局模式，就用View自己想要的宽高值</span>
<span style="color: #000000;">            setMeasuredDimension(getMeasuredWidth(), getMeasuredHeight());
        } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (widthSpecMode ==<span style="color: #000000;"> MeasureSpec.AT_MOST) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果只有宽度都是AT_MOST的话，即只有宽度是wrap_content布局模式，宽度就用View自己想要的宽度值，高度就用父ViewGroup指定的高度值</span>
<span style="color: #000000;">            setMeasuredDimension(getMeasuredWidth(), heightSpecSize);
        } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (heightSpecMode ==<span style="color: #000000;"> MeasureSpec.AT_MOST) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果只有高度都是AT_MOST的话，即只有高度是wrap_content布局模式，高度就用View自己想要的宽度值，宽度就用父ViewGroup指定的高度值</span>
<span style="color: #000000;">            setMeasuredDimension(widthSpecSize, getMeasuredHeight());
        }

        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = 0; i &lt; mMatchedChildrenList.size(); i++<span style="color: #000000;">) {
            View matchChild </span>=<span style="color: #000000;"> getChildAt(i);
            </span><span style="color: #0000ff;">if</span> (matchChild.getVisibility() !=<span style="color: #000000;"> View.GONE) {
                </span><span style="color: #0000ff;">final</span> LayoutParams layoutParams =<span style="color: #000000;"> matchChild.getLayoutParams();
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> 计算子 View 宽的 MeasureSpec</span>
                <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> childWidthMeasureSpec;
                </span><span style="color: #0000ff;">if</span> (layoutParams.width ==<span style="color: #000000;"> LayoutParams.MATCH_PARENT) {
                    childWidthMeasureSpec </span>=<span style="color: #000000;"> MeasureSpec.makeMeasureSpec(getMeasuredWidth(), MeasureSpec.EXACTLY);
                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    childWidthMeasureSpec </span>= getChildMeasureSpec(widthMeasureSpec, 0<span style="color: #000000;">, layoutParams.width);
                }
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> 计算子 View 高的 MeasureSpec</span>
                <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> childHeightMeasureSpec;
                </span><span style="color: #0000ff;">if</span> (layoutParams.height ==<span style="color: #000000;"> LayoutParams.MATCH_PARENT) {
                    childHeightMeasureSpec </span>=<span style="color: #000000;"> MeasureSpec.makeMeasureSpec(getMeasuredHeight(), MeasureSpec.EXACTLY);
                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    childHeightMeasureSpec </span>= getChildMeasureSpec(widthMeasureSpec, 0<span style="color: #000000;">, layoutParams.height);
                }
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> 根据 MeasureSpec 计算自己的宽高</span>
<span style="color: #000000;">                matchChild.measure(childWidthMeasureSpec, childHeightMeasureSpec);
            }
        }
    }
}</span></pre>
</div>
<p>这里我们只是重写了两个绘制过程中的重要的方法：onMeasure 和 onLayout 方法。</p>
<p>对于 onMeasure 方法具体逻辑如下：</p>
<ol>
<li>
<p><span style="color: #000080;">super.onMeasure 会先计算自定义 view 的大小；</span></p>
</li>
<li><span style="color: #000080;">调用&nbsp;measureChild 对 子 View 进行测量；</span></li>
<li>
<p><span style="color: #000080;">自定义 view 设置的宽高参数不是&nbsp;MeasureSpec.EXACTLY&nbsp;的话，对于子 View 是 match_parent 需要额外处理，同时也需要对&nbsp;MeasureSpec.AT_MOST 情况进行额外处理。</span></p>
</li>
<li>
<p><span style="color: #000080;">&nbsp;当自定义View 的大小确定后，在对子 View 是 match_parent 重新测量；</span></p>
</li>
</ol>
<p>上述的测量过程的代码也是参考 FrameLayout 源码的，具体可以参看文章：</p>
<p>对于&nbsp;onLayout 方法，因为是水平滑动的，所以要根据宽度来进行layout。</p>
<p>到这里我们的 View 布局就已经基本结束了。但是要实现&nbsp;<code>Viewpager&nbsp;</code>的效果，还需要添加对事件的处理。事件的处理流程之前我们有分析过，在制作自定义 View 的时候也是会经常用到的，不了解的可以参考文章&nbsp;<a href="https://www.jianshu.com/p/bc4c9e5f4b1c" target="_blank">Android Touch事件分发超详细解析</a>。</p>
<div class="cnblogs_code">
<pre><code> <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> init(Context context) {
        mScroller </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Scroller(context);
        mTracker </span>=<span style="color: #000000;"> VelocityTracker.obtain();
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 因为我们定义的是ViewGroup，从onInterceptTouchEvent开始。
     * 重写onInterceptTouchEvent,对横向滑动事件进行拦截
     *
     * </span><span style="color: #808080;">@param</span><span style="color: #008000;"> event
     * </span><span style="color: #808080;">@return</span>
     <span style="color: #008000;">*/</span><span style="color: #000000;">
    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> onInterceptTouchEvent(MotionEvent event) {
        </span><span style="color: #0000ff;">boolean</span> intercepted = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> x = (<span style="color: #0000ff;">int</span><span style="color: #000000;">) event.getX();
        </span><span style="color: #0000ff;">int</span> y = (<span style="color: #0000ff;">int</span><span style="color: #000000;">) event.getY();
        </span><span style="color: #0000ff;">switch</span><span style="color: #000000;"> (event.getAction()) {
            </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> MotionEvent.ACTION_DOWN:
                intercepted </span>= <span style="color: #0000ff;">false</span>;<span style="color: #008000;">//</span><span style="color: #008000;">必须不能拦截，否则后续的ACTION_MOME和ACTION_UP事件都会拦截。</span>
                <span style="color: #0000ff;">break</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> MotionEvent.ACTION_MOVE:
                intercepted </span>= Math.abs(x - mLastX) &gt; Math.abs(y -<span style="color: #000000;"> mLastY);
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
        }
        Log.d(TAG, </span>"onInterceptTouchEvent: intercepted " +<span style="color: #000000;"> intercepted);
        mLastX </span>=<span style="color: #000000;"> x;
        mLastY </span>=<span style="color: #000000;"> y;
        </span><span style="color: #0000ff;">return</span> intercepted ? intercepted : <span style="color: #0000ff;">super</span><span style="color: #000000;">.onInterceptHoverEvent(event);
    }

    </span><span style="color: #008000;">/**</span><span style="color: #008000;">
     * 当ViewGroup拦截下用户的横向滑动事件以后，后续的Touch事件将交付给`onTouchEvent`进行处理。
     * 重写onTouchEvent方法
     </span><span style="color: #008000;">*/</span><span style="color: #000000;">
    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> onTouchEvent(MotionEvent event) {
        mTracker.addMovement(event);
        </span><span style="color: #0000ff;">int</span> x = (<span style="color: #0000ff;">int</span><span style="color: #000000;">) event.getX();
        </span><span style="color: #0000ff;">int</span> y = (<span style="color: #0000ff;">int</span><span style="color: #000000;">) event.getY();
        </span><span style="color: #0000ff;">switch</span><span style="color: #000000;"> (event.getAction()) {
            </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> MotionEvent.ACTION_DOWN:
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> MotionEvent.ACTION_MOVE:
                </span><span style="color: #0000ff;">int</span> deltaX = x -<span style="color: #000000;"> mLastX;
                Log.d(TAG, </span>"onTouchEvent: deltaX " +<span style="color: #000000;"> deltaX);

                </span><span style="color: #008000;">//</span><span style="color: #008000;"> scrollBy 方法将对我们当前 View 的位置进行偏移</span>
                scrollBy(-deltaX, 0<span style="color: #000000;">);
                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
            </span><span style="color: #0000ff;">case</span><span style="color: #000000;"> MotionEvent.ACTION_UP:
                Log.d(TAG, </span>"onTouchEvent: " +<span style="color: #000000;"> getScrollX());
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> getScrollX()为在X轴方向发生的便宜，mChildWidth * currentIndex表示当前View在滑动开始之前的X坐标
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> distance存储的就是此次滑动的距离</span>
                <span style="color: #0000ff;">int</span> distance = getScrollX() - mChildWidth *<span style="color: #000000;"> mCurrentIndex;
                </span><span style="color: #008000;">//</span><span style="color: #008000;">当本次滑动距离&gt;View宽度的1/2时，切换View</span>
                <span style="color: #0000ff;">if</span> (Math.abs(distance) &gt; mChildWidth / 2<span style="color: #000000;">) {
                    </span><span style="color: #0000ff;">if</span> (distance &gt; 0<span style="color: #000000;">) {
                        mCurrentIndex</span>++<span style="color: #000000;">;
                    } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                        mCurrentIndex</span>--<span style="color: #000000;">;
                    }
                } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">获取X轴加速度，units为单位，默认为像素，这里为每秒1000个像素点</span>
                    mTracker.computeCurrentVelocity(1000<span style="color: #000000;">);
                    </span><span style="color: #0000ff;">float</span> xV =<span style="color: #000000;"> mTracker.getXVelocity();
                    </span><span style="color: #008000;">//</span><span style="color: #008000;">当X轴加速度&gt;50时，也就是产生了快速滑动，也会切换View</span>
                    <span style="color: #0000ff;">if</span> (Math.abs(xV) &gt; 50<span style="color: #000000;">) {
                        </span><span style="color: #0000ff;">if</span> (xV &lt; 0<span style="color: #000000;">) {
                            mCurrentIndex</span>++<span style="color: #000000;">;
                        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                            mCurrentIndex</span>--<span style="color: #000000;">;
                        }
                    }
                }

                </span><span style="color: #008000;">//</span><span style="color: #008000;">对currentIndex做出限制其范围为【0，getChildCount() - 1】</span>
                mCurrentIndex = mCurrentIndex &lt; 0 ? 0 : mCurrentIndex &gt; getChildCount() - 1 ? getChildCount() - 1<span style="color: #000000;"> : mCurrentIndex;
                </span><span style="color: #008000;">//</span><span style="color: #008000;">滑动到下一个View</span>
                smoothScrollTo(mCurrentIndex * mChildWidth, 0<span style="color: #000000;">);
                mTracker.clear();

                </span><span style="color: #0000ff;">break</span><span style="color: #000000;">;
        }

        Log.d(TAG, </span>"onTouchEvent: "<span style="color: #000000;">);
        mLastX </span>=<span style="color: #000000;"> x;
        mLastY </span>=<span style="color: #000000;"> y;
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">super</span><span style="color: #000000;">.onTouchEvent(event);
    }

    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> dispatchTouchEvent(MotionEvent ev) {
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">super</span><span style="color: #000000;">.dispatchTouchEvent(ev);
    }

    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> smoothScrollTo(<span style="color: #0000ff;">int</span> destX, <span style="color: #0000ff;">int</span><span style="color: #000000;"> destY) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> startScroll方法将产生一系列偏移量，从（getScrollX(), getScrollY()），destX - getScrollX()和destY - getScrollY()为移动的距离</span>
        mScroller.startScroll(getScrollX(), getScrollY(), destX - getScrollX(), destY - getScrollY(), 1000<span style="color: #000000;">);
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> invalidate方法会重绘View，也就是调用View的onDraw方法，而onDraw又会调用computeScroll()方法</span>
<span style="color: #000000;">        invalidate();
    }

    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 重写computeScroll方法</span>
<span style="color: #000000;">    @Override
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> computeScroll() {
        </span><span style="color: #0000ff;">super</span><span style="color: #000000;">.computeScroll();
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 当scroller.computeScrollOffset()=true时表示滑动没有结束</span>
        <span style="color: #0000ff;">if</span><span style="color: #000000;"> (mScroller.computeScrollOffset()) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 调用scrollTo方法进行滑动，滑动到scroller当中计算到的滑动位置</span>
<span style="color: #000000;">            scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 没有滑动结束，继续刷新View</span>
<span style="color: #000000;">            postInvalidate();
        }
    }</span></pre>
</div>
<p>具体效果如下图所示：</p>
</div>
<div><img src="./images/Android 自定义 View 详解3.png" alt="" /><br />
<p><strong>对于 Scroller 的用法总结如下：</strong></p>
<div><ol>
<li>
<p><span style="color: #000080;">调用 Scroller 的 startScroll() 方法来进行一些滚动的初始化设置，然后迫使 View 进行绘制 (调用 View 的 invalidate() 或 postInvalidate() 就可以重新绘制 View)；</span></p>















</li>
<li>
<p><span style="color: #000080;">绘制 View 的时候 drawchild 方法会调用 computeScroll() 方法，重写 computeScroll()，通过 Scroller 的 computeScrollOffset() 方法来判断滚动有没有结束；</span></p>















</li>
<li>
<p><span style="color: #000080;">scrollTo() 方法虽然会重新绘制 View，但还是要调用下 invalidate() 或者 postInvalidate() 来触发界面重绘，重新绘制 View 又触发 computeScroll()；</span></p>















</li>
<li>
<p><span style="color: #000080;">如此往复进入一个循环阶段，即可达到平滑滚动的效果；</span></p>















</li>















</ol>
<p>也许有人会问，干嘛还要调用来调用去最后在调用 scrollTo() 方法，还不如直接调用 scrollTo() 方法来实现滚动，其实直接调用是可以，只不过 scrollTo() 是瞬间滚动的，给人的用户体验不太好，所以 Android 提供了 Scroller 类实现平滑滚动的效果。</p>
<p>为了方面大家理解，我画了一个简单的调用示意图：</p>



























</div>
<p>&nbsp;</p>
<p><img src="./images/Android 自定义 View 详解4.png" alt="" /></p>
<p>&nbsp;</p>
<p>到此，自定义 view 的方法就讲完了。希望对大家有用。</p>

































</div>

































</div>

































</div>

































</div>

































</div>

































</div>
<p>参考文献：</p>
<p>1、<a href="https://www.jianshu.com/p/705a6cb6bfee" target="_blank">Android自定义View全解</a></p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>