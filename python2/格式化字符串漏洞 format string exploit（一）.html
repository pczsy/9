<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修格式化字符串漏洞 format string exploit（一）' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>格式化字符串漏洞 format string exploit（一）</center></div><div class='banquan'>原文出处:本文由博客园博主pwn2web提供。<br/>
原文连接:https://www.cnblogs.com/pwn2web/p/12077965.html</div><br>
    <p><span style="font-family: 'Microsoft YaHei';">&nbsp;</span></p>
<p><span style="font-family: 'Microsoft YaHei';">&nbsp;</span></p>
<p><span style="font-family: 'Microsoft YaHei';">本文系原创，转载请说明出处</span></p>
<p><span style="font-family: 'Microsoft YaHei';">本文为基于CTF WIKI的PWN学习</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 14pt;"><strong>0x00 格式化字符串原理</strong></span></p>
<p><span style="font-family: 'Microsoft YaHei';">&nbsp; &nbsp;先附一张经典的图，如下</span></p>
<p><span style="font-family: 'Microsoft YaHei';"><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/格式化字符串漏洞 format string exploit（一）0.png" alt="" /></span></p>
<p><span style="font-family: 'Microsoft YaHei';">&nbsp;</span></p>
<p><span style="font-family: 'Microsoft YaHei';">&nbsp; 其栈上布局如下：</span></p>
<table style="margin-left: auto; margin-right: auto;" border="0">
<tbody>
<tr>
<td><span style="font-family: 'Microsoft YaHei';">some value　</span></td>
</tr>
<tr>
<td><span style="font-family: 'Microsoft YaHei';">3.14</span></td>
</tr>
<tr>
<td><span style="font-family: 'Microsoft YaHei';">123456</span></td>
</tr>
<tr>
<td><span style="font-family: 'Microsoft YaHei';">addr of "red"</span></td>
</tr>
<tr>
<td><span style="font-family: 'Microsoft YaHei';">addr of format string : " Color %s, Number %d, Float %4.2f"</span></td>
</tr>
</tbody>
</table>
<p><span style="font-family: 'Microsoft YaHei';">&nbsp; &nbsp;如果程序写成了：</span></p>
<p><span style="font-family: 'Microsoft YaHei';">&nbsp;</span></p>
<div class="cnblogs_code">
<pre><code><span style="font-family: 'Microsoft YaHei';">printf("Color %s, Number %d, Float %4.2f");</span></pre>
</div>
<p><span style="font-family: 'Microsoft YaHei';">&nbsp;</span></p>
<p><span style="font-family: 'Microsoft YaHei';">&nbsp; &nbsp;分别将栈上的三个变量分别解析为：</span></p>
<ol>
<li><span style="font-family: 'Microsoft YaHei';">解析其地址对应的字符串</span></li>
<li><span style="font-family: 'Microsoft YaHei';">解析其内容对应的整形值</span></li>
<li><span style="font-family: 'Microsoft YaHei';">解析其内容对应的浮点值</span></li>
</ol>
<p><span style="font-family: 'Microsoft YaHei';">&nbsp; &nbsp; 我们编写程序验证以下：</span></p>
<div class="cnblogs_code">
<pre><code>#include &lt;stdio.h&gt;
<span style="color: #0000ff;">int</span><span style="color: #000000;"> main() {

  printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">Color %s, Number %d, Float %4.2f</span><span style="color: #800000;">"</span>, &ldquo;red&rdquo;, <span style="color: #800080;">123456</span>, <span style="color: #800080;">3.14</span><span style="color: #000000;">);
  printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">Color %s, Number %d, Float %4.2f</span><span style="color: #800000;">"</span><span style="color: #000000;">);
  </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<p>&nbsp;</p>
<p><span style="font-family: 'Microsoft YaHei';">&nbsp; &nbsp;输入以下命令编译（记得安装libc6-dev-i386库）：</span></p>
<div class="cnblogs_code">
<pre><code><span style="font-family: 'Microsoft YaHei';"> gcc -m32 -fno-stack-protector -no-pie -o leakmemory 1.c </span></pre>
</div>
<p><span style="font-family: 'Microsoft YaHei';">&nbsp; &nbsp;运行结果</span></p>
<p><span style="font-family: 'Microsoft YaHei';"><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/格式化字符串漏洞 format string exploit（一）1.png" alt="" /></span></p>
<p><span style="font-family: 'Microsoft YaHei';">gdb调试一下：</span></p>
<p><span style="font-family: 'Microsoft YaHei';">b printf后输入r运行</span></p>
<p><span style="font-family: 'Microsoft YaHei';"><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/格式化字符串漏洞 format string exploit（一）2.png" alt="" width="660" height="383" /></span></p>
<p><span style="font-family: 'Microsoft YaHei';">可以看到在第一个printf的运行中，stack的参数正如上文所说，先是格式化字符串，再是123456（的16进制），最后是3.14</span></p>
<p><span style="font-family: 'Microsoft YaHei';">继续调试至第二个printf（一直按n）</span></p>
<p><span style="font-family: 'Microsoft YaHei';"><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/格式化字符串漏洞 format string exploit（一）3.png" alt="" width="564" height="389" /></span></p>
<p><span style="font-family: 'Microsoft YaHei';">&nbsp;</span></p>
<p><span style="font-family: 'Microsoft YaHei';">&nbsp;</span></p>
<p><span style="font-family: 'Microsoft YaHei';">&nbsp;stack中我们发现，首先入栈的依旧是格式化字符串，但是上面三个参数不再是之前的那几个了。按照原理，第二次输出的应该是0xffffcfb4及之后的两个内存对应的内容。下面我们来细致讨论。</span></p>
<p><span style="font-family: 'Microsoft YaHei';">&nbsp;</span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 14pt;"><strong>0x01 漏洞利用</strong></span></p>
<p><span style="font-family: 'Microsoft YaHei';">利用格式化字符串漏洞，我们还可以获取我们所想要输出的内容。一般会有如下几种操作</span></p>
<ul>
<li><span style="font-family: 'Microsoft YaHei';">泄露栈内存</span>
<ul>
<li>获取某个变量的值 （%s）</li>
<li>获取某个变量对应地址的内存 （%p）</li>
</ul>
</li>
<li><span style="font-family: 'Microsoft YaHei';">泄露任意地址内存</span>
<ul>
<li>利用 GOT 表得到 libc 函数地址，进而获取 libc，进而获取其它 libc 函数地址 (addr%n$s)</li>
<li>盲打，dump 整个程序，获取有用信息。</li>
</ul>
</li>
</ul>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 16px;"><strong>&nbsp;一、泄露内存</strong></span></p>
<p><span style="font-family: 'Microsoft YaHei';"><strong>（1）获取栈变量数值</strong></span></p>
<p><span style="font-family: 'Microsoft YaHei';">这里使用ctf wiki上面的例子：</span></p>
<div class="cnblogs_code">
<pre><code>#include &lt;stdio.h&gt;
<span style="color: #0000ff;">int</span><span style="color: #000000;"> main() {
  </span><span style="color: #0000ff;">char</span> s[<span style="color: #800080;">100</span><span style="color: #000000;">];
  </span><span style="color: #0000ff;">int</span> a = <span style="color: #800080;">1</span>, b = <span style="color: #800080;">0x22222222</span>, c = -<span style="color: #800080;">1</span><span style="color: #000000;">;
  scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%s</span><span style="color: #800000;">"</span><span style="color: #000000;">, s);
  printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%08x.%08x.%08x.%s\n</span><span style="color: #800000;">"</span><span style="color: #000000;">, a, b, c, s);
  printf(s);
  </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<p>&nbsp;</p>
<p><span style="font-family: 'Microsoft YaHei';">编译运行调试</span></p>
<p><span style="font-family: 'Microsoft YaHei';"><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/格式化字符串漏洞 format string exploit（一）4.png" alt="" /></span></p>
<p><span style="font-family: 'Microsoft YaHei';">&nbsp;</span></p>
<p><span style="font-family: 'Microsoft YaHei';">&nbsp;调试：</span><br /><span style="font-family: 'Microsoft YaHei';"><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/格式化字符串漏洞 format string exploit（一）5.png" alt="" /></span></p>
<p><span style="font-family: 'Microsoft YaHei';">&nbsp;</span></p>
<p><span style="font-family: 'Microsoft YaHei';">&nbsp;直接转载（copy）了：可以看出，此时此时已经进入了 printf 函数中，栈中第一个变量为返回地址，第二个变量为格式化字符串的地址，第三个变量为 a 的值，第四个变量为 b 的值，第五个变量为 c 的值，第六个变量为我们输入的格式化字符串对应的地址。继续运行程序，按c</span></p>
<p><span style="font-family: 'Microsoft YaHei';"><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/格式化字符串漏洞 format string exploit（一）6.png" alt="" width="712" height="443" /></span></p>
<p><span style="font-family: 'Microsoft YaHei';">&nbsp;</span></p>
<p><span style="font-family: 'Microsoft YaHei';">&nbsp;将会把上图中0xffffcf44及其后面两个地址包含的内容输出输出：</span><br /><span style="font-family: 'Microsoft YaHei';"><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/格式化字符串漏洞 format string exploit（一）7.png" alt="" /></span></p>
<p><span style="font-family: 'Microsoft YaHei';">&nbsp;</span></p>
<p><span style="font-family: 'Microsoft YaHei';">&nbsp;并不是每次得到的结果都一样 ，栈上的数据会因为每次分配的内存页不同而有所不同，这是因为栈是不对内存页做初始化的。这可以从我上面的几个截图结果看出来。</span></p>
<p><span style="font-family: 'Microsoft YaHei';"><strong>（2）获取栈指定变量值</strong></span></p>
<p><span style="font-family: 'Microsoft YaHei';">可以使用%n$x获得栈上第n+1个参数，格式化字符串是第一个参数，那么如果想获得printf的第n个参数，就需要加1.</span></p>
<p><span style="font-family: 'Microsoft YaHei';">如，我想获得第三个参数值f7e946bb，那么我就输入%3$x</span></p>
<p><span style="font-family: 'Microsoft YaHei';"><strong>（3）获取对应字符串：%s</strong></span></p>
<p><span style="font-family: 'Microsoft YaHei';"><strong>（4）获取数据:%p</strong></span></p>
<p><span style="font-family: 'Microsoft YaHei';"><strong>&nbsp;</strong></span></p>
<p><span style="font-family: 'Microsoft YaHei'; font-size: 16px;"><strong>二、获取任意地址内存</strong></span></p>
<p><span style="font-family: 'Microsoft YaHei';">上面的泄露并不强力，比赛中经常需要泄露某一个 libc 函数的 got 表内容，从而得到其地址，进而获取 libc 版本以及其他函数的地址，这时候，能够完全控制泄露某个指定地址的内存就显得很重要了。</span></p>
<p><span style="font-family: 'Microsoft YaHei';">这里我们再看一遍源程序代码：</span></p>
<div class="cnblogs_code">
<pre><code>#include &lt;stdio.h&gt;
<span style="color: #0000ff;">int</span><span style="color: #000000;"> main() {
  </span><span style="color: #0000ff;">char</span> s[<span style="color: #800080;">100</span><span style="color: #000000;">];
  </span><span style="color: #0000ff;">int</span> a = <span style="color: #800080;">1</span>, b = <span style="color: #800080;">0x22222222</span>, c = -<span style="color: #800080;">1</span><span style="color: #000000;">;
  scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%s</span><span style="color: #800000;">"</span><span style="color: #000000;">, s);
  printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%08x.%08x.%08x.%s\n</span><span style="color: #800000;">"</span><span style="color: #000000;">, a, b, c, s);
  printf(s);
  </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
}</span></pre>
</div>
<p>&nbsp;</p>
<p><span style="font-family: 'Microsoft YaHei';">scanf接收入s的值，然后两个printf。这里我们输入%s，如下调试，打印出0xff007325, 就是%s对应的字符串值，所以，输出函数的栈分布，栈上的第一个参数就是格式化字符串的地址。</span></p>
<p><span style="font-family: 'Microsoft YaHei';"><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/格式化字符串漏洞 format string exploit（一）8.png" alt="" width="709" height="733" /></span></p>
<p><span style="font-family: 'Microsoft YaHei';">这就意味着格式化字符串内容可控，同时，还需要注意的是，第一个参数虽然放置的是格式化字符串的地址，但是，输出函数并没有在这里开始调用，你也可以从上图中看到，在0xffffcf50处，又有一个%s，这里才是调用格式化字符串的时候，输出格式化字符串表达的内容时刻。这就意味着，因为格式化字符串我们可以自己控制，那么，如果我格式化字符串里面包含了%s，它会输出%s对应地址（0xff007325）所包含的内容，如果包含scanf@got, 它会输出scanf@got对应地址包含的内容，也就是scanf的真实地址。</span></p>
<p><span style="font-family: 'Microsoft YaHei';">总结：1、格式化字符串可以按照自己的意愿输入。2、格式化字符串的地址为栈上的第一个参数，顺序之后的某个位置会调用这个格式化字符串，以格式化字符串的内容输出内容。</span></p>
<p><span style="font-family: 'Microsoft YaHei';">所以，我们只要知道，调用这个格式化字符串的位置就可以了。</span></p>
<p><span style="font-family: 'Microsoft YaHei';">根据CTF WIKI上的说明方案，我们可以使用下面的字符来确定格式化字符串在哪调用：</span></p>
<div class="cnblogs_code">
<pre><code><span style="font-family: 'Microsoft YaHei';">[tag]%p%p%p%p%p%p...</span></pre>
</div>
<p><span style="font-family: 'Microsoft YaHei';">如果输出栈的内容与我们前面的 tag 重复了，那么我们就可以有很大把握说明该地址就是格式化字符串的地址，之所以说是有很大把握，这是因为不排除栈上有一些临时变量也是该数值（0x41414141）。如：</span></p>
<p><span style="font-family: 'Microsoft YaHei';"><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/格式化字符串漏洞 format string exploit（一）9.png" alt="" width="740" height="273" /></span></p>
<p><span style="font-family: 'Microsoft YaHei';">&nbsp;</span></p>
<p><span style="font-family: 'Microsoft YaHei';">&nbsp;AAAA&nbsp; 0XFFD2RC30&nbsp; 0XC2&nbsp; 0XF7E596BB&nbsp;&nbsp;0X41414141&nbsp; &nbsp;0X702570250</span></p>
<p><span style="font-family: 'Microsoft YaHei';">我们调试看一下：</span></p>
<p><span style="font-family: 'Microsoft YaHei';">我输入的是AAAA加上8个%p</span></p>
<p><span style="font-family: 'Microsoft YaHei';"><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/格式化字符串漏洞 format string exploit（一）10.png" alt="" width="903" height="695" /></span></p>
<p><span style="font-family: 'Microsoft YaHei';">&nbsp;</span></p>
<p><span style="font-family: 'Microsoft YaHei';">&nbsp;你会看到，AAAA后面依次输出8个内容，</span></p>
<p><span style="font-family: 'Microsoft YaHei';">第一个输出AAAA，这本来就是字符，作为一个标志显示出来罢了。然后往后，%p开始作用，依次是0xffffcfa0（可以看到格式化字符串为第一个参数，%p从格式字符串下一个开始），0xc2, 0xf7e946bb这些都是跟着格式化字符串后面的参数，之后，便打印出来0xffffcfa0地址对应的内容，即字符串。也就是说，其相对printf函数，为第5个参数（第五行），但是相对格式化字符串（第一行），是第四个参数。那么既然是第四个参数，我们使用%4$s看看测试一下。</span></p>
<p><span style="font-family: 'Microsoft YaHei';">然后你会发现core dump：</span></p>
<p><span style="font-family: 'Microsoft YaHei';"><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/格式化字符串漏洞 format string exploit（一）11.png" alt="" /></span></p>
<p><span style="font-family: 'Microsoft YaHei';">&nbsp;</span></p>
<p><span style="font-family: 'Microsoft YaHei';">&nbsp;为啥？调试。</span></p>
<p><span style="font-family: 'Microsoft YaHei';"><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/格式化字符串漏洞 format string exploit（一）12.png" alt="" width="657" height="320" /></span></p>
<p><span style="font-family: 'Microsoft YaHei';">&nbsp;</span></p>
<p><span style="font-family: 'Microsoft YaHei';">&nbsp;首先，%4$s对应的存放地址为0xffffcfa0, 我们查看内存发现存着的是0x73243425, 再看看0x73243425放着什么，啥都没有，那肯定崩溃。</span></p>
<p><span style="font-family: 'Microsoft YaHei';">我们输入%4$s是0x73243425, 我们输入%5$s是0x732434525,................</span></p>
<p><span style="font-family: 'Microsoft YaHei';">那就是说，我们确定了参数为第几个后，在tag处输入想要获得的内容的地址，那么，输出的将是输入的地址对应的内容。</span></p>
<p><span style="font-family: 'Microsoft YaHei';">然后使用CTF wiki上payload改改就可以实现获取scanf的地址：</span></p>
<div class="cnblogs_code">
<pre><code><span style="color: #0000ff;">from</span> pwn <span style="color: #0000ff;">import</span> *<span style="color: #000000;">
sh </span>= process(<span style="color: #800000;">'</span><span style="color: #800000;">./leakmemory</span><span style="color: #800000;">'</span><span style="color: #000000;">)  
leakmemory </span>= ELF(<span style="color: #800000;">'</span><span style="color: #800000;">./leakmemory</span><span style="color: #800000;">'</span><span style="color: #000000;">)  
</span><span style="color: #800080;">__isoc99_scanf_got</span> = leakmemory.got[<span style="color: #800000;">'</span><span style="color: #800000;">__isoc99_scanf</span><span style="color: #800000;">'</span>]  <span style="color: #008000;">#</span><span style="color: #008000;">获取got地址</span>
<span style="color: #0000ff;">print</span> hex(<span style="color: #800080;">__isoc99_scanf_got</span><span style="color: #000000;">)
payload </span>= p32(<span style="color: #800080;">__isoc99_scanf_got</span>) + <span style="color: #800000;">'</span><span style="color: #800000;">%4$s</span><span style="color: #800000;">'</span>  <span style="color: #008000;">#</span><span style="color: #008000;">想要输出的地址加上确定好的参数位置</span>
<span style="color: #0000ff;">print</span><span style="color: #000000;"> payload
sh.sendline(payload)
sh.recvuntil(</span><span style="color: #800000;">'</span><span style="color: #800000;">%4$s\n</span><span style="color: #800000;">'</span><span style="color: #000000;">)
</span><span style="color: #0000ff;">print</span> hex(u32(sh.recv()[4:8])) <span style="color: #008000;">#</span><span style="color: #008000;"> 去掉 __isoc99_scanf@got的地址</span>
sh.interactive()</pre>
</div>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>