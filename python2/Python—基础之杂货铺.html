<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Python—基础之杂货铺' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Python—基础之杂货铺</center></div><div class='banquan'>原文出处:本文由博客园博主刘_love_田提供。<br/>
原文连接:https://www.cnblogs.com/liuhaidon/p/11626520.html</div><br>
    <p><span style="background-color: #ffff00; color: #ff00ff; font-size: 16px;"><strong>列表、元组、字典之前的互相转换</strong></span></p>
<p><span style="background-color: #ffffff; color: #000000; font-size: 16px;"><strong>列表与元组的转换</strong></span></p>
<div class="cnblogs_Highlighter">
<pre><code># 列表转换成元组：使用 tuple 函数
num_list = [3, 6, 9]
num_tuple = tuple(num_list)
print num_tuple, type(num_tuple)    # (3, 6, 9)  &lt;type 'tuple'&gt;

# 元组转换成列表：使用 list 函数
num_tuple = (2, 4, 6)
num_list = list(num_tuple)
print num_list, type(num_list)      # [2, 4, 6]  &lt;type 'list'&gt;</pre>
</div>
<p><span style="background-color: #ffff00; color: #ff00ff; font-size: 16px;"><strong>字符串格式化输出</strong></span></p>
<p><span style="background-color: #ffffff; color: #000000;">字符串的格式化输出使得字符串的使用更加灵活、且格式输出一致。格式化输出的两种方式：百分号方式、format方式。</span></p>
<p><strong><span style="background-color: #ffffff; color: #000000;">百分号方式</span></strong></p>
<div class="cnblogs_Highlighter">
<pre><code>info = "My name is %s" % "杰伦"
print info      # 结果：My name is 杰伦
info = "My name is %s, I'm %d years old" % ("杰伦", 22)
print info      # 结果：My name is 杰伦, I'm 22 years old

info = "My name is %(name)s, I'm %(age)d years old" % {"name":"杰伦", "age":22}
print info      # 结果：My name is 杰伦, I'm 22 years old      

# 浮点数，并且指定小数点后的位数，四舍五入
st1 = "The number is %.2f" % 68.68888       # 结果：The number is 68.69
st2 = "The number is %6.2f" % 68.68888      # 结果：The number is  68.69
# 百分之几
st3 = "The number is %.2f%%" % 12.366566    # 结果：The number is 12.37%
st4 = "The number is %6.2f%%" % 12.366566   # 结果：The number is  12.37%
# 科学计数法
st5 = "The number is %e" % 11000012         # 结果：The number is 1.100001e+07</pre>
</div>
<p><strong><span style="background-color: #ffffff; color: #000000;">format方式</span></strong></p>
<div class="cnblogs_Highlighter">
<pre><code># 方式1：占位符为{},以元组的方式传入
info = "My name is {}, I'm {} years old".format("杰伦", 22)
 
# 方式2：占位符为{int},以元组的方式传入
info = "My name is {0}, I'm {1} years old".format("杰伦", 22)
info = "My name is {1}, I'm {0} years old".format(22, "杰伦")
info = "My name is {1}, I'm {0} years old".format(*[22, "杰伦"])
 
# 方式3：占位符为{key},以字典的方式传入
info = "My name is {name}, I'm {age} years old".format(name="杰伦", age=22)
info = "My name is {name}, I'm {age} years old".format(**{"name":"杰伦", "age":22})
 
# 传入列表中的元素
info1 = "My name is {0[0]},I'm {1[1]} years old.".format(["杰伦", "俊杰"], [22, 23])
# 规定传入的参数的格式，并且以元组的形式传入
info2 = "My name is {:s},I'm {:d} years old.".format("杰伦", 22)
# 规定传入的参数的格式，并且以字典的形式传入
info3 = "My name is {name:s},I'm {age:d} years old.".format(name="杰伦", age=22)
# 占位符-&gt;s:字符串，d:十进制，b：二进制，0:八进制，x:十六进制,X：大写十六进制，e:科学计数法，.2f：浮点数，保留两位小数
info4 = "numbers --&gt;{:s},{:d},{:b},{:o},{:x},{:X},{:e},{:.2f}".format("hello",15,15,15,15,15,16.6666,16.3333)
 
# 如何将文本高亮显示
name ="\033[42;1m 杰伦 \033[0m"
print name</pre>
</div>
<p><span style="background-color: #ffff00; color: #ff00ff; font-size: 18px;"><strong>复制、深拷贝和浅拷贝的区别</strong></span></p>
<p><span style="background-color: #ffffff; color: #000000;"><strong>复制</strong></span></p>
<div class="cnblogs_Highlighter">
<pre><code>import copy
 
ls1 = ["java", "python", [1,2,3]]
ls2 = ls1
 
ls2[0] = "c++"
print ls1, ls2   # 输出为：['c++', 'python', [1, 2, 3]]  ['c++', 'python', [1, 2, 3]]
 
ls2[2][0] = 6
print ls1, ls2   # 输出为：['c++', 'python', [6, 2, 3]]  ['c++', 'python', [6, 2, 3]]</pre>
</div>
<p><span style="background-color: #ffffff; color: #000000;"><strong>浅拷贝</strong></span></p>
<div class="cnblogs_Highlighter">
<pre><code>import copy

ls1 = ["java", "python", [1,2,3]]
ls2 = copy.copy(ls1)   # 浅拷贝

# 修改列表中的不可变数据类型，ls2变，ls1不变
ls2[0] = "c++"
print ls1, ls2   # 输出为：['java', 'python', [1, 2, 3]]  ['c++', 'python', [1, 2, 3]]

# 修改列表中的可变数据类型时，ls2变，ls1也变
ls2[2][0] = 6
print ls1, ls2   # 输出为：['java', 'python', [6, 2, 3]]  ['c++', 'python', [6, 2, 3]]</pre>
</div>
<p><span>这是由于：浅拷贝--&gt;拷贝的仅仅是原列表以及原列表元素中内存指针，故ls2中的不可变数据类型发生改变时，其内存指针也发生了改变，则当ls2[0]发生改变时，其内存指针发生改变，指向的不再存储"little-five"的内存空间,而是存放"xiaowu"的内存空间。故ls1不受影响。而当修改ls2中可变数据类型时，修改列表[1,2,3]中的元素时，该列表[1,2,3]的内存地址并不发生改变，故ls1和ls2的内存指针均指向该列表[1,2,3]，故ls2发生该表，ls1也跟着改变。</span></p>
<p><span>修改ls2列表里的不可变数据类型(如字符串)，则ls2[0]的地址值就发生了改变，与ls1[0]的地址值不是同一个了，则ls1列表的值也就不会发生改变。如果ls2增加一个元素，则ls1也不会改变。</span></p>
<p><span>修改ls2列表里的可变数据类型时(如列表)，则ls2[2][0]的地址值没变，与ls1[2][0]的地址值还是同一个，只是这个地址值指向的值变了。</span></p>
<p><span>个人理解：列表里面存储的是地址。</span>从下面例子可以看出可变数据类型和不可变数据类型的区别：</p>
<div class="cnblogs_Highlighter">
<pre><code># 当修改不可变数据类型，其内存指针发生改变
name = "python"
print id(name)      # 140357443045920
name = "java"
print id(name)      # 140357443045968

# 当修改可变数据类型时，其内存指针不发生改变
arry = ["English", "Chinese", "Jpan"]
print id(arry)      # 140357442918160
arry[2] = "USA"
print id(arry)      # 140357442918160</pre>
</div>
<p><span style="background-color: #ffffff; color: #000000;"><strong>深拷贝</strong></span></p>
<div class="cnblogs_Highlighter">
<pre><code>import copy

ls1 = ["java", "python", [1,2,3]]
ls3 = copy.deepcopy(ls1)  # 深拷贝

ls3[0] = "c++"
print ls1, ls3    # 输出为：['java', 'python', [1, 2, 3]]  ['c++', 'python', [1, 2, 3]]

ls3[2][0] = 6
print ls1, ls3    # 输出为：['java', 'python', [1, 2, 3]]  ['c++', 'python', [6, 2, 3]]
</pre>
</div>
<p>从上述例子可以看出，ls1与ls3再无任何关联，这是由于ls3拷贝过来时，其拷贝的不止内存指针，同时还创建新的内存空间，并将数据拷贝至新的内存空间。故新的内存指针指向新的内存空间。</p>
<p>　　</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>