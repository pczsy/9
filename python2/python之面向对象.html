<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修python之面向对象' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>python之面向对象</center></div><div class='banquan'>原文出处:本文由博客园博主追梦NAN提供。<br/>
原文连接:https://www.cnblogs.com/zdqc/p/11278575.html</div><br>
    <h1 id="第一章-面向对象初识">第一章 面向对象初识</h1>
<hr />
<p><strong>面向对象的三大特性是什么？ 抽象、继承、多态。</strong></p>
<p><strong>面向对象第一个优点:</strong>*</p>
<p><strong>对相似功能的函数,同一个业务的函数进行归类,分类,使你的代码更清晰化，更合理化。</strong></p>
<p>什么是面向对象。</p>
<p>面向对象的程序设计的核心是对象（上帝式思维），要理解对象为何物，必须把自己当成上帝，上帝眼里世间存在的万物皆为对象，不存在的也可以创造出来。</p>
<p><strong>那什么是类？什么是对象？</strong></p>
<p>类：就是具有相同属性和功能的一类事物。</p>
<p>对象：就是类的具体表现。对象一定是不一样的</p>
<p><strong><em>面向对象的第二个优点:</em></strong></p>
<p><strong>面向对象，要拥有上帝的视角看问题，类其实就是一个公共模板（厂房），对象就是从具体的模板实例化出来,得对象,得一切</strong></p>
<h2 id="面向对象的结构">1. 面向对象的结构</h2>
<pre><code><code>class Human:
    &quot;&quot;&quot;
    类的具体结构
    &quot;&quot;&quot;
    #第一部分:静态属性
    mind = &quot;思想&quot;
    language =&quot;语言&quot;

    #第二部分:动态方法
    def work(self):
        print(&quot;工作&quot;)
    def eat(self):
        print(&quot;吃饭&quot;)</code></pre>
<p>class 是关键字与def用法相同，定义一个类。<br />
Human是此类的类名，类名使用驼峰(CamelCase)命名风格，首字母大写，私有类可用一个下划线开头。<br />
类的结构从大方向来说就分为两部分：<br />
静态变量。<br />
动态方法。</p>
<h2 id="从类名的角度研究类">1. 从类名的角度研究类</h2>
<h3 id="类名操作类中的属性">1.类名操作类中的属性</h3>
<pre><code><code>class Human:
    &quot;&quot;&quot;
    类的具体结构
    &quot;&quot;&quot;
    #第一部分:静态属性
    mind = &quot;思想&quot;
    language =&quot;语言&quot;

    #第二部分:动态方法
    def work(self):
        print(&quot;工作&quot;)
    def eat(self):
        print(&quot;吃饭&quot;)</code></pre>
<h4 id="类名查看类中所有的内容">1.类名查看类中所有的内容</h4>
<pre><code><code>print(Human.__dict__)</code></pre>
<h4 id="类名操作类中的静态属性">2.类名操作类中的静态属性</h4>
<p>1.增加</p>
<pre><code><code>Human.body=&quot;有头发&quot;
print(Human.__dict__)</code></pre>
<p>2.删除</p>
<pre><code><code>del Human.mind</code></pre>
<p>3.改</p>
<pre><code><code>Human.mind =&quot;个性&quot;
print(Human.__dict__)</code></pre>
<p>4.查</p>
<pre><code><code>print(Human.language)
# print(Human.__dict__)</code></pre>
<h2 id="类名操作动态方法">2.类名操作动态方法</h2>
<p>除了两个特殊方法：静态方法，类方法之外，一般不会通过类名操作一个类中的方法.</p>
<pre><code><code>Human.work(123)</code></pre>
<p>总结:一般类名</p>
<h2 id="从对象的角度研究类">3. 从对象的角度研究类</h2>
<h3 id="什么是对象">1.什么是对象</h3>
<p>对象是从类中出来的，只要是类名加上（），这就是一个实例化过程，这个就会实例化一个对象。**</p>
<p>实例化一个对象总共发生了三件事：</p>
<p>　　1，在内存中开辟了一个对象空间。</p>
<p>　　2，自动执行类中的_<strong><em>init</em></strong>_方法，并将这个对象空间（内存地址）传给了__init__方法的第一个位置参数self。</p>
<p>　　3，在__<strong>init</strong> _方法中通过self给对象空间添加属性。</p>
<pre><code><code>class Human:
    &quot;&quot;&quot;
    类的具体结构
    &quot;&quot;&quot;
    
    mind = &quot;思想&quot;
    language =&quot;语言&quot;

    def __init__(self,name,age):
# self 和 obj 指向的是同一个内存地址同一个空间，下面就是通过self给这个对象空间封装四个属性。
        self.n=name
        self.a=age
    def work(self):
        print(&quot;工作&quot;)
    def eat(self):
        print(&quot;吃饭&quot;)

obj=Human(&quot;zbb&quot;,18) #实例化过程
#得到一个返回值,这个返回值就是对象,实例
print(obj.n)
print(obj.a)
print(obj.__dict__)
#zbb
#{&#39;n&#39;: &#39;zbb&#39;}</code></pre>
<h3 id="对象操作对象空间属性">2.对象操作对象空间属性</h3>
<h4 id="对象查看对象的空间的所有属性">1.对象查看对象的空间的所有属性</h4>
<pre><code><code>obj = Human(&#39;zbb&#39;,18)
print(obj.__dict__)</code></pre>
<h4 id="对象操作对象空间的属性">2. 对象操作对象空间的属性</h4>
<pre><code><code>obj = Human(&#39;zbb&#39;,18)
增:
obj.sex = &#39;laddy_boy&#39;
删:
del obj.a
改:
obj.a = 1000
查:
print(obj.n)
print(obj.__dict__)</code></pre>
<h3 id="对象查看类中的属性">3.对象查看类中的属性</h3>
<pre><code><code>obj = Human(&#39;zbb&#39;,18)
# print(obj.mind)
obj.mind = &#39;无脑的&#39;
print(obj.mind)
print(Human.mind)</code></pre>
<h3 id="对象调用类中的方法">4.对象调用类中的方法</h3>
<pre><code><code>class Human:

    mind = &#39;有思想&#39;
    language = &#39;实用语言&#39;
    def __init__(self,name,sex,age,hobby):
        self.n = name
        self.s = sex
        self.a = age
        self.h = hobby

    def work(self):
        print(self)
        print(&#39;人类会工作&#39;)

    def tools(self):
        print(&#39;人类会使用工具&#39;)

obj = Human(&#39;barry&#39;,&#39;男&#39;,18,&#39;运动&#39;)
obj.work()
obj.tools()</code></pre>
<h3 id="self-是什么">5.self 是什么？</h3>
<pre><code><code>self其实就是类中方法（函数）的第一个位置参数，只不过解释器会自动将调用这个函数的对象传给self。所以咱们把类中的方法的第一个参数约定俗成设置成self, 代表这个就是对象。</code></pre>
<p><strong>一个类可以实例化多个对象</strong></p>
<pre><code><code>obj1= Human(&#39;小胖&#39;,&#39;男&#39;,20,&#39;美女&#39;)
obj2= Human(&#39;相爷&#39;,&#39;男&#39;,18,&#39;肥女&#39;)
print(obj1,obj2)
print(obj1.__dict__)
print(obj2.__dict__)</code></pre>
<h1 id="第二章-类空间问题以及类之间的关系">第二章 类空间问题以及类之间的关系</h1>
<h2 id="何处可以添加对象属性">1.何处可以添加对象属性</h2>
<pre><code><code>class A:
    def __init__(self,name):
        self.name = name

    def func(self,sex):
        self.sex = sex</code></pre>
<pre><code><code># 类外面可以：
obj = A(&#39;barry&#39;)
obj.age = 18
print(obj.__dict__)  # {&#39;name&#39;: &#39;barry&#39;, &#39;age&#39;: 18}

# 类内部也可以：
obj = A(&#39;barry&#39;) # __init__方法可以。
obj.func(&#39;男&#39;)  # func 方法也可以。
</code></pre>
<h2 id="何处可以添加类的静态属性">2.何处可以添加类的静态属性</h2>
<pre><code><code>class A:
    def __init__(self, name):
        self.name = name

    def func(self, sex):
        self.sex = sex

    def func1(self):
        A.bbb = &#39;ccc&#39;
</code></pre>
<pre><code><code># 类的外部可以添加

A.aaa = &#39;djb&#39;
print(A.__dict__)

# 类的内部也可以添加。

A.func1(111)
print(A.__dict__)
</code></pre>
<h2 id="对象如何找到类的属性">3. 对象如何找到类的属性</h2>
<p><img src="./images/python之面向对象0.png" /></p>
<p>对象查找属性的顺序：先从对象空间找 ------&gt; 类空间找 ------&gt; 父类空间找 -------&gt;.....</p>
<p>类名查找属性的顺序：先从本类空间找 -------&gt; 父类空间找--------&gt; ........</p>
<p>上面的顺序都是单向不可逆，类名不可能找到对象的属性。</p>
<h2 id="类与类之间的关系">4.类与类之间的关系</h2>
<ol>
<li>依赖关系</li>
<li>关联关系</li>
<li>组合关系</li>
<li>聚合关系</li>
<li>实现关系</li>
<li>继承关系(类的三大特性之一：继承。)</li>
</ol>
<h3 id="依赖关系">1.依赖关系</h3>
<p>主从之分</p>
<p>依赖关系：将一个类的对象或者类名传到另一个类的方法使用。</p>
<h3 id="关联组合聚合关系">2.关联,组合,聚合关系</h3>
<ol>
<li>关联关系. 两种事物必须是互相关联的. 但是在某些特殊情况下是可以更改和更换的.</li>
<li>聚合关系. 属于关联关系中的⼀种特例. 侧重点是xxx和xxx聚合成xxx. 各⾃有各⾃的声明周期. 比如电脑. 电脑⾥有CPU, 硬盘, 内存等等. 电脑挂了. CPU还是好的. 还是完整的个体</li>
<li>组合关系. 给对象封装一个属性,属性值是另一个类的对象</li>
</ol>
<pre><code><code>class  Boy:

    def __init__(self,name,girl=None):
        self.name = name
        self.girl=girl

    def hava_diner(self):
        if self.girl:
            print(f&quot;{self.name}请{self.girl}吃饭&quot;)
        else:
            print(&quot;单身狗&quot;)


live=Boy(&quot;qw&quot;)
# live.hava_diner()
live.girl=&quot;zxy&quot;
live.hava_diner()
</code></pre>
<pre><code><code>class  Boy:

    def __init__(self,name,girl=None):
        self.name = name
        self.girl=girl

    def hava_diner(self):
        if self.girl:
            print(f&quot;{self.name}请{self.girl}吃饭&quot;)
        else:
            print(&quot;单身狗&quot;)

    def girl_skill(self):
        self.girl.skill()

class Girl:
    def __init__(self,name):
        self.name=name

    def  skill(self):
        print(f&quot;{self.name}能吃&quot;)
zbb=Boy(&quot;zbb&quot;)
# live.hava_diner()
zxy =Girl(&quot;zxy&quot;)
zbb.girl=zxy
zbb.girl_skill()
</code></pre>
<pre><code><code>class  Game_role:

    def __init__(self,name,ad,hp):
        self.name=name
        self.ad=ad
        self.hp=hp

    def equipment(self,wea):
        self.weapon =wea   #组合关系


class Weapon:
    def  __init__(self,name,ad):
        self.name = name
        self.ad  = ad

    def weapon_attack(self,p1,p2): #依赖关系
        p2.hp-=self.ad
        print(f&quot;{p1.name}利用{self.name}给了{p2.name}一枪,{p2.name}掉了{self.ad}血,还剩{p2.hp}&quot;)

gailun =Game_role(&quot;盖伦&quot;,10,100)
yasuo =Game_role(&quot;剑豪&quot;,20,80)
Sword = Weapon(&quot;大保健&quot;,16)
Musket = Weapon(&#39;菊花枪&#39;,20)
# 给游戏人物封装武器属性
gailun.equipment(Sword)

gailun.weapon.weapon_attack(gailun,yasuo)
</code></pre>
<h1 id="第三章-继承">第三章 继承</h1>
<h2 id="什么是面向对象的继承">1.什么是面向对象的继承</h2>
<p>比较官方的说法就是：</p>
<p>继承（英语：inheritance）是面向对象软件技术当中的一个概念。如果一个类别A“继承自”另一个类别B，就把这个A称为“B的子类别”，而把B称为“A的父类别”也可以称“B是A的超类”。继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子类别追加新的属性和方法也是常见的做法。 一般静态的面向对象编程语言，继承属于静态的，意即在子类别的行为在编译期就已经决定，无法在执行期扩充</p>
<p>专业说法: 如果B类继承A类</p>
<p>B类就称为子类,派生类</p>
<p>A类称为父类,基类,超类</p>
<p>通俗一点就是 子承父业</p>
<pre><code><code># 继承的用法：
class Aniaml:
    live = &quot;123&quot;
    def __init__(self,name,sex,age):
            self.name = name
            self.age = age
            self.sex = sex

class Cat(Aniaml):
    pass

class Dog(Aniaml):
    pass
</code></pre>
<p>优点: 减少重复代码 .</p>
<p>增加类之间的耦合度（耦合性不宜多，宜精）</p>
<h2 id="继承的分类">2.继承的分类</h2>
<p>在python2x版本中存在两种类.：<br />
　　⼀个叫<strong>经典类</strong>. 在python2.2之前. ⼀直使⽤的是经典类. 经典类在基类的根如果什么都不写.<br />
　　⼀个叫<strong>新式类</strong>. 在python2.2之后出现了新式类. 新式类的特点是基类的根是object类。<br />
python3x版本中只有一种类：<br />
python3中使⽤的都是<strong>新式类</strong>. 如果基类谁都不继承. 那这个类会默认继承 object</p>
<h2 id="单继承">3.单继承</h2>
<p>1.类名,对象执行父类的方法</p>
<pre><code><code>class Animal:

    live = &quot;有生命&quot;
    def  __init__(self,name,sex,age):
        self.name =name
        self.sex =sex
        self.age =age

    def eat(self):
        print(&quot;chi&quot;)

class Human(Animal):
    body = &quot;有思想&quot;
#类名执行父类属性的方法(不常用)
print(Human.live)
Human.eat(1213)
#子类执行父类的方法
obj = Human(&quot;zbb&quot;,&quot;男&quot;,&quot;23&quot;) #相当于实例化
print(obj.live)
</code></pre>
<p>2.执行顺序</p>
<pre><code><code>p1 = Person(&#39;barry&#39;,&#39;男&#39;,18)
# 实例化对象时必须执行__init__方法,类中没有，从父类找，父类没有，从object类中找。
p1.eat()
# 先要执行自己类中的eat方法，自己类没有才能执行父类中的方法。
</code></pre>
<p>3.同时执行子类以及父类方法</p>
<p>第一种方法(不常用)</p>
<pre><code><code>class Animal:


    def eat(self):
        print(&quot;chi&quot;)

class Human:

    def  __init__(self,name):
        self.name =name
    def eat(self):
        print(f&quot;{self.name}需要吃饭&quot;)
        Animal.eat(self.name)

obj = Human(&quot;zbb&quot;)
obj.eat()
</code></pre>
<p>第二种方法</p>
<pre><code><code>class Animal:

    def eat(self):
        print(&quot;chi&quot;)

class Human(Animal):
    def  __init__(self,name):
        self.name =name

    def eat(self):
        print(f&quot;{self.name}需要吃饭&quot;)
        super().eat()

obj = Human(&quot;zbb&quot;)
obj.eat()</code></pre>
<p>super() 重构父类的方法</p>
<p>解决多重继承问题</p>
<p>不需要明确给出任何基类的名字,它会自动找到<strong>所有直接基类</strong>,<strong>及其对应的方法</strong>.<strong>用于继承.</strong></p>
<p><strong>super()</strong>的好处<strong>就是可以避免直接使用父类的名字.主要用于多重继承</strong></p>
<h2 id="多继承">4.多继承</h2>
<pre><code><code>在python2x版本中存在两种类.：
　　⼀个叫经典类. 在python2.2之前. ⼀直使⽤的是经典类. 经典类在基类的根如果什么都不写.
　　⼀个叫新式类. 在python2.2之后出现了新式类. 新式类的特点是基类的根是object类。
python3x版本中只有一种类：
python3中使⽤的都是新式类. 如果基类谁都不继承. 那这个类会默认继承 object</code></pre>
<p>1.经典类的多继承</p>
<p>经典类: 深度优先.从左至右,深度优先.</p>
<p>不继承object类</p>
<p><img src="./images/python之面向对象1.png" /></p>
<p>2.新式类的多继承</p>
<p>继承object类</p>
<p><img src="./images/python之面向对象2.png" /></p>
<pre><code><code>class O:
    name = &#39;1&#39;

class D(O):
    pass

class E(O):
    name = &#39;2&#39;
    # pass
class F(O):
    name = &#39;3&#39;

class B(D,E):
    pass

class C(E,F):
    pass

class A(B,C):
    pass

obj = A()
print(obj.name)

# mro(Child(Base1，Base2)) = [ Child ] + merge( mro(Base1), mro(Base2), [ Base1, Base2] )
# mro(A(B,C)) = [A] + merge(mro(B),mro(C),[B,C])
</code></pre>
<pre><code><code>总结:直接print 不需要什么算法
print(A.mro())
mro是继承付父类方法时的顺序表
</code></pre>
<h1 id="第四章-封装">第四章 封装</h1>
<p>封装，顾名思义就是将内容封装到某个地方，以后再去调用被封装在某处的内容。</p>
<p>所以，在使用面向对象的封装特性时，需要：</p>
<ul>
<li>将内容封装到某处</li>
<li>从某处调用被封装的内容</li>
</ul>
<h2 id="第一步将内容封装到某处">第一步：将内容封装到某处</h2>
<p><img src="./images/python之面向对象3.png" /></p>
<p>self 是一个形式参数，当执行 obj1 = Foo( ) 时，self 等于 obj1</p>
<p><img src="./images/python之面向对象4.png" /></p>
<h2 id="第二步从某处调用被封装的内容">第二步：从某处调用被封装的内容</h2>
<p>调用被封装的内容时，有两种情况：</p>
<ul>
<li>通过对象直接调用</li>
<li>通过self间接调用</li>
</ul>
<h3 id="通过对象直接调用被封装的内容">1、通过对象直接调用被封装的内容</h3>
<p>上图展示了对象 <strong>ojb1</strong>在内存中保存的方式，根据保存格式可以如此调用被封装的内容：对象.属性名</p>
<pre><code><code>class Foo:
    def __init__(self,name,age):
        self.name = name
        self.age = age


obj1 = Foo(&quot;zbb&quot;,18)
print(obj1.name) # 直接调用obj1对象的name属性
print(obj1.age) # 直接调用obj1对象的age属性
</code></pre>
<h3 id="通过self间接调用被封装的内容">2、通过self间接调用被封装的内容</h3>
<p>执行类中的方法时，需要通过self间接调用被封装的内容</p>
<pre><code><code>class Foo:
    def __init__(self,name,age):
        self.name = name
        self.age = age
    def func(self):
        print(self.name)
        print(self.age)


obj1 = Foo(&quot;zbb&quot;,18)
obj1.func() ## Python默认会将obj1传给self参数
</code></pre>
<p><strong>综上所述，对于面向对象的封装来说，其实就是使用构造方法将内容封装到 对象 中，然后通过对象直接或者self间接获取被封装的内容。</strong></p>
<h1 id="第五章-多态">第五章 多态</h1>
<p>多态，同一个对象，多种形态。python默认支持多态。</p>
<p>鸭子类型</p>
<pre><code><code>python中有一句谚语说的好，你看起来像鸭子，那么你就是鸭子。
对于代码上的解释其实很简答：
class A:
    def f1(self):
        print(&#39;in A f1&#39;)
    
    def f2(self):
        print(&#39;in A f2&#39;)


class B:
    def f1(self):
        print(&#39;in A f1&#39;)
    
    def f2(self):
        print(&#39;in A f2&#39;)
        
obj = A()
obj.f1()
obj.f2()

obj2 = B()
obj2.f1()
obj2.f2()
# A 和 B两个类完全没有耦合性，但是在某种意义上他们却统一了一个标准。
# 对相同的功能设定了相同的名字，这样方便开发，这两个方法就可以互成为鸭子类型。

# 这样的例子比比皆是：str  tuple list 都有 index方法，这就是统一了规范。
# str bytes 等等 这就是互称为鸭子类型。

鸭子类型
</code></pre>
<h1 id="第六章-类的约束">第六章 类的约束</h1>
<pre><code><code>class  Payment:

    def pay(self,money):
        raise  Exception(&quot;你的子类需要定义pay方法&quot;)
        #pass

class QQpay(Payment):

    def pay(self,money):
        print(f&quot;使用qq支付了{money}&quot;)


class Alipay(Payment):
    def  pay(self,money):
        print(f&quot;使用阿里支付了{money}&quot;)


class Wechat(Payment):
    def fuqian(self,money):
        print(f&quot;使用微信支付了{money}&quot;)


def pay(obj,money):  #统一接口
    obj.pay(money) # 这个函数就是统一支付规则，这个叫做： 归一化设计。

obj1 = QQpay()
obj2 = Alipay()
obj3 = Wechat()
pay(obj1,100)
pay(obj2,200)

# pay(obj3,200)  # 会直接找到父类 并发出错误
</code></pre>
<pre><code><code>from  abc import   ABCMeta,abstractmethod

class  Payment(metaclass=ABCMeta):
    #抽象类 接口类  规范和约束  metaclass指定的是一个元类
    @abstractmethod
    def pay(self,money):
        pass #抽象方法


class QQpay(Payment):

    def pay(self,money):
        print(f&quot;使用qq支付了{money}&quot;)


class Alipay(Payment):
    def  pay(self,money):
        print(f&quot;使用阿里支付了{money}&quot;)


class Wechat(Payment):
    def fuqian(self,money):
        print(f&quot;使用微信支付了{money}&quot;)
    # def pay(self,money):#强制定义  不定义会报错
    #     pass

def pay(obj,money): #统一接口
    obj.pay(money)

obj3 = Wechat()   #实例化过程 就报错了
</code></pre>
<p><strong>总结: 约束. 其实就是⽗类对⼦类进⾏约束. ⼦类必须要写xxx⽅法. 在python中约束的⽅式和⽅法有两种:</strong></p>
<p><strong>1. 使⽤抽象类和抽象⽅法</strong>, 由于该⽅案来源是java和c#. 所以使⽤频率还是很少的</p>
<p><strong>2.使⽤⼈为抛出异常的⽅案</strong>. 并且尽量抛出的是NotImplementError. 这样比较专业, ⽽且错误比较明确.(推荐)</p>
<h1 id="第七章-super深入了解">第七章 super（）深入了解</h1>
<p><strong>super是严格按照类的继承顺序执行！！！</strong></p>
<pre><code><code># super可以下一个类的其他方法
# 严格按照类的mro顺序执行
</code></pre>
<pre><code><code>class A:
    def f1(self):
        print(&#39;in A&#39;)

class Foo(A):
    def f1(self):
        super().f1()
        print(&#39;in Foo&#39;)

class Bar(A):
    def f1(self):
        print(&#39;in Bar&#39;)

class Info(Foo,Bar):
    def f1(self):
        super(Foo,self).f1()
        #super(Info,self).f1() #()默认是
        print(&#39;in Info f1&#39;)

obj = Info()
obj.f1()


</code></pre>
<h1 id="第八章-带颜色的print">第八章 带颜色的print</h1>
<p><strong>书写格式：</strong> <strong>开头部分</strong>：\033[显示方式;前景色;背景色m + <strong>结尾部分：</strong>\033[0m</p>
<p>​ 注意：开头部分的三个参数：显示方式，前景色，背景色是可选参数，可以只写其中的某一个；另外由于表示三个参数不同含义的数值都是唯一的没有重复的，所以三个参数的书写先后顺序没有固定要求，系统都能识别；但是，建议按照默认的格式规范书写。</p>
<p>​ 对于结尾部分，其实也可以省略，但是为了书写规范，建议\033[***开头，\033[0m结尾。</p>
<pre><code><code>-------------------------------------------
-------------------------------------------
字体色     |       背景色     |      颜色描述
-------------------------------------------
30        |        40       |       黑色
31        |        41       |       红色
32        |        42       |       绿色
33        |        43       |       黃色
34        |        44       |       蓝色
35        |        45       |       紫红色
36        |        46       |       青蓝色
37        |        47       |       白色
-------------------------------------------
-------------------------------
显示方式     |      效果
-------------------------------
0           |     终端默认设置
1           |     高亮显示
4           |     使用下划线
5           |     闪烁
7           |     反白显示
8           |     不可见
-------------------------------
</code></pre>
<p><strong>数值表示的参数含义：</strong></p>
<p><strong>显示方式:</strong> 0（默认值）、1（高亮）、22（非粗体）、4（下划线）、24（非下划线）、 5（闪烁）、25（非闪烁）、7（反显）、27（非反显）</p>
<p><strong>前景色:</strong> 30（黑色）、31（红色）、32（绿色）、 33（黄色）、34（蓝色）、35（洋 红）、36（青色）、37（白色）</p>
<p><strong>背景色:</strong> 40（黑色）、41（红色）、42（绿色）、 43（黄色）、44（蓝色）、45（洋 红）、46（青色）、47（白色）</p>
<p><strong>常见开头格式</strong>：<br />
\033[0m 默认字体正常显示，不高亮<br />
\033[32;0m 红色字体正常显示<br />
\033[1;32;40m 显示方式: 高亮 字体前景色：绿色 背景色：黑色<br />
\033[0;31;46m 显示方式: 正常 字体前景色：红色 背景色：青色</p>
<p>举例说明：</p>
<p>1，</p>
<pre><code><code>print(&#39;\033[1;35;0m字体变色，但无背景色 \033[0m&#39;)  # 有高亮 或者 print(&#39;\033[1;35m字体有色，但无背景色 \033[0m&#39;)
print(&#39;\033[1;45m 字体不变色，有背景色 \033[0m&#39;)  # 有高亮
print(&#39;\033[1;35;46m 字体有色，且有背景色 \033[0m&#39;)  # 有高亮
print(&#39;\033[0;35;46m 字体有色，且有背景色 \033[0m&#39;)  # 无高亮
</code></pre>
<h1 id="第九章-类的成员">第九章 类的成员</h1>
<h2 id="细分类的组成成员">1.细分类的组成成员</h2>
<pre><code><code>class A:

    company_name = &#39;zbb&#39;  # 静态变量(静态字段)
    __iphone = &#39;1353333xxxx&#39;  # 私有静态变量(私有静态字段)


    def __init__(self,name,age): #特殊方法

        self.name = name  #对象属性(普通字段)
        self.__age = age  # 私有对象属性(私有普通字段)

    def func1(self):  # 普通方法
        pass

    def __func(self): #私有方法
        print(666)


    @classmethod  # 类方法
    def class_func(cls):
        &quot;&quot;&quot; 定义类方法，至少有一个cls参数 &quot;&quot;&quot;
        print(&#39;类方法&#39;)

    @staticmethod  #静态方法
    def static_func():
        &quot;&quot;&quot; 定义静态方法 ，无默认参数&quot;&quot;&quot;
        print(&#39;静态方法&#39;)

    @property  # 属性
    def prop(self):
        pass
</code></pre>
<h2 id="类的私有成员">2.类的私有成员</h2>
<p>对于每一个类的成员而言都有两种形式：</p>
<ul>
<li>公有成员，在任何地方都能访问</li>
<li>私有成员，只有在类的内部才能方法</li>
</ul>
<p><strong>私有成员和公有成员的访问限制不同</strong>：</p>
<h3 id="静态字段静态属性">1.静态字段(静态属性)</h3>
<p>​ 公有静态字段：类可以访问；类内部可以访问；派生类中可以访问</p>
<p>​ 私有静态字段：仅类内部可以访问；</p>
<pre><code><code>class A:
    name = &#39;zbb&#39;
    __name = &quot;zmn&quot;
    def func(self):
        print(self.name)
        print(self.__name)

obj = A()

obj.func()  #内部可以访问
</code></pre>
<p><strong>外部不能访问</strong></p>
<pre><code><code>class A:
    name = &#39;zbb&#39;
    __name = &quot;zmn&quot;
    def func(self):
        pass

obj = A()

print(obj.name)
print(obj.__name) #报错
print(A.__name) #报错
</code></pre>
<h3 id="对象属性">2.对象属性</h3>
<p>公有普通字段：对象可以访问；类内部可以访问；派生类中可以访问</p>
<p>私有普通字段：仅类内部可以访问；</p>
<pre><code><code>class A:

    def __init__(self,name,pwd):

        self.name = name
        self.__pwd = pwd

    def md5(self):
        self.__pwd = self.__pwd + &quot;123&quot;
obj = A(&#39;zbb&#39;,&quot;123&quot;)
print(obj.__pwd)  ###报错 不能在类外部以及派生类使用
</code></pre>
<h3 id="方法">3.方法:</h3>
<p>公有方法:对象可以访问；类内部可以访问；派生类中可以访问</p>
<p>私有方法:仅类内部可以访问；</p>
<pre><code><code>class  A:
    def func(self):
        self.__func()
        print(&quot;1&quot;)
    def __func(self):
        print(&quot;2&quot;)

obj = A()
obj.func()   #内部可以调用
# obj.__func()  报错
#####print(A._A__func)  #(不允许!!!)
</code></pre>
<p>总结:</p>
<p>私有成员来说: 当你遇到重要的数据,功能,(只允许本类使用的一些方法,数据)设置成私有成员.</p>
<p>ps：非要访问私有成员的话，可以通过 对象._类__属性名,但是绝对不允许!!!*</p>
<p>*为什么可以通过._类__私有成员名访问呢?因为类在创建时,如果遇到了私有成员(包括私有静态字段,私有普通字段,私有方法)它会将其保存在内存时自动在前面加上_类名.*</p>
<h2 id="类的其他方法">3.类的其他方法</h2>
<p>实例方法</p>
<p>定义：第一个参数必须是实例对象，该参数名一般约定为“self”，通过它来传递实例的属性和方法（也可以传类的属性和方法）；</p>
<p>调用：只能由实例对象调用。</p>
<h3 id="类方法">1.类方法</h3>
<p>定义：使用装饰器@classmethod。第一个参数必须是当前类对象，该参数名一般约定为“cls”，通过它来传递类的属性和方法（不能传实例的属性和方法）；</p>
<p>调用：实例对象和类对象都可以调用。</p>
<p>类方法有什么用???</p>
<p>​ 得到类名可以实例化对象.</p>
<p>​ 可以操作类的属性.</p>
<pre><code><code>class  A:

    def func(self):
        print(&quot;实例方法&quot;)

    @classmethod
    def cls_func(cls):
        print(f&quot;cls{cls}&quot;) #cls类名
        obj = cls()
        print(obj)  #打印A的内存地址
        print(&quot;类方法&quot;)

A.cls_func()
#obj = A()
#obj.cls_func()
# 类方法: 一般就是通过类名去调用的方法,并且自动将类名地址传给cls,
# 但是如果通过对象调用也可以,但是传的地址还是类名地址.
</code></pre>
<p>例题</p>
<p>创建学生类,只要实例化一个对象,写一个类方法,统计一下具体实例化多少个学生?</p>
<pre><code><code>class Student:

    count = 0
    def __init__(self,name,id):

        self.name = name
        self.id = id
        Student.addnum()

    @classmethod
    def addnum(cls):
        cls.count = cls.count + 1

    @classmethod
    def getnum(cls):
        return cls.count

obj1 = Student(&#39;zbb&#39;, 12343243243) #
obj1 = Student(&#39;zbb&#39;, 12343243243) #
print(Student.getnum())
</code></pre>
<h3 id="静态方法">2.静态方法</h3>
<p>使用装饰器@staticmethod。</p>
<p>​ 调用：实例对象和类对象都可以调用。</p>
<pre><code><code># # 静态方法是不依赖于对象与类的,其实静态方法就是函数.
# 保证代码的规范性,合理的划分.后续维护性高.
#和在外面没有区别

import time

class TimeTest(object):

    area = &#39;中国&#39;
    def __init__(self, hour, minute, second):
        self.hour = hour
        self.minute = minute
        self.second = second

    def change_time(self):
        print(f&#39;你想调整的时间: {self.hour}时{self.minute}分{self.second}秒&#39;)

    @staticmethod
    def showTime():
        return time.strftime(&quot;%H:%M:%S&quot;, time.localtime())


def showTime():
    return time.strftime(&quot;%H:%M:%S&quot;, time.localtime())

def time1():
    pass

def time2():
    pass
# t = TimeTest(2, 10, 10)
# # t.change_time()
# print(TimeTest.showTime())
</code></pre>
<h3 id="属性">3.属性</h3>
<p>property是一种特殊的属性，访问它时会执行一段功能（函数）然后返回值</p>
<p>将动态方法 伪装 成了一个属性,虽然在代码级别上没有什么提升,但是让你看起来更合理</p>
<pre><code><code>例一：BMI指数（bmi是计算而来的，但很明显它听起来像是一个属性而非方法，如果我们将其做成一个属性，更便于理解）

成人的BMI数值：
过轻：低于18.5
正常：18.5-23.9
过重：24-27
肥胖：28-32
非常肥胖, 高于32
　　体质指数（BMI）=体重（kg）÷身高^2（m）
　　EX：70kg÷（1.75×1.75）=22.86
</code></pre>
<pre><code><code>class Bmi:

    def __init__(self,name,height,weight):

        self.name = name
        self.height = height
        self.weight = weight

    def bmi(self):
        return self.weight/self.height**2

obj = Bmi(&#39;赵嘎&#39;, 1.83, 65)
print(obj.bmi())
结果虽然实现了,但是逻辑上感觉不合理.bmi应该是类似于name,age,height,等名词,
但是你把它当做方法使用了.
</code></pre>
<pre><code><code>class Bmi:

    def __init__(self,name,height,weight):

        self.name = name
        self.height = height
        self.weight = weight

    @property
    def bmi(self):
        return self.weight/self.height**2

obj = Bmi(&#39;赵嘎&#39;, 1.83, 65)
# print(obj.bmi)
# property 将执行一个函数需要函数名()变换成直接函数名.
# 将动态方法 伪装 成了一个属性,虽然在代码级别上没有什么提升,但是让你看起来更合理.

</code></pre>
<p><strong>由于新式类中具有三种访问方式，我们可以根据他们几个属性的访问特点，分别将三个方法定义为对同一个属性：获取、修改、删除</strong></p>
<pre><code><code>class Foo:
    @property
    def AAA(self):
        print(&#39;get的时候运行我啊&#39;)

    @AAA.setter
    def AAA(self,value):
        print(&#39;set的时候运行我啊&#39;)

    @AAA.deleter
    def AAA(self):
        print(&#39;delete的时候运行我啊&#39;)

#只有在属性AAA定义property后才能定义AAA.setter,AAA.deleter
f1=Foo()
f1.AAA
f1.AAA=&#39;aaa&#39;
del f1.AAA
# get的时候运行我啊
# set的时候运行我啊
# delete的时候运行我啊
class Foo:
    def get_AAA(self):
        print(&#39;get的时候运行我啊&#39;)

    def set_AAA(self,value):
        print(&#39;set的时候运行我啊&#39;)

    def delete_AAA(self):
        print(&#39;delete的时候运行我啊&#39;)
    AAA=property(get_AAA,set_AAA,delete_AAA) #内置property三个参数与get,set,delete一一对应

f1=Foo()
f1.AAA
f1.AAA=&#39;aaa&#39;
del f1.AAA
</code></pre>
<p>使用场景</p>
<pre><code><code>class Goods(object):

    def __init__(self):
        # 原价
        self.original_price = 100
        # 折扣
        self.discount = 0.8

    @property
    def price(self):
        # 实际价格 = 原价 * 折扣
        new_price = self.original_price * self.discount
        return new_price

    @price.setter
    def price(self, value):
        self.original_price = value

    @price.deltter
    def price(self, value):
        del self.original_price

obj = Goods()
obj.price         # 获取商品价格
obj.price = 200   # 修改商品原价
del obj.price     # 删除商品原价

商品实例

商品示例
</code></pre>
<h2 id="第十章-isinstace-与-issubclass">第十章 isinstace 与 issubclass</h2>
<p><strong>isinstance(a,b)：判断a是否是b类（或者b类的派生类）实例化的对象</strong></p>
<pre><code><code>class A:
    pass

class B(A):
    pass

obj = B()

 
print(isinstance(obj,B))
print(isinstance(obj,A))

isinstance
</code></pre>
<p><strong>isinstace</strong>(a,b) 判断的是 a类是否是b类 子孙类.**</p>
<p><strong>issubclass(a,b)： 判断a类是否是b类（或者b的派生类）的派生类</strong></p>
<pre><code><code>class A:
    pass

class B(A):
    pass

class C(B):
    pass

print(issubclass(B,A))
print(issubclass(C,A))

issubclass
</code></pre>
<p>思考：那么 list str tuple dict等这些类与 Iterble类 的关系是什么？</p>
<pre><code><code>from collections import Iterable

print(isinstance([1,2,3], list))  # True
print(isinstance([1,2,3], Iterable))  # True
print(issubclass(list,Iterable))  # True

# 由上面的例子可得，这些可迭代的数据类型，list str tuple dict等 都是 Iterable的子类。
</code></pre>
<h1 id="第十章-type与object联系">第十章 type与object联系</h1>
<p>type元类是获取该对象从属于的类,而type类比较特殊，Python原则是：一切皆对象，其实类也可以理解为'对象',而type元类又称作构建类，</p>
<p><strong>python中大多数内置的类（包括object）以及自己定义的类，都是由type元类创造的。</strong></p>
<pre><code><code>print(type(&#39;abc&#39;))
print(type(True))
print(type(100))
print(type([1, 2, 3]))
print(type({&#39;name&#39;: &#39;zbb&#39;}))
print(type((1,2,3)))
print(type(object))

class A:
    pass

print(isinstance(object,type))
print(isinstance(A, type))
</code></pre>
<pre><code><code>type 与 object 的关系.
print(type(object)) object类是type类的一个实例.
object类是type类的父类.
print(issubclass(type,object))
</code></pre>
<h1 id="第十一章-反射">第十一章 反射</h1>
<p>程序可以访问、检测和修改它本身状态或行为的一种能力（自省）。</p>
<p><strong>python面向对象中的反射：</strong></p>
<p><strong>通过字符串的形式操作对象相关的属性。</strong></p>
<p>python中的一切事物都是对象（都可以使用反射）</p>
<p><strong>四个可以实现自省的函数</strong></p>
<p>下列方法适用于类和对象（一切皆对象，类本身也是一个对象）</p>
<p><strong>对对象的反射</strong></p>
<pre><code><code>class Foo:
    f=&quot;类的静态变量&quot;
    def __init__(self,name,age):
        self.name = name
        self.age = age

    def  say_hi(self):
        print(f&quot;hello {self.name}&quot;)
#实例化对象
obj = Foo(&quot;zbb&quot;,23)

#检测是否含有某属性
print(hasattr(obj,&quot;name&quot;))
print(hasattr(obj,&quot;say_hi&quot;))
# 获得属性(可以获得是字符串)
n = getattr(obj,&quot;name&quot;)
# print(obj.name)
print(n)
func=getattr(obj,&#39;say_hi&#39;)
# obj.say_hi()
func()

# print(getattr(obj,&#39;aaaaaaaa&#39;)) #报错
print(getattr(obj,&#39;aaaaaaaa&#39;,&#39;不存在啊&#39;)) #报错内容自己定义
# 设置属性
setattr(obj,&#39;sb&#39;,True)
setattr(obj,&#39;show_name&#39;,lambda self:self.name+&#39;nb&#39;)
print(obj.__dict__)
print(obj.show_name(obj))
#删除属性
delattr(obj,&#39;age&#39;)
delattr(obj,&#39;show_name&#39;)
# delattr(obj,&#39;show_name111&#39;)#不存在,则报错
print(obj.__dict__)
</code></pre>
<p><strong>对类的反射</strong></p>
<pre><code><code>class A:
    country = &quot;中国&quot;

    def __init__(self,name,age):
        self.name = name
        self.age =age

    def func(self):
        print(self)
        print(&quot;in  A&quot;)

if  hasattr(A,&quot;country&quot;):
    print(getattr(A,&quot;country&quot;))

if  hasattr(A,&quot;func&quot;):
    obj = A(&quot;zbb&quot;,&quot;18&quot;)
    getattr(obj,&quot;func&quot;)()

</code></pre>
<p><strong>当前模块的反射</strong></p>
<pre><code><code>import sys

def s1():
    print(&#39;s1&#39;)

def s2():
    print(&#39;s2&#39;)

this_module = sys.modules[__name__] #本模块这个对象

hasattr(this_module, &#39;s1&#39;)
getattr(this_module, &#39;s2&#39;)
</code></pre>
<p>在当前模块中一次性执行4个函数</p>
<pre><code><code>def func1():
    print(&#39;in func1&#39;)

def func2():
    print(&#39;in func2&#39;)

def func3():
    print(&#39;in func3&#39;)

def func4():
    print(&#39;in func4&#39;)

import sys

func_lst = [f&#39;func{i}&#39; for i in range(1,5)]
    # print(func_lst)
for func in func_lst:
    getattr(sys.modules[__name__],func)()
</code></pre>
<p><strong>对其他模块的反射</strong></p>
<pre><code><code>#一个模块中的代码
def test():
    print(&#39;from the test&#39;)

# 另一个模块中的代码
import module_test as obj

#obj.test()

print(hasattr(obj,&#39;test&#39;))

getattr(obj,&#39;test&#39;)()
</code></pre>
<p>反射的应用：</p>
<p>了解了反射的四个函数。那么反射到底有什么用呢？它的应用场景是什么呢？</p>
<p>现在让我们打开浏览器，访问一个网站，你单击登录就跳转到登录界面，你单击注册就跳转到注册界面，等等，其实你单击的其实是一个个的链接，每一个链接都会有一个函数或者方法来处理</p>
<pre><code><code>class User:

    user_list = [(&#39;login&#39;,&#39;登录&#39;),(&#39;register&#39;,&#39;注册&#39;),(&#39;save&#39;, &#39;存储&#39;)]

    def login(self):
        print(&#39;欢迎来到登录页面&#39;)

    def register(self):
        print(&#39;欢迎来到注册页面&#39;)

    def save(self):
        print(&#39;欢迎来到存储页面&#39;)


while 1:
    choose = input(&#39;请输入序号: \n1: 登录\n2: 注册\n3: 存储\n&#39;).strip()  # 1
    obj = User()
    getattr(obj, obj.user_list[int(choose)-1][0])()  # getattr(obj,&#39;login&#39;)
</code></pre>
<h1 id="第十二章-函数-vs-方法">第十二章 函数 vs 方法</h1>
<h2 id="通过打印函数方法名确定了解">1.通过打印函数(方法)名确定(了解)</h2>
<pre><code><code>def func():
    pass

class A:
    def func(selfs):
        pass


print(func)
print(A.func)#通过类名调用的类中的实例方法叫函数
&lt;function func at 0x00000252B19DC2F0&gt;
&lt;function A.func at 0x00000252B1B997B8&gt;
obj= A()
print(obj.func)#通过对象调用的类中的实例方法叫方法.
</code></pre>
<h4 id="通过types模块验证">2 通过types模块验证</h4>
<pre><code><code>from types import FunctionType
from types import MethodType

def func():
    pass

class A:
    def func(self):
        pass

obj = A()

print(isinstance(func,FunctionType))  # True
print(isinstance(A.func,FunctionType))  # True
print(isinstance(obj.func,FunctionType))  # False
print(isinstance(obj.func,MethodType))  # True
</code></pre>
<pre><code><code>总结:
python 中一切皆对象, 类在某种意义上也是一个对象,python中自己定义的类,
以及大部分内置类,都是由type元类(构建类)实例化得来的.
python 中一切皆对象, 函数在某种意义上也是一个对象,函数这个对象是从FunctionType这个类实例化出来的.
python 中一切皆对象, 方法在某种意义上也是一个对象,方法这个对象是从MethodType这个类实例化出来的.
</code></pre>
<h4 id="静态方法是函数">3 静态方法是函数</h4>
<h4 id="函数与方法的区别">4 函数与方法的区别</h4>
<p>那么，函数和方法除了上述的不同之处，我们还总结了一下几点区别。</p>
<p><strong>（1）函数的是显式传参的。</strong></p>
<p>（2）函数则跟对象无关。</p>
<p><strong>（3）方法中的数据则是隐形传参.</strong></p>
<p>（4）方法可以操作类内部的数据。</p>
<p>（5）方法跟对象是关联的。如我们在用strip()方法是，是不是都是要通过str对象调用，比如我们有字符串s,然后s.strip()这样调用。是的，strip()方法属于str对象。</p>
<p>我们或许在日常中会口语化称呼函数和方法时不严谨，但是我们心中要知道二者之间的区别。</p>
<p>在其他语言中，如Java中只有方法，C中只有函数，C++么，则取决于是否在类中。</p>
<h1 id="第十三章-双下方法">第十三章 双下方法</h1>
<p>定义：双下方法是特殊方法</p>
<p>双下方法主要是python源码程序员使用的，</p>
<p>我们在开发中尽量不要使用双下方法，但是深入研究双下方法，更有益于我们阅读源码。</p>
<p>调用：不同的双下方法有不同的触发方式，就好比盗墓时触发的机关一样，不知不觉就触发了双下方法，例如：__init_</p>
<h2 id="len">1. len</h2>
<pre><code><code>class  B:
    def __init__(self,name,age):
        self.name = name

    def __len__(self):
        print(self.__dict__)
        return  len(self.__dict__) #必须要加

b = B(&quot;zbb&quot;,28)

print(len(b)) #len()触发调用
</code></pre>
<h2 id="hash">2.hash</h2>
<pre><code><code>class A:

    pass

obj = A()

print(hash(obj))
print(hash(&#39;fdsaf&#39;)) # hash()触发调用
</code></pre>
<h2 id="str重点">3.str重点</h2>
<p>如果一个类中定义了__str__方法，那么在打印 对象 时，默认输出该方法的返回值。</p>
<pre><code><code>class A:

    def __init__(self,name,age):
        self.name = name
        self.age =age

    def __str__(self):
        print(666)
        return f&#39;姓名: {self.name} 年龄: {self.age}&#39;

a = A(&quot;zbb&quot;,18)
print(f&#39;{a.name},{a.age}&#39;) #打印对象名触发__str__方法
print(str(a)) #直接str转化也可以触发.
</code></pre>
<h2 id="repr">4.repr</h2>
<p>如果一个类中定义了__repr__方法，那么在repr(对象) 时，默认输出该方法的返回值。</p>
<pre><code><code>print(&#39;我叫%s&#39; % (&#39;zbb&#39;))
print(&#39;我叫%r&#39; % (&#39;zbb&#39;)) #保留括号里的原来的样子
print(repr(&#39;fdsaf&#39;))
# 我叫zbb
# 我叫&#39;zbb&#39;
# &#39;fdsaf&#39;

</code></pre>
<pre><code><code>class A:

    def __init__(self,name,age):
        self.name = name
        self.age =age

    def __repr__(self):
        print(666)
        return f&#39;姓名: {self.name} 年龄: {self.age}&#39;

a = A(&#39;zbb&#39;,18)

# print(a)
print(repr(a)) #print(repr(对象名))  触发   
</code></pre>
<h2 id="call重点">5.call重点</h2>
<pre><code><code>class Foo:

    def __init__(self):
        pass

    def __call__(self, *args, **kwargs):
        print(&#39;__call__&#39;)

obj = Foo()
obj() # 对象名()   或者 类名()()  触发
# Foo()()
</code></pre>
<h2 id="eq">6.eq</h2>
<pre><code><code>class A:
    def __init__(self):
        self.a = 1
        self.b = 2

    def __eq__(self,obj):
        # if  self.a == obj.a and self.b == obj.b:
        #     return True
        return True
x = A()
y = A()
print(x == y) # 对象名 == 对象名    会触发
节省内存
</code></pre>
<h2 id="del">7.del</h2>
<pre><code><code>class A:

    def __del__(self):
        print(666)

obj = A()
del obj
# del 变量名 或者 类 或者 方法名时会执行     
#不需要去程序员去关心，垃圾处理机制帮助处理
</code></pre>
<h2 id="new-重点">8.new 重点</h2>
<pre><code><code>class A:

    def __init__(self):

        self.x = 1
        print(&#39;in init function&#39;)

    def __new__(cls, *args, **kwargs):
        print(&#39;in new function&#39;)
        return object.__new__(A)  # object 342534

a = A()
# 1. 先触发 object的__new__方法,此方法在内存中开辟一个对象空间.
# 2. 执行__init__方法,给对象封装属性.
</code></pre>
<pre><code><code># python中的设计模式: 单例模式

# 一个类只允许实例化一个对象.
class A:

    pass
obj = A()
print(obj)
obj1 = A()
print(obj1)
obj2 = A()
print(obj2)  #地址都不同
</code></pre>
<p><strong>手写单例模式</strong></p>
<pre><code><code>方便对实例个数的控制并节约系统资源
</code></pre>
<pre><code><code>class A:
    __msg = None  # 用来记录对象信息

    def __init__(self,name):
        self.name = name

    def __new__(cls, *args, **kwargs):
        if not cls.__msg:  # 当 __msg 为 None 时，证明是第一次创建对象空间
            # cls.__msg = super().__new__(cls)  # 调用父类的__new__方法。 记得参数为 cls(类本身)
            cls.__msg = object.__new__(cls)
        return cls.__msg  # 将对象空间返回




a = A(&quot;zbb&quot;)
a1 = A(&quot;zxy&quot;)
print(a.name)
print(a1.name)  # 两个地址相同


</code></pre>
<h2 id="item">9.item</h2>
<pre><code><code># __item__系列
# __getitem__  __setitem__  __delitem__  对对象做类似于字典的(增删改查)触发__item__系列
# __delattr__ del obj.属性  就会触发此方法
class Foo:
    def __init__(self,name):
        self.name=name

    def __getitem__(self, item):
        print(self.__dict__[item])

    def __setitem__(self, key, value):
        self.__dict__[key]=value
    def __delitem__(self, key):
        print(&#39;del obj[key]时,我执行&#39;)
        self.__dict__.pop(key)
    def __delattr__(self, item):
        print(&#39;del obj.key时,我执行&#39;)
        self.__dict__.pop(item)

f1=Foo(&#39;sb&#39;)
f1[&#39;age&#39;]=18
f1[&#39;age1&#39;]=19
del f1.age1
del f1[&#39;age&#39;]
f1[&#39;name&#39;]=&#39;alex&#39;
print(f1.__dict__)
</code></pre>
<h2 id="enter-exit">10.enter exit</h2>
<p>上下文管理</p>
<pre><code><code># 实例化对象的第二种方式: 必须基于 __enter__ 以及 __exit__这个两个方法.
class A:

    def __init__(self, text):
        self.text = text

    def __enter__(self):  # 开启上下文管理器对象时触发此方法
        self.text = self.text + &#39;您来啦&#39;  # 第一步
        print(11111)
        return self  # 必须!!!将实例化的对象返回f1

    def __exit__(self, exc_type, exc_val, exc_tb):  # 执行完上下文管理器对象f1时触发此方法
        print(333)  # 第三步
        self.text = self.text + &#39;,这就走啦&#39;


with A(&#39;大爷&#39;) as f1:
    print(2222)
    print(f1.text)  # 第二步
print(f1.text)  # 第四步
</code></pre>
<h2 id="iter">11.iter</h2>
<pre><code><code>class A:

    def __init__(self,name):
        self.name = name

    def __iter__(self):
        for i in range(10):
            yield i


obj = A(&#39;zbb&#39;)  # obj 一个可迭代对象
# print(&#39;__iter__&#39; in dir(obj))
for i in obj:
    print(i)
</code></pre>
<pre><code><code>class A:

    def __init__(self,name):
        self.name = name

    def __iter__(self):
        for i in range(10):
            yield i

obj = A(&#39;zbb&#39;)  # obj 一个可迭代对象

o = iter(obj)
print(next(o))
print(next(o))
print(next(o))
</code></pre>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>