<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Python语法速查： 1. 数据类型与内置函数' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Python语法速查： 1. 数据类型与内置函数</center></div><div class='banquan'>原文出处:本文由博客园博主初级电路与软件研究提供。<br/>
原文连接:https://www.cnblogs.com/initcircuit/p/11488026.html</div><br>
    <style><!--
td.subtitle { 
  background-color:#FBFBFE;
}

td.name {
  font-family: 'Consolas';
}

td.name span{
  font-size: 13px;
  font-style: italic;
  
}
td.name p {
  line-height: 2ex;
}

td.example {
  font-family: 'Consolas';
  color: #606060;
  font-size: 12px;
}

td.example p {  
  line-height: 2ex;
}

td.example p span {
  color: #B0B0B0;
  font-size: 12px;
}
td.example a.advc {
  color: #606060;
}
a.advc {  
  border-bottom:1px solid gray;
  text-decoration:none;
}


h2.dscp span {
  font-style: italic;
}
.codebox {
        display:table-cell;
        width:800px;
        padding-left:20px;
        padding-right:20px;
}
.codebox span {
  color: #909090;
}
a.return {
    color: #BBB;
    font-size:0.8em;
}
--></style>
<p><a class="return" href="https://www.cnblogs.com/initcircuit/p/11849378.html">返回目录</a></p>
<p>&nbsp;</p>
<h2 id="h_title1">&nbsp;<span style="font-family: 'Microsoft YaHei';">（1）常用内置数据类型</span></h2>
<table id="index01" style="width: 100%;" dir="ltr" border="1" frame="border" cellspacing="0" cellpadding="0" align="left"><colgroup> <col width="100" align="center" /> <col width="160" /> </colgroup>
<thead>
<tr><th style="text-align: center;">分类</th><th style="text-align: center;">类型名称</th><th style="text-align: center;">描述</th></tr>
</thead>
<tbody>
<tr>
<td rowspan="4" align="center">数字</td>
<td>int</td>
<td>整数</td>
</tr>
<tr>
<td>float</td>
<td>浮点数</td>
</tr>
<tr>
<td>complex</td>
<td>复数</td>
</tr>
<tr>
<td>bool</td>
<td>布尔值</td>
</tr>
<tr>
<td rowspan="6" align="center">序列</td>
<td>str</td>
<td>字符串（不可变序列）</td>
</tr>
<tr>
<td>list</td>
<td>列表</td>
</tr>
<tr>
<td>tuple</td>
<td>元组（不可变序列）</td>
</tr>
<tr>
<td>range</td>
<td>整数范围（不可变序列）</td>
</tr>
<tr>
<td>bytes</td>
<td>字节数组（不可变序列）</td>
</tr>
<tr>
<td>bytearray</td>
<td>可变字节数组</td>
</tr>
<tr>
<td align="center">映射</td>
<td>dict</td>
<td>字典</td>
</tr>
<tr>
<td rowspan="2" align="center">集合</td>
<td>set</td>
<td>可变集合</td>
</tr>
<tr>
<td>frozenset</td>
<td>不可变集合</td>
</tr>
<tr>
<td align="center">None</td>
<td>NoneType</td>
<td>空对象，它没有任何属性</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 id="h_title2">&nbsp;<span style="font-family: 'Microsoft YaHei';"> （2）类型检查常用方法 </span></h2>
<table id="index01" style="width: 100%;" dir="ltr" border="1" frame="border" cellspacing="0" cellpadding="0" align="left"><colgroup> <col width="190" /> <col width="100" /> <col width="220" /> </colgroup>
<thead>
<tr><th style="text-align: center;">用法</th><th style="text-align: center;">类型</th><th style="text-align: center;">描述</th><th style="text-align: center;">举例</th></tr>
</thead>
<tbody>
<tr>
<td style="font-family: 'Consolas';">id(<span style="font-size: 13px;">实例</span>)</td>
<td align="center">内置函数</td>
<td>返回一个对象的身份（整数）</td>
<td class="example">
<p>id(a)</p>
</td>
</tr>
<tr>
<td style="font-family: 'Consolas';">type(<span style="font-size: 13px;">实例</span>)</td>
<td align="center">内置函数</td>
<td>返回一个对象实例的类型</td>
<td class="example">type(a)</td>
</tr>
<tr>
<td style="font-family: 'Consolas';">is</td>
<td align="center">运算符</td>
<td>比较2个对象是否同一身份</td>
<td class="example" style="font-family: 'Consolas';">
<p>a is b</p>
<p>type(a) is str</p>
<p>type(a) is type(b)&nbsp;&nbsp; <span># a与b是否同一类型</span></p>
</td>
</tr>
<tr>
<td style="font-family: 'Consolas';">isinstance(<span style="font-size: 13px;">实例, 类名</span>)</td>
<td align="center">内置函数</td>
<td>入参对象是否是入参类的实例</td>
<td class="example">
<p>isinstance(s, list) <span># s是否为列表</span></p>
<p>isinstance(f, Foo) &nbsp;<span># f是否为Foo类的实例</span></p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 id="h_title3">&nbsp;<span style="font-family: 'Microsoft YaHei';"> （3）常用内置函数 </span></h2>
<table id="index03" style="width: 100%;" dir="ltr" border="1" frame="border" cellspacing="0" cellpadding="0" align="left"><colgroup> <col width="138" /> <col width="250" /> <col width="230" /> </colgroup>
<thead>
<tr><th style="text-align: center;">名称</th><th style="text-align: center;">简述</th><th style="text-align: center;">用法</th><th style="text-align: center;">举例或说明</th></tr>
</thead>
<tbody><!----- 数学运算分类 ------------------------------------------>
<tr>
<td class="subtitle" colspan="4"><strong>数学运算</strong></td>
</tr>
<tr>
<td class="name">abs()</td>
<td>返回一个数的绝对值</td>
<td class="name">abs(<span>x</span>)</td>
<td class="example">abs(a)</td>
</tr>
<tr>
<td class="name">pow()</td>
<td>x的y次方运算，将结果对z取模</td>
<td class="name">pow(<span>x, y[,z]</span>)</td>
<td class="example">
<p>pow(2,3,3) <span># 结果为2</span></p>
</td>
</tr>
<tr>
<td class="name">round()</td>
<td>将x按10的负n次取四舍五入</td>
<td class="name">round(<span>x[, n=0]</span>)</td>
<td class="example"><a id="t_round" class="advc" style="text-decoration: none;" href="#h_round"> 舍入规则见下详述 </a></td>
</tr>
<tr>
<td class="name">divmod()</td>
<td>将a除以b的商和余数作为元组返回</td>
<td class="name">divmod(<span>a, b</span>)</td>
<td class="example">
<p>divmod(10,3) <span># 结果为(3,1)</span></p>
</td>
</tr>
<!----- 内置数据类型实例生成 ------------------------------------------>
<tr>
<td class="subtitle" colspan="4"><strong>内置数据类型实例生成</strong></td>
</tr>
<tr>
<td class="name">int()</td>
<td>根据入参数字或字符串，生成整数实例</td>
<td class="name">int(<span>x[, base=10]</span>)</td>
<td class="example">base默认为10， <a id="t_int" class="advc" style="text-decoration: none;" href="#h_int">详见下例</a></td>
</tr>
<tr>
<td class="name">float()</td>
<td>根据入参数字或字符串，生成浮点数实例</td>
<td class="name">float(<span>x</span>)</td>
<td class="example">
<p>float(3) <span># 结果为3.0</span></p>
</td>
</tr>
<tr>
<td class="name">complex()</td>
<td>生成复数实例</td>
<td class="name">complex(<span>r[, i]</span>)</td>
<td class="example">较少用到</td>
</tr>
<tr>
<td class="name">bool()</td>
<td>生成布尔值实例</td>
<td class="name">bool(<span>[x]</span>)</td>
<td class="example">不带入参时默认返回False</td>
</tr>
<tr>
<td class="name">list()</td>
<td>生成列表实例</td>
<td class="name">list(<span>[iter]</span>)</td>
<td class="example">iter须是可迭代对象</td>
</tr>
<tr>
<td class="name">dict()</td>
<td>生成字典实例</td>
<td class="name">dict(<span>[m]</span>)</td>
<td class="example"><a id="t_dict" class="advc" style="text-decoration: none;" href="#h_dict">详见下述</a></td>
</tr>
<tr>
<td class="name">tuple()</td>
<td>生成元组实例</td>
<td class="name">tuple(<span>[iter]</span>)</td>
<td class="example">iter须是可迭代对象</td>
</tr>
<tr>
<td class="name">str()</td>
<td>生成字符串实例</td>
<td class="name">str(<span>[object]</span>)</td>
<td class="example">入参object的__str__方法</td>
</tr>
<tr>
<td class="name">range()</td>
<td>创建range实例</td>
<td class="name">
<p>range(<span>stop</span>)</p>
<p>range(<span>start, stop [,step]</span>)</p>
</td>
<td class="example">range对象可以用迭代、也可用切片访问</td>
</tr>
<tr>
<td class="name">set()</td>
<td>生成集合实例</td>
<td class="name">set(<span>[iter]</span>)</td>
<td class="example">iter须是可迭代对象</td>
</tr>
<tr>
<td class="name">frozenset()</td>
<td>生成不可变集合实例</td>
<td class="name">frozenset(<span>[iter]</span>)</td>
<td class="example">iter须是可迭代对象</td>
</tr>
<tr>
<td class="name">slice()</td>
<td>生成切片对象</td>
<td class="name">
<p>slice(<span>stop</span>)</p>
<p>slice(<span>start, stop [,step]</span>)</p>
</td>
<td class="example">
<p>较少直接使用</p>
</td>
</tr>
<tr>
<td class="name">bytes()</td>
<td>生成不可变字节数组实例</td>
<td class="name">bytes(<span>[source [,encoding [,errors]]]</span>)</td>
<td class="example"><a id="t_bytes" class="advc" style="text-decoration: none;" href="#h_bytes">详见下述</a></td>
</tr>
<tr>
<td class="name">bytearray()</td>
<td>生成可变字节数组实例</td>
<td class="name">bytearray(<span>[source [,encoding [,errors]]]</span>)</td>
<td class="example">用法同上，内容可变</td>
</tr>
<tr>
<td class="name">memoryview()</td>
<td>生成memoryview实例</td>
<td class="name">memoryview(<span>obj</span>)</td>
<td class="example">较少用到</td>
</tr>
<tr>
<td class="name">object()</td>
<td>生成一个基类实例</td>
<td class="name">object()</td>
<td class="example">较少用到</td>
</tr>
<!----- 编码与解码 ------------------------------------------>
<tr>
<td class="subtitle" colspan="4"><strong>编码与解码</strong></td>
</tr>
<tr>
<td class="name">hex()</td>
<td>将数值x用16进制字符串表示</td>
<td class="name">hex(<span>x</span>)</td>
<td class="example">
<p>hex(16) <span># 结果为'0x10'</span></p>
</td>
</tr>
<tr>
<td class="name">oct()</td>
<td>将数值x用8进制字符串表示</td>
<td class="name">oct(<span>x</span>)</td>
<td class="example">
<p>oct(16) <span># 结果为'0o20'</span></p>
</td>
</tr>
<tr>
<td class="name">bin()</td>
<td>将数值x用2进制字符串表示</td>
<td class="name">bin(<span>x</span>)</td>
<td class="example">
<p>bin(8) <span># 结果为'0b1000'</span></p>
</td>
</tr>
<tr>
<td class="name">ord()</td>
<td>将单字符转换成utf-8数值</td>
<td class="name">ord(<span>c</span>)</td>
<td class="example">
<p>ord('a') <span># 结果为97</span></p>
<p>ord('数') <span># 结果为25968</span></p>
</td>
</tr>
<tr>
<td class="name">chr()</td>
<td>将数值x转换成单字符字符串</td>
<td class="name">chr(<span>x</span>)</td>
<td class="example">
<p>chr(97) <span># 结果为'a' </span></p>
<p>chr(25968) <span># 结果为'数' </span></p>
</td>
</tr>
<tr>
<td class="name">ascii()</td>
<td>像repr()那样显示对象，非ASCII字符显示为转义序列</td>
<td class="name">ascii(<span>object</span>)</td>
<td class="example">较少用到</td>
</tr>
<!----- 序列操作 ------------------------------------------>
<tr>
<td class="subtitle" colspan="4"><strong>序列操作</strong></td>
</tr>
<tr>
<td class="name">len()</td>
<td>返回s中包含的项数</td>
<td class="name">len(<span>s</span>)</td>
<td class="example">s可以是：列表、元组、字符串、集合、字典</td>
</tr>
<tr>
<td class="name">min()</td>
<td>如果只有1个参数s，返回s中各项的最小值。如果有多个参数，返回各个参数中的最小值。</td>
<td class="name">min(<span>s[, args, ...]</span>)</td>
<td class="example">
<p>s可以是可迭代对象</p>
<p>min([1,3,5]) <span># 结果为1 </span></p>
<p>min(1,3,5,7) <span># 结果为1 </span></p>
</td>
</tr>
<tr>
<td class="name">max()</td>
<td>如果只有1个参数s，返回s中各项的最大值。如果有多个参数，返回各个参数中的最大值。</td>
<td class="name">max(<span>s[, args, ...]</span>)</td>
<td class="example">
<p>s可以是可迭代对象</p>
<p>min([1,3,5]) <span># 结果为5 </span></p>
<p>min(1,3,5,7) <span># 结果为7 </span></p>
</td>
</tr>
<tr>
<td class="name">sum()</td>
<td>计算可迭代对象iter中所有项的和，initial为累加初始值，默认为0。只能用于数值计算。</td>
<td class="name">sum(<span>iter[ ,initial]</span>)</td>
<td class="example">
<p>sum([1,2,3]) <span># 结果为6 </span></p>
<p>sum([1,2,3], 10) <span># 结果为16 </span></p>
</td>
</tr>
<!----- 迭代操作 ------------------------------------------>
<tr>
<td class="subtitle" colspan="4"><strong>迭代操作</strong></td>
</tr>
<tr>
<td class="name">all()</td>
<td>若可迭代对象iterable中的所有值都为True，则返回True。</td>
<td class="name">all(<span>iter</span>)</td>
<td class="example">
<p>all([0,1,2,3]) <span># 结果为False </span></p>
</td>
</tr>
<tr>
<td class="name">any()</td>
<td>若可迭代对象iterable中的任意值为True，则返回True。</td>
<td class="name">any(<span>iter</span>)</td>
<td class="example">
<p>any([0,1,2,3]) <span># 结果为True </span></p>
</td>
</tr>
<tr>
<td class="name">enumerate()</td>
<td>根据入参迭代器，产生一个新迭代器，其中每个元素为一个元组：内含一个计数值和原迭代出的值。</td>
<td class="name">enumerate(<span>iter[ ,start=0]</span>)</td>
<td class="example">
<p>for i,x in enumerate(['a','b'])</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;pass</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span># 结果迭代出(0,'a'), (1,'b') </span></p>
</td>
</tr>
<tr>
<td class="name">zip()</td>
<td>产生一个新迭代器，第n个元素为一个(s1[n], s2[n], ...)的元组，其长度为最短的一个迭代器长度。</td>
<td class="name">zip(<span>[s1 [, s2 [, ...]]]</span>)</td>
<td class="example">
<p>a = [1,2,3]</p>
<p>b = ['x','y']</p>
<p>for t in zip(a, b)</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;pass</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span># 迭代结果为(1,'x'), (2,'y') </span></p>
</td>
</tr>
<tr>
<td class="name">sorted()</td>
<td>根据入参迭代器的内容排序，创建有序列表</td>
<td class="name">sorted(<span>iter, *, key=None, reverse=False</span>)</td>
<td class="example"><a id="t_sorted" class="advc" style="text-decoration: none;" href="#h_sorted">详见下述</a></td>
</tr>
<tr>
<td class="name">reversed()</td>
<td>产生一个迭代器，将入参序列的所有元素位置颠倒（注意：跟sorted()完全不同）</td>
<td class="name">reversed(<span>seq</span>)</td>
<td class="example">
<p>for x in reversed([1,2,'a']):</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;pass</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span># 迭代结果为 'a', 2, 1 </span></p>
</td>
</tr>
<tr>
<td class="name">filter()</td>
<td>产生一个迭代器，其内容是对入参iter中的每个元素使用func函数进行过滤，只有func返回True的才被加入新迭代器。</td>
<td class="name">filter(<span>func, iter</span>)</td>
<td class="example">
<p>a = [1,2,3,4,5,6,7,8]</p>
<p>filter(lambda x:x%2==1, a)</p>
<p><span># 迭代器中内容为 1,3,5,7 </span></p>
</td>
</tr>
<tr>
<td class="name">map()</td>
<td>产生一个迭代器，其每一项是将函数func应用到iter中的每一项返回的结果。若入参有多个iter迭代器，则相应的函数func应有多个入参。</td>
<td class="name">map(<span>func, iter, ...</span>)</td>
<td class="example">
<p>map(lambda x:x*2, [1,3,5,7])</p>
<p><span># 迭代器中内容为 2,6,10,14 </span></p>
</td>
</tr>
<tr>
<td class="name">iter()</td>
<td>返回一个可生成object中各项的迭代器。</td>
<td class="name">iter(<span>object[ ,sentinel]</span>)</td>
<td class="example">
<p>较少直接使用</p>
</td>
</tr>
<tr>
<td class="name">next()</td>
<td>返回迭代器iter中的下一项。</td>
<td class="name">next(<span>iter[ ,default]</span>)</td>
<td class="example">
<p>较少直接使用</p>
</td>
</tr>
<!----- 对象实例操作 ------------------------------------------>
<tr>
<td class="subtitle" colspan="4"><strong>对象实例操作</strong></td>
</tr>
<tr>
<td class="name">id()</td>
<td>返回object的唯一整数标识符（这是一个内存位置）。</td>
<td class="name">id(<span>object</span>)</td>
<td class="example">
<p>结果为一个整数，较少直接使用</p>
</td>
</tr>
<tr>
<td class="name">type()</td>
<td>当单参数调用时，返回入参object的类型。当三参数调用时，创建一个新type对象（一般用于元类）。</td>
<td class="name">
<p>type(<span>object</span>)</p>
<p>type(<span>name, bases, dict</span>)</p>
</td>
<td class="example">
<p>type(1) <span># 结果为&lt;class 'int'&gt; </span></p>
<p>type('a') <span># 结果为&lt;class 'str'&gt; </span></p>
</td>
</tr>
<tr>
<td class="name">isinstance()</td>
<td>如果object是clsinfo类的一个实例，则返回True。clsinfo可以是一个含多个类的元组。</td>
<td class="name">isinstance(<span>object, clsinfo</span>)</td>
<td class="example">
<p><span># 设有一个名为Foo的自定义类</span></p>
<p>f = Foo()</p>
<p>isinstance(f, Foo) <span># True </span></p>
<p>isinstance(f, (Foo,list)) <span># True </span></p>
<p>isinstance([1,2], (Foo,list)) <span># True</span></p>
<p>isinstance(f, (list,tuple) <span># False</span></p>
</td>
</tr>
<tr>
<td class="name">repr()</td>
<td>返回object的字符串表示形式。</td>
<td class="name">repr(<span>object</span>)</td>
<td class="example">一般在类内部的__repr__()方法会定义本对象的字符串表示形式。</td>
</tr>
<tr>
<td class="name">dir()</td>
<td>返回object对象的属性名（含方法名）列表，若object是一个模块，则返回其内部定义的符号列表。</td>
<td class="name">dir(<span>object</span>)</td>
<td class="example">如果类内部定义了__dir__属性，则返回此值。</td>
</tr>
<tr>
<td class="name">hasattr()</td>
<td>若name是object的属性名，则返回True</td>
<td class="name">hasattr(<span>object, name</span>)</td>
<td class="example">
<p>入参name是一个字符串</p>
</td>
</tr>
<tr>
<td class="name">getattr()</td>
<td>返回对象的name属性的值，若无此属性，则default是可选的返回值，否则引起AttributeError。</td>
<td class="name">getattr(<span>object, name [,default]</span>)</td>
<td class="example">
<p>a = getattr(obj, 'p1')</p>
<p><span># 效果同 a = obj.p1 </span></p>
</td>
</tr>
<tr>
<td class="name">setattr()</td>
<td>设置对象的属性</td>
<td class="name">setattr(<span>object, name, value</span>)</td>
<td class="example">
<p>setattr(obj, 'p1', a)</p>
<p><span># 效果同 obj.p1 = a </span></p>
</td>
</tr>
<tr>
<td class="name">delattr()</td>
<td>删除对象的属性</td>
<td class="name">delattr(<span>object, name</span>)</td>
<td class="example">
<p>delattr(obj, 'p1')</p>
<p><span># 效果同 del obj.p1 </span></p>
</td>
</tr>
<tr>
<td class="name">hash()</td>
<td>返回对象的整数散列值。一般可变对象不会定义散列值，除非类内部定义了__hash__()方法。</td>
<td class="name">hash()</td>
<td class="example">
<p>hash('abc') <span># 结果为526986374 </span></p>
<p>hash(3.14) <span>&nbsp;# 结果为1846836513 </span></p>
</td>
</tr>
<tr>
<td class="name">callable()</td>
<td>检查一个对象是否是可调用的。但有时即便返回 True，object 仍然可能调用失败。</td>
<td class="name">callable(<span>object</span>)</td>
<td class="example">对于函数、方法、lamdba表达式、类、实现了__call__()方法的类实例，它都返回True。</td>
</tr>
<!----- 类操作 ------------------------------------------>
<tr>
<td class="subtitle" colspan="4"><strong>类操作</strong></td>
</tr>
<tr>
<td class="name">staticmethod()</td>
<td>创建在类中使用的静态方法。</td>
<td class="name">staticmethod(<span>func</span>)</td>
<td class="example">一般通过@staticmethod装饰器隐式调用该函数</td>
</tr>
<tr>
<td class="name">classmethod()</td>
<td>创建在类方法。</td>
<td class="name">classmethod(<span>func</span>)</td>
<td class="example">一般通过@classmethod装饰器隐式调用该函数</td>
</tr>
<tr>
<td class="name">issubclass()</td>
<td>如果class是clsinfo的子类，或class是基于抽象基类clsinfo注册的，则返回True。clsinfo可以是一个含多个类的元组。</td>
<td class="name">issubclass(<span>class, clsinfo</span>)</td>
<td class="example">
<p>issubclass(Foo, BaseFoo) <span># 结果为 True</span></p>
<p>issubclass(Foo, (BaseFoo,list) <span># 结果为 True</span></p>
</td>
</tr>
<tr>
<td class="name">super()</td>
<td>
<p>返回一个代理对象，提供可以调用基类中的方法的手段。type是当前子类名，object一般是self。</p>
<p>在Python3中，在子类方法中可以省略type和object参数，直接简写成：super()</p>
</td>
<td class="name">super(<span>type [,object]</span>)</td>
<td class="example">
<p>class B(A):</p>
<p>&nbsp;&nbsp;def foo(self):</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span># 调用基类A的foo方法</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;super(B,self).foo()</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span># 在Python3中可简写成：</span></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<span># super().foo()</span></p>
</td>
</tr>
<tr>
<td class="name">property()</td>
<td>创建一个虚拟属性。fget, fset, fdel分别为自定义的属性读取、设置、删除方法，doc为文档字符串。</td>
<td class="name">property(<span>fget=None, fset=None, fdel=None, doc=None</span>)</td>
<td class="example">
<p>class C:</p>
<p>&nbsp;&nbsp;def __init__(self):</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;self._x = 'c'</p>
<p>&nbsp;&nbsp;def gx(self):</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;return self._x</p>
<p>&nbsp;&nbsp;x=property(fget=gx, doc='a')</p>
<p><span>&nbsp;&nbsp;# 定义了一个只读的属性x </span></p>
</td>
</tr>
<!----- 域操作 ------------------------------------------>
<tr>
<td class="subtitle" colspan="4"><strong>域操作</strong></td>
</tr>
<tr>
<td class="name">globals()</td>
<td>返回代表当前全局作用域的所有符号的字典。</td>
<td class="name">globals()</td>
<td class="example">
<p>globals()</p>
</td>
</tr>
<tr>
<td class="name">locals()</td>
<td>返回代表当前局部作用域的所有符号的字典。</td>
<td class="name">locals()</td>
<td class="example">
<p>locals()</p>
</td>
</tr>
<tr>
<td class="name">vars()</td>
<td>返回object的所有属性和属性值的字典对象，如果没有入参，则相当于调用locals()</td>
<td class="name">vars(<span>[object]</span>)</td>
<td class="example">
<p>vars(obj)</p>
</td>
</tr>
<!-----  ------------------------------------------>
<tr>
<td class="subtitle" colspan="4"><strong>输入输出与文件操作</strong></td>
</tr>
<tr>
<td class="name">input()</td>
<td>显示prompt提示信息，并读取一行输入，将读入内容不作任何修改作为字符串返回。（Python3中取消了原raw_input()函数）</td>
<td class="name">input(<span>[prompt]</span>)</td>
<td class="example">
<p>&gt;&gt;&gt; input('pls ipt:')</p>
<p><span>pls ipt:</span>123</p>
<p><span># 返回结果为：'123'</span></p>
<p>&nbsp;</p>
<p><a id="t_rawinput" class="advc" style="text-decoration: none;" href="#h_rawinput">旧版raw_input用法</a></p>
</td>
</tr>
<tr>
<td class="name">print()</td>
<td>打印一系列值到屏幕上。入参中可设置：多个显示对象之间的分隔符、换行符、输出设备、强制刷新等，一般不用修改。</td>
<td class="name">print(<span>*objects, sep=' ', end='\n', file=sys.stdout, flush=False</span>)</td>
<td class="example">
<p>一般用于调试用</p>
</td>
</tr>
<tr>
<td class="name">open()</td>
<td>打开文件并返回一个新文件对象。</td>
<td class="name">open(<span>file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None</span>)</td>
<td class="example">
<p>在文件操作章节详细描述</p>
</td>
</tr>
<!----- 杂项 ------------------------------------------>
<tr>
<td class="subtitle" colspan="4"><strong>杂项</strong></td>
</tr>
<tr>
<td class="name">eval()</td>
<td>计算入参表达式的值并返回结果。expr是一个字符串或代码对象。globals和locals参数可指定操作时的全局和局部命名空间映射对象。</td>
<td class="name">eval(<span>expr, globals=None, locals=None</span>)</td>
<td class="example">
<p>x = 1</p>
<p>y = eval('x+1') <span># 结果为2 </span></p>
<a id="t_eval" class="advc" style="text-decoration: none;" href="#h_eval">更详细说明</a></td>
</tr>
<tr>
<td class="name">exec()</td>
<td>执行Python语句，入参code可以是字符串、文件或代码对象。globals和locals参数可指定操作时的全局和局部命名空间映射对象。</td>
<td class="name">exec(<span>code[, globals[, locals]]</span>)</td>
<td class="example">
<p>x = 1</p>
<p>code = """s = x + 1</p>
<p>print(s)"""</p>
<p>exec(code) <span># 结果为2</span></p>
<p>exec(code, {'x':10}) <span># 结果为11</span></p>
<a id="t_exec" class="advc" style="text-decoration: none;" href="#h_exec">更详细说明</a></td>
</tr>
<tr>
<td class="name">format()</td>
<td>按照format_spec中的格式将value转换为有格式的字符串，该操作调用value.__format__()方法。</td>
<td class="name">format(<span>value[, format_spec]</span>)</td>
<td class="example">
<p>一般在格式化字符串时被隐式调用</p>
</td>
</tr>
<tr>
<td class="name">help()</td>
<td>调用内置的帮助系统。object可以是字符串（表示模块名、类名、函数名、方法名、关键字、文档主题名称），如果是其他类型的对象，则会出现与该对象有关的帮助界面。</td>
<td class="name">help(<span>[object]</span>)</td>
<td class="example">
<p>help('math')</p>
</td>
</tr>
<tr>
<td class="name">compile()</td>
<td>将source对象编译为代码对象，结果可被用于eval()和exec()函数。</td>
<td class="name">compile(<span>source, filename, mode, flags=0, dont_inherit=False, optimize=-1</span>)</td>
<td class="example">
<p>若不是开发框架的话，一般用不到</p>
</td>
</tr>
<tr>
<td class="name">breakpoint()</td>
<td>Python3.7中新增的内置函数，用来设置程序运行时的断点，程序运行到该函数时自动进入调试器。这是个方便函数，可以让你很方便地进入Pdb调试器（不用再显式导入调试模块等）。</td>
<td class="name">breakpoint(<span>*args, **kwargs</span>)</td>
<td class="example">在需要设置断点的地方直接调用breakpoint()即可</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<!-------------------------round()------------------------------>
<h2 id="h_round" class="dscp">● round(x[, n])</h2>
<p><strong>说明：</strong></p>
<p style="text-indent: 2em;">在Python3中，当被舍入数字为5且为第1位小数时，舍入规则如下：若被舍入数字的前一个数为偶数，则朝0方向进行四舍五入；否则远离0，正负数都遵循这个规则。其它位的四舍五入不适用此规则，依旧按照普通数学规则进行。</p>
<p><strong>举例：</strong></p>
<div class="codebox">
<div class="cnblogs_code">
<pre><code>&gt;&gt;&gt; round(2.5) <span>&nbsp;# 结果为2</span>
&gt;&gt;&gt; round(-2.5) <span># 结果为2</span>
&gt;&gt;&gt; round(3.5) <span>&nbsp;# 结果为4</span>
&gt;&gt;&gt; round(-3.5) <span># 结果为4</span></pre>
</div>
</div>
<p><a class="return" href="#t_round">返回索引</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<!---------------------int()---------------------------------->
<h2 id="h_int" class="dscp">● int(x[, base])</h2>
<p><strong>说明：</strong></p>
<p style="text-indent: 2em;">x可以是数字或字符串，base是入参的转换进制基数，可以是2、8、16、16等，转换结果总是10进制整数。</p>
<p><strong>举例：</strong></p>
<div class="codebox">
<div class="cnblogs_code">
<pre><code>&gt;&gt;&gt;  int('100')<span>&nbsp;# 结果为100</span>
&gt;&gt;&gt;  int('100', 10)<span>&nbsp;# 结果为100</span>
&gt;&gt;&gt;  int('100', 16)<span>&nbsp;# 结果为256</span>
&gt;&gt;&gt;  int('100', 2)<span>&nbsp;# 结果为4</span></pre>
</div>
</div>
<p><a class="return" href="#t_int">返回索引</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<!-------------------------dict()------------------------------>
<h2 id="h_dict" class="dscp">● dict([m])</h2>
<p><strong>说明：</strong></p>
<p style="text-indent: 2em;">入参m若是字典，则dict(m)就创建一个m浅复制。若m不是字典，则必须能够产生(key, value)形式的迭代值。也可用关键字创建字典，见下例。</p>
<p><strong>举例：</strong></p>
<div class="codebox">
<div class="cnblogs_code">
<pre><code>&gt;&gt;&gt;  dict('a'=1, 'b'=2)<span>&nbsp;# 结果为{'a':1, 'b':2}</span>
&gt;&gt;&gt;  dict()<span>&nbsp;# 结果为空字典{}</span></pre>
</div>
</div>
<p><a class="return" href="#t_dict">返回索引</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<!-------------------------bytes()------------------------------>
<h2 id="h_bytes" class="dscp">● bytes([source [,encoding [,errors]]])</h2>
<p><strong>说明：</strong></p>
<p style="text-indent: 2em;">生成不变字节数组，入参source为原始输入字符串，入参encoding指定要使用的字符编码方式。</p>
<p><strong>举例：</strong></p>
<div class="codebox">
<div class="cnblogs_code">
<pre><code>&gt;&gt;&gt; x = bytes()  <span>&nbsp;# 结果为空字节数组 b''</span>
&gt;&gt;&gt; x = b''  <span>&nbsp;# 结果同上</span>
&gt;&gt;&gt; x = bytes('abc')  <span>&nbsp;# 结果为 b'abc'</span>
&gt;&gt;&gt; x = bytes('ab数字', 'utf-8') <span>&nbsp;# 结果为 b'ab\xe6\x95\xb0\xe5\xad\x97' </span></pre>
</div>
</div>
<p><a class="return" href="#t_bytes">返回索引</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<!------------------------sorted()------------------------------->
<h2 id="h_sorted" class="dscp">● sorted(iter, *, key=None, reverse=False)</h2>
<p><strong>说明：</strong></p>
<p style="text-indent: 2em;">根据iter迭代器中的各项值的内容进行排序（从小到大），创建有序列表，一般只能对数字或字符串进行排序。key是个单参数函数，可以对元素在被排序前进行预处理，将一些常规来说不能排序的元素预处理成可排序的数字或字符串。reverse是个标志位，用以指出是否逆序（从大到小）排序。（注意：Python3最新版本中已废除了cmp参数）</p>
<p><strong>举例：</strong></p>
<div class="codebox">
<div class="cnblogs_code">
<pre><code>&gt;&gt;&gt;  sorted([1,7,3,5]) <span>&nbsp;# 结果为[1,3,5,7]</span>
&gt;&gt;&gt;  sorted([1,7,3,5], reverse=True) <span>&nbsp;# 结果为[7,5,3,1]</span>
&gt;&gt;&gt;  sorted(['c','b','a'])<span>&nbsp;# 结果为['a','b','c']</span>
&gt;&gt;&gt;  sorted([('b',2),('a',1)], key=lambda x:x[1])<span>&nbsp;# 结果为[('a',1),('b',2)]</span>
&gt;&gt;&gt;  <span># 上例说明：入参列表中的元素为元组，一般不能排序。但这里用lambda生成了一个匿名函数，对元素进行预处理，取出每个元素元组中的数字，然后用这个数字作为排序依据，给sorted()函数进行排序</span></pre>
</div>
</div>
<p><a class="return" href="#t_sorted">返回索引</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<!------------------------raw_input()------------------------------->
<h2 id="h_rawinput" class="dscp">● 旧版raw_input()用法</h2>
<p><strong>说明：</strong></p>
<p style="text-indent: 2em;">在Python3中的input()函数相当于Python2中的raw_input()函数。而在Python2中的input()函数中，用户在输入字符串内容时必须带上引号，否则会报错（非字符串类型则不需要引号）。所以在Python2中，一般尽量使用raw_input()函数。</p>
<p><strong>举例：</strong></p>
<div class="codebox">
<div class="cnblogs_code">
<pre><code>x = input('x:') <span>&nbsp;# 用户必须输入带引号的字符串：'abc'，否则会报错</span>
x = raw_input('x:')  <span>&nbsp;# 用户可以直接输入：abc，系统会自动将其转换为字符串</span></pre>
</div>
</div>
<p><a class="return" href="#t_rawinput">返回索引</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<!------------------------eval()------------------------------->
<h2 id="h_eval" class="dscp">● eval(expr, globals=None, locals=None)</h2>
<p><strong>说明：</strong></p>
<p style="text-indent: 2em;">eval()计算字符串形式的表达式或代码对象expr，并返回计算结果。其中globals和locals参数可指定操作时的全局和局部命名空间，如果省略，就使用当前实际的全局和局部命名空间中的值。</p>
<p><strong>举例：</strong></p>
<div class="codebox">
<div class="cnblogs_code">
<pre><code># 例1：
x = eval(input('Enter an expression:')) <span>&nbsp;# 用户若输入：1+2*3，返回值为7</span>

# 例2：
scope = {'x':2, 'y':3}
eval('x+y', scope)  <span>&nbsp;# 相当于在scope命名空间中运行eval()，结果为5</span></pre>
</div>
</div>
<p><a class="return" href="#t_eval">返回索引</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<!------------------------exec()------------------------------->
<h2 id="h_exec" class="dscp">● exec(code[, globals[, locals]])</h2>
<p><strong>说明：</strong></p>
<p style="text-indent: 2em;">exec在Python2中是一个语句，exec()在Python3中是内置函数，exec()最有用的地方在于可以动态地创建代码字符串。其中globals和locals参数可指定操作时的全局和局部命名空间，如果省略，就使用当前实际的全局和局部命名空间中的值。</p>
<p style="text-indent: 2em;">由于每次执行exec()或eval()时，Python都要编译一次入参字符串，这个比较耗资源。如果某个代码字符串要反复执行多次，最好是先编译代码，然后在后续的调用中使用编译过的code对象。详见后面的例子。</p>
<p><strong>举例：</strong></p>
<div class="codebox">
<div class="cnblogs_code">
<pre><code># 例1：
x = 1
scope = {}
exec('x=2', scope)  <span>&nbsp;# 在命名空间scope中运行赋值语句，所以x仅在scope范围为2，在实际的全局空间中仍为1</span>

# 例2：
s = 'for i in range(100): print(i)'
code = compile(s, '', 'exec')   <span>&nbsp;# 将要执行的字符串代码先进行编译</span>
exec(code)   <span>&nbsp;# 执行刚才已编译过的代码</span></pre>
</div>
</div>
<p><a class="return" href="#t_exec">返回索引</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 id="h_title4">&nbsp;<span style="font-family: 'Microsoft YaHei';">（4）程序结构的数据类型</span></h2>
<p style="text-indent: 2em;">在Python中，函数、类、方法、模块等等都可以当作数据操作的对象，下表为表示程序本身各种元素的类型。</p>
<table id="index01" style="width: 100%;" dir="ltr" border="1" frame="border" cellspacing="0" cellpadding="0" align="left"><colgroup> <col width="100" align="center" /> <col width="260" /> </colgroup>
<thead>
<tr><th style="text-align: center;">分类</th><th style="text-align: center;">类型名称</th><th style="text-align: center;">描述</th></tr>
</thead>
<tbody>
<tr>
<td rowspan="5" align="center">可调用</td>
<td>types.BuiltinFunctionType</td>
<td>内置函数或方法</td>
</tr>
<tr>
<td>types.FunctionType</td>
<td>用于定义的函数（包括lambda匿名函数）</td>
</tr>
<tr>
<td>types.MethodType</td>
<td>类中定义的方法</td>
</tr>
<tr>
<td style="color: #b0b0b0;">type</td>
<td style="color: #b0b0b0;">因为类本身也是可以被调用的，所以这里也列一下。</td>
</tr>
<tr>
<td style="color: #b0b0b0;">object</td>
<td style="color: #b0b0b0;">因为类本身也是可以被调用的，所以这里也列一下。</td>
</tr>
<tr>
<td align="center">模块</td>
<td>types.ModuleType</td>
<td>模块</td>
</tr>
<tr>
<td align="center">类型</td>
<td>type</td>
<td>内置数据类型和类的类型</td>
</tr>
<tr>
<td align="center">根类</td>
<td>object</td>
<td>所有类型和类的祖先</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><a class="return" href="https://www.cnblogs.com/initcircuit/p/11849378.html">返回目录</a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>