<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Python复习 一' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Python复习 一</center></div><div class='banquan'>原文出处:本文由博客园博主Mirror王宇阳提供。<br/>
原文连接:https://www.cnblogs.com/wangyuyang1016/p/11260913.html</div><br>
    <h1 id="python回炉复习-1">Python回炉复习 1</h1>
<h2 id="变量">变量</h2>
<p>Python的变量和C语言的变量书写方式类似；</p>
<h2 id="书写要求">书写要求</h2>
<p>python程序编写结构利用缩进表示，抛弃花括号；</p>
<h2 id="结构">结构</h2>
<h3 id="分支">分支：</h3>
<pre><code><code>if(条件语句1):
    执行语句块
else if(条件语句2):
    执行语句块
else:
    执行语句块</code></pre>
<h3 id="循环">循环：</h3>
<h4 id="while-循环">while 循环</h4>
<pre><code><code>while 循环条件:
    循环语句体</code></pre>
<h4 id="for-循环">for 循环</h4>
<pre><code><code>for 目标 in 表达式：
    循环语句体</code></pre>
<blockquote>
<p>表达式的结果会和目标联成共体</p>
</blockquote>
<ul>
<li>range()函数：</li>
</ul>
<blockquote>
<p>步长函数；</p>
<p>range(x,y,z)</p>
<p>​ x：开始</p>
<p>​ y：结束（y-1）</p>
<p>​ z：步长</p>
</blockquote>
<ul>
<li>break 语句：</li>
</ul>
<blockquote>
<p>跳出当前结构体</p>
</blockquote>
<ul>
<li>continue 语句：</li>
</ul>
<blockquote>
<p>结束以此循环体的运行</p>
</blockquote>
<h2 id="列表">列表</h2>
<h3 id="创建列表">创建列表</h3>
<pre><code><code>&gt;&gt;&gt; num = [1,2,3,4,5] // 列表创建
&gt;&gt;&gt; num               // 列表输出
[1, 2, 3, 4, 5]
&gt;&gt;&gt; num = [&#39;Hello&#39;,&#39;你好&#39;,666]
&gt;&gt;&gt; num // 列表支持各种类型，除数字以外的其他字符都需要用单引号
[&#39;Hello&#39;, &#39;你好&#39;, 666]</code></pre>
<h4 id="append添加元素">append()：添加元素</h4>
<pre><code><code>&gt;&gt;&gt; num.append(6)
&gt;&gt;&gt; num
[1, 2, 3, 4, 5, 6]</code></pre>
<h4 id="extend添加多个元素">extend()：添加多个元素</h4>
<pre><code><code>&gt;&gt;&gt; num.extend([7,8,9])
&gt;&gt;&gt; num
[1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre>
<blockquote>
<p>append()是添加一个单独的元素，就是简单的扩充；</p>
<p>而extend()则是将原有的列表和自己要添加的列表拼接成一个新列表</p>
</blockquote>
<h4 id="insert在列表中插入元素">insert()：在列表中插入元素</h4>
<pre><code><code>&gt;&gt;&gt; num.insert(0,0) // 在0索引位置添加元素0
&gt;&gt;&gt; num
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre>
<h4 id="pop删除列表元素">pop()：删除列表元素</h4>
<ul>
<li>php()：删除列表最后一个元素</li>
<li>php(X)：删除列表中索引为X的元素</li>
<li>pop()会返回被删除的元素内容</li>
</ul>
<pre><code><code>&gt;&gt;&gt; num.pop()
9
&gt;&gt;&gt; num.pop(0)
0
&gt;&gt;&gt; num
[1, 2, 3, 4, 5, 6, 7, 8]</code></pre>
<h4 id="del-语句删除列表">del 语句：删除列表</h4>
<ul>
<li>del [ListName]：删除整个列表（也可以同时删除多个）</li>
<li>del [ListName[X]]：删除索引为X的元素</li>
</ul>
<pre><code><code>&gt;&gt;&gt; num = [1,2,3,4,5,6,7,8]
&gt;&gt;&gt; num
[1, 2, 3, 4, 5, 6, 7, 8]
&gt;&gt;&gt; del num[7]
&gt;&gt;&gt; num
[1, 2, 3, 4, 5, 6, 7]
&gt;&gt;&gt; del num
&gt;&gt;&gt; num
Traceback (most recent call last):
  File &quot;&lt;pyshell#19&gt;&quot;, line 1, in &lt;module&gt;
    num
NameError: name &#39;num&#39; is not defined</code></pre>
<blockquote>
<p>如报错提示：num不存在</p>
</blockquote>
<h4 id="remove删除已知x元素">remove()：删除已知X元素</h4>
<ul>
<li>搜索元素X内容并删除</li>
</ul>
<blockquote>
<p>我们之前的del语句和pop()函数都是依靠列表的索引来删除索引下的元素，remove()则是不靠索引，而是根据元素的具体内容来删除。</p>
</blockquote>
<pre><code><code>&gt;&gt;&gt; num = [&#39;Hello&#39;,&#39;你好&#39;,666]
&gt;&gt;&gt; num
[&#39;Hello&#39;, &#39;你好&#39;, 666]
&gt;&gt;&gt; num.remove(666)
&gt;&gt;&gt; num
[&#39;Hello&#39;, &#39;你好&#39;]
&gt;&gt;&gt; num.remove(&#39;你好&#39;)
&gt;&gt;&gt; num
[&#39;Hello&#39;]</code></pre>
<h3 id="列表分片">列表分片</h3>
<p>将一个列表只输出或显示或复制一部分数据元素，就是所谓的列表分片</p>
<pre><code><code>&gt;&gt;&gt; num = [&#39;HUAWEI&#39;,&quot;CHINA&quot;,&#39;Mirror&#39;,&#39;XIAOMI&#39;]
&gt;&gt;&gt; num
[&#39;HUAWEI&#39;, &#39;CHINA&#39;, &#39;Mirror&#39;, &#39;XIAOMI&#39;]
&gt;&gt;&gt; num[0:1]
[&#39;HUAWEI&#39;]
&gt;&gt;&gt; num[0:2]
[&#39;HUAWEI&#39;, &#39;CHINA&#39;]
&gt;&gt;&gt; num[0:4]
[&#39;HUAWEI&#39;, &#39;CHINA&#39;, &#39;Mirror&#39;, &#39;XIAOMI&#39;]

&gt;&gt;&gt; num[:2]
[&#39;HUAWEI&#39;, &#39;CHINA&#39;]
&gt;&gt;&gt; num[:]
[&#39;HUAWEI&#39;, &#39;CHINA&#39;, &#39;Mirror&#39;, &#39;XIAOMI&#39;]
&gt;&gt;&gt; num[2:]
[&#39;Mirror&#39;, &#39;XIAOMI&#39;]</code></pre>
<blockquote>
<p>仔细观察，发现分片的[x:y]是左闭右开的范围（原则）【python里很多时候和范围有关的闭合问题都是左闭右开的原则】</p>
<p>同时，分片机制还支持省略范围值；即左为空则从0开始，右为空则到最后一个元素结束，左右皆为空则全部元素输出；</p>
</blockquote>
<h4 id="分片的高级玩法">分片的高级玩法</h4>
<blockquote>
<p>大家都认为分片只有两个参数？</p>
<p>分片有三个参数 ==&gt; [x:y:z]</p>
<p>​ x：开始</p>
<p>​ y： 结束</p>
<p>​ z： 步长（即每次递加的数量为z也可以理解为数学中的等差概念）</p>
</blockquote>
<pre><code><code>&gt;&gt;&gt; num = [] // 创建一个空数组
&gt;&gt;&gt; for i in range(1,10):
    num.append(i)
&gt;&gt;&gt; num
[1, 2, 3, 4, 5, 6, 7, 8, 9]
&gt;&gt;&gt; num[0:10:2]
[1, 3, 5, 7, 9]</code></pre>
<h4 id="深浅复制初讨论">深浅复制初讨论</h4>
<pre><code><code>&gt;&gt;&gt; list = [1,2,3,4]
&gt;&gt;&gt; copy = list
&gt;&gt;&gt; copy1 = list
&gt;&gt;&gt; copy2 = list[:]
&gt;&gt;&gt; copy1
[1, 2, 3, 4]
&gt;&gt;&gt; copy2
[1, 2, 3, 4]</code></pre>
<p>从上边可以看出，list直接复制和list[:]分片复制的结果一样，但其实暗藏心急哦！</p>
<pre><code><code>&gt;&gt;&gt; list.append(5)
&gt;&gt;&gt; copy1
[1, 2, 3, 4, 5]
&gt;&gt;&gt; copy2
[1, 2, 3, 4]</code></pre>
<p>向原来的源列表 append() 添加一个元素，发现copy1的内容和list源列表一同别改变（append()操作）</p>
<ul>
<li>解释：</li>
</ul>
<blockquote>
<p>copy1 = list : 属于将list的内存地址给了copy1，</p>
<p>copy2 = list[:]：属于将list的值给了copy2</p>
</blockquote>
<blockquote>
<blockquote>

</blockquote>
</blockquote>
<h3 id="列表比较">列表比较</h3>
<p>列表支持比较运算符的比较操作：</p>
<pre><code><code>&gt;&gt;&gt; list1 = [123]
&gt;&gt;&gt; list2 = [234]
&gt;&gt;&gt; list3 = [123]
&gt;&gt;&gt; list1 &lt; list2
True
&gt;&gt;&gt; list1 &lt;= list3
True
&gt;&gt;&gt; list1 == list3
True
&gt;&gt;&gt; list1 != list2
True
&gt;&gt;&gt; list1.append(234)
&gt;&gt;&gt; list2.append(123)

&gt;&gt;&gt; list1
[123, 234]
&gt;&gt;&gt; list2
[234, 123]
&gt;&gt;&gt; list1 &gt; list2
False</code></pre>
<blockquote>
<p>两个列表的比较是根据ASCII值的大小比较的，如果遇到两个元素，则比较第一个，若第一个相同在比较第二个元素。</p>
</blockquote>
<h3 id="字符串列表">字符串列表</h3>
<h4 id="拼接和重复">拼接和重复</h4>
<pre><code><code>&gt;&gt;&gt; str1
[&#39;HUAWEI&#39;]
&gt;&gt;&gt; str2
[&#39;CHINA&#39;]
&gt;&gt;&gt; str1 + str2
[&#39;HUAWEI&#39;, &#39;CHINA&#39;]
&gt;&gt;&gt; str1 * 3
[&#39;HUAWEI&#39;, &#39;HUAWEI&#39;, &#39;HUAWEI&#39;]
&gt;&gt;&gt; str1 = str1 +str2
&gt;&gt;&gt; str1
[&#39;HUAWEI&#39;, &#39;CHINA&#39;]
&gt;&gt;&gt; str1[1] * 3
&#39;CHINACHINACHINA&#39;</code></pre>
<h3 id="元素判断innot-in">元素判断：in/not in</h3>
<ul>
<li>判断元素是否存在列表中：’str‘ in List / ’str‘ not in List</li>
</ul>
<pre><code><code>&gt;&gt;&gt; str1
[&#39;HUAWEI&#39;, &#39;CHINA&#39;]
&gt;&gt;&gt; &quot;CHINA&quot; in str1
True
&gt;&gt;&gt; &quot;CHINA&quot; not in str1
False</code></pre>
<h3 id="元素查询">元素查询</h3>
<h4 id="index查询元素的索引">index()：查询元素的索引</h4>
<pre><code><code>&gt;&gt;&gt; str = [&quot;H&quot;,&quot;U&quot;,&quot;A&quot;,&quot;W&quot;,&quot;E&quot;,&quot;I&quot;]
&gt;&gt;&gt; str
[&#39;H&#39;, &#39;U&#39;, &#39;A&#39;, &#39;W&#39;, &#39;E&#39;, &#39;I&#39;]
&gt;&gt;&gt; str.index(&quot;I&quot;)
5
&gt;&gt;&gt; str.index(&quot;K&quot;)  // 元素不存在保存
Traceback (most recent call last):
  File &quot;&lt;pyshell#4&gt;&quot;, line 1, in &lt;module&gt;
    str.index(&quot;K&quot;)
ValueError: &#39;K&#39; is not in list
&gt;&gt;&gt; </code></pre>
<h4 id="count查询元素重复次数">count()：查询元素重复次数</h4>
<pre><code><code>&gt;&gt;&gt; list
[3, 4, 5, 2, 5, 66, 7, 2, 5, 7]
&gt;&gt;&gt; list.count(5)
3</code></pre>
<h4 id="排序reverse-sort">排序：reverse() 、sort()</h4>
<ul>
<li>reverse()：反向排列</li>
<li>sort()：升序排列</li>
</ul>
<pre><code><code>&gt;&gt;&gt; list
[3, 4, 5, 2, 5, 66, 7, 2, 5, 7]
&gt;&gt;&gt; list.reverse() // 反向排列
&gt;&gt;&gt; list
[7, 5, 2, 7, 66, 5, 2, 5, 4, 3]
&gt;&gt;&gt; list.sort()   // 升序
&gt;&gt;&gt; list
[2, 2, 3, 4, 5, 5, 5, 7, 7, 66]
&gt;&gt;&gt; list.reverse()  // 反向排列 （srot+reverse ==&gt; 降序）
&gt;&gt;&gt; list
[66, 7, 7, 5, 5, 5, 4, 3, 2, 2]</code></pre>
<h2 id="元组">元组</h2>
<p>元组可以理解为：一旦定义不可被更改的列表。</p>
<h3 id="元组创建">元组创建</h3>
<pre><code><code>&gt;&gt;&gt; tuple = (1,2,3,4,5)
&gt;&gt;&gt; number = [1,2,3,4,5]
&gt;&gt;&gt; tuple
(1, 2, 3, 4, 5)
&gt;&gt;&gt; number
[1, 2, 3, 4, 5]</code></pre>
<p>tuple是元组，number是列表；</p>
<p>可以发现；两者的定义有所不同</p>
<p><strong>元组是由圆括号组成的一组列表数据，列表是由方括号组成的一组数据</strong></p>
<h3 id="元组访问">元组访问</h3>
<p>元组的访问方法和列表是一样的，主要通过元组的索引来访问元组的元素，和列表一样可以通过分片（切片）的方式访问。</p>
<pre><code><code>&gt;&gt;&gt; tuple
(1, 2, 3, 4, 5)
&gt;&gt;&gt; tuple[2]
3
&gt;&gt;&gt; tuple[3]
4
&gt;&gt;&gt; tuple[:]
(1, 2, 3, 4, 5)</code></pre>
<h4 id="type-方法">type() 方法</h4>
<ul>
<li>返回参数的类型</li>
</ul>
<pre><code><code>&gt;&gt;&gt; tup = ()
&gt;&gt;&gt; num = []
&gt;&gt;&gt; type(tup)
&lt;class &#39;tuple&#39;&gt;
&gt;&gt;&gt; type(num)
&lt;class &#39;list&#39;&gt;</code></pre>
<p>很多时候，都会认为圆括号定义的列表数据就是元组，然而并不是！</p>
<pre><code><code>&gt;&gt;&gt; del tup
&gt;&gt;&gt; tup
Traceback (most recent call last):
  File &quot;&lt;pyshell#14&gt;&quot;, line 1, in &lt;module&gt;
    tup
NameError: name &#39;tup&#39; is not defined
&gt;&gt;&gt; tup = 1,2,3,4
&gt;&gt;&gt; type(tup)
&lt;class &#39;tuple&#39;&gt;</code></pre>
<p>没错，没有圆括号的列表数据也是tuple元组。</p>
<p>定义元组的特点是：<strong>逗号</strong></p>
<pre><code><code>&gt;&gt;&gt; (6)*6
36
&gt;&gt;&gt; (6,)*6
(6, 6, 6, 6, 6, 6)</code></pre>
<p>所以在元组的定义时候，需要一个逗号告诉程序，这是元组</p>
<pre><code><code>&gt;&gt;&gt; tup = (1,2,3,)
&gt;&gt;&gt; type(tup)
&lt;class &#39;tuple&#39;&gt;</code></pre>
<p>这是最标准的定义方法，为什么？</p>
<h3 id="元组更新与删除">元组更新与删除</h3>
<ul>
<li>更新：</li>
</ul>
<p>元组和列表的功能除了数据改变以外几乎一致，一个元组的数据是不可以改变的，但元组和元组之间是可以拼接的</p>
<pre><code><code>&gt;&gt;&gt; tup
(1, 2, 3)
&gt;&gt;&gt; tup = tup[:3] + 4, + 5,
Traceback (most recent call last):
  File &quot;&lt;pyshell#28&gt;&quot;, line 1, in &lt;module&gt;
    tup = tup[:3] + 4, + 5,
TypeError: can only concatenate tuple (not &quot;int&quot;) to tuple
&gt;&gt;&gt; tup = tup[:3] + (4,) + (5,6,)
&gt;&gt;&gt; tup
(1, 2, 3, 4, 5, 6)</code></pre>
<p>tup利用拼接将tup元组数据进行了更新；</p>
<p>注意：</p>
<p>​ 这里在拼接的时候，将拼接的内容均用括号和逗号等标志表示这是一个元组数据，否则会被程序认为是一个字符或者数字数据。</p>
<p><strong>逗号是元组的标志定义</strong></p>
<ul>
<li>删除：</li>
</ul>
<pre><code><code>&gt;&gt;&gt; tup = tup[:2] + tup[4:]
&gt;&gt;&gt; tup
(1, 2, 5, 6)</code></pre>
<p>通过拼接方法覆盖掉需要删除的元素，以此达到删除元素的目的。</p>
<ul>
<li>总结：</li>
</ul>
<p>元组的数据是不变的，但是元组可以和列表一样自由的拼接：</p>
<p>​ 利用末尾的切片拼接的方式让元素增加元素（注意元组元素逗号标识）</p>
<p>​ 利用分片拼接的方式切除删除元素的前后内容拼接成一个新的元组</p>
<h2 id="字符串">字符串</h2>
<ul>
<li>Python3的所有字符串都是Unicode（编码）字符串</li>
</ul>
<h3 id="创建">创建</h3>
<pre><code><code>&gt;&gt;&gt; char = &quot;HUAWEI&quot;
&gt;&gt;&gt; str = &#39;XIAOMI&#39;
&gt;&gt;&gt; char
&#39;HUAWEI&#39;
&gt;&gt;&gt; str
&#39;XIAOMI&#39;</code></pre>
<p>字符串的创建可以使用单引号和双引号</p>
<h4 id="字符串修改">字符串修改</h4>
<pre><code><code>&gt;&gt;&gt; str = str[:3] + &quot;-&quot; + str[3:]
&gt;&gt;&gt; str
&#39;XIA-OMI&#39;</code></pre>
<p>字符串的修改和元组类似，采用分片拼接的方式实现更改字符串内容。</p>
<p>ps：是重新组成新的字符串给一个新的字符串变量所以要赋值</p>
<h3 id="字符串格式化">字符串格式化</h3>
<h4 id="format">format()</h4>
<ul>
<li>按照索引坐标</li>
</ul>
<pre><code><code>&gt;&gt;&gt; &#39;{0}-{1}={2}&#39;.format(&#39;XIAOMI&#39;,&#39;HUAWEI&#39;,&#39;CHINA&#39;)
&#39;XIAOMI-HUAWEI=CHINA&#39;</code></pre>
<p>从代码中可以看出，字符串中的花括号内容是对应这format方法的参数值索引内容，通俗说：花括号里的索引会将format中的对应的参数值调用组成一个字符串。{format中的参数称为：位置参数}</p>
<ul>
<li>按照(关键字)键值对</li>
</ul>
<pre><code><code>&gt;&gt;&gt; &#39;{x}-{h}={c}&#39;.format(x=&#39;XIAOMI&#39;,h=&#39;HUAWEI&#39;,c=&#39;CHINA&#39;)
&#39;XIAOMI-HUAWEI=CHINA&#39;</code></pre>
<ul>
<li>注意：<strong>位置参数索引要放在关键字索引前面</strong></li>
</ul>
<h2 id="格式化操作">格式化操作</h2>
<h3 id="格式化操作符">格式化操作符</h3>
<table>
<thead>
<tr class="header">
<th>格式符号</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>%c</td>
<td>格式化字符以及ASCII</td>
</tr>
<tr class="even">
<td>%s</td>
<td>格式化字符串</td>
</tr>
<tr class="odd">
<td>%d</td>
<td>格式化整数（十进制）</td>
</tr>
<tr class="even">
<td>%o</td>
<td>格式化无符号八进制</td>
</tr>
<tr class="odd">
<td>%x 、%X</td>
<td>格式化无符号十六进制（小写、大写）</td>
</tr>
<tr class="even">
<td>%f</td>
<td>格式化浮点数</td>
</tr>
<tr class="odd">
<td>%e 、%E</td>
<td>格式化科学计数法浮点数</td>
</tr>
</tbody>
</table>
<p>以上为常见的格式符号操作；和C语言异曲同工。</p>
<h3 id="格式化操作书写">格式化操作书写</h3>
<pre class="txt"><code>&#39;[格式化操作符]&#39; % [需要格式化操作的内容]</code></pre>
<pre><code><code>&gt;&gt;&gt; &#39;%c&#39; % 99
&#39;c&#39;</code></pre>
<p>格式化操作的表达方式是：百分号 ==&gt; <strong>%</strong></p>
<h3 id="辅助参数">辅助参数</h3>
<table>
<thead>
<tr class="header">
<th>参数命令</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>m.n</td>
<td>m为最小从宽度，n为小数点后的位数</td>
</tr>
<tr class="even">
<td>-</td>
<td>左对齐</td>
</tr>
<tr class="odd">
<td>+</td>
<td>证书前显示加好</td>
</tr>
<tr class="even">
<td>#</td>
<td>在八进制和十进制结果中分别显示：0o 和 0x/0X</td>
</tr>
<tr class="odd">
<td>0</td>
<td>数字前面用”0“填充空格</td>
</tr>
<tr class="even">
<td>转义字符</td>
<td>描述</td>
</tr>
<tr class="odd">
<td> '</td>
<td>单引号</td>
</tr>
<tr class="even">
<td> &quot;</td>
<td>双引号</td>
</tr>
<tr class="odd">
<td> a</td>
<td>系统响鸣</td>
</tr>
<tr class="even">
<td> b</td>
<td>退格符</td>
</tr>
<tr class="odd">
<td> n</td>
<td>换行符</td>
</tr>
<tr class="even">
<td> t ，  v</td>
<td>制表符（8个空格）</td>
</tr>
<tr class="odd">
<td> f</td>
<td>换页符</td>
</tr>
<tr class="even">
<td> r</td>
<td>回车符</td>
</tr>
<tr class="odd">
<td> \</td>
<td>反斜杠</td>
</tr>
<tr class="even">
<td> 0</td>
<td>代表一个空字符</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="序列">序列</h2>
<ul>
<li>列表、元组、字符串（*）都可以视为可迭代对象</li>
</ul>
<h3 id="list可迭代对象转为列表">list()：可迭代对象转为列表</h3>
<pre><code><code>&gt;&gt;&gt; list = list((1,2,3,4))
&gt;&gt;&gt; list
[1, 2, 3, 4]
&gt;&gt;&gt; list = list(&quot;HUAWEI&quot;)
&gt;&gt;&gt; list
[&#39;H&#39;, &#39;U&#39;, &#39;A&#39;, &#39;W&#39;, &#39;E&#39;, &#39;I&#39;]</code></pre>
<h3 id="tuple可迭代对象转为元组">tuple()：可迭代对象转为元组</h3>
<pre><code><code>&gt;&gt;&gt; tuple = tuple(&quot;HUAWEI&quot;)
&gt;&gt;&gt; tuple
(&#39;H&#39;, &#39;U&#39;, &#39;A&#39;, &#39;W&#39;, &#39;E&#39;, &#39;I&#39;)
&gt;&gt;&gt; type(tuple)
&lt;class &#39;tuple&#39;&gt;</code></pre>
<h3 id="strobj对象转为字符串">str()：obj对象转为字符串</h3>
<pre><code><code>&gt;&gt;&gt; s = str(1)
&gt;&gt;&gt; s
&#39;1&#39;
&gt;&gt;&gt; type(s)
&lt;class &#39;str&#39;&gt;
&gt;&gt;&gt; tuple(s)
(&#39;1&#39;,)</code></pre>
<h3 id="lensub返回参数长度">len(sub)：返回参数长度</h3>
<pre><code><code>&gt;&gt;&gt; num = [1,2,3,5,6,7]
&gt;&gt;&gt; len(num)
6</code></pre>
<h3 id="maxmin序列最大最小值">max()/min()：序列最大/最小值</h3>
<pre><code><code>&gt;&gt;&gt; num = [1,2,3,5,6,7]
&gt;&gt;&gt; len(num)
6
&gt;&gt;&gt; max(num)
7
&gt;&gt;&gt; min(num)
1</code></pre>
<h3 id="sum返回总和">sum()：返回总和</h3>
<pre><code><code>&gt;&gt;&gt; num = [1,2,3,5,6,7]
&gt;&gt;&gt; sum(num)
24</code></pre>
<h3 id="sorted排序">sorted()：排序</h3>
<pre><code><code>&gt;&gt;&gt; num
[12, 24, 33, 32, 243, 3, 6, 23, 15, 7, 6, 5, 3, 2, 1]
&gt;&gt;&gt; sorted(num)
[1, 2, 3, 3, 5, 6, 6, 7, 12, 15, 23, 24, 32, 33, 243]
&gt;&gt;&gt; num
[12, 24, 33, 32, 243, 3, 6, 23, 15, 7, 6, 5, 3, 2, 1]
&gt;&gt;&gt; num.sort()
&gt;&gt;&gt; num
[1, 2, 3, 3, 5, 6, 6, 7, 12, 15, 23, 24, 32, 33, 243]</code></pre>
<p>代码中我们和前面的sort()进行了对比发现</p>
<p>​ sorted()：返回升序后的结果但不改变原有数据</p>
<p>​ sort()：将源列表进行了升序</p>
<h3 id="reversed逆向迭代">reversed()：逆向迭代</h3>
<pre><code><code>&gt;&gt;&gt; list = list((2,4,67,3,7,3,8))
&gt;&gt;&gt; for i in reversed(list):
    print(i,end=&#39;-&#39;)

8-3-7-3-67-4-2-</code></pre>
<p>可以看出，reversed()方法会将一个可迭代的序列逆向迭代输出</p>
<h3 id="enumerate生成二元组">enumerate()：生成二元组</h3>
<p>二元组：元素为2的元组构成一个迭代对象，每个二元组有迭代参数的索引和对应的元素组成。</p>
<pre><code><code>&gt;&gt;&gt; for i in enumerate(list):
    print(i)

    
(0, &#39;H&#39;)
(1, &#39;U&#39;)
(2, &#39;A&#39;)
(3, &#39;W&#39;)
(4, &#39;E&#39;)
(5, &#39;I&#39;)</code></pre>
<h3 id="zip迭代参数合为元组">zip()：迭代参数合为元组</h3>
<p>返回可迭代参数共同组成的元组</p>
<pre><code><code>&gt;&gt;&gt; list
[2, 4, 67, 3, 7, 3, 8]
&gt;&gt;&gt; str
[&#39;H&#39;, &#39;U&#39;, &#39;A&#39;, &#39;W&#39;, &#39;E&#39;, &#39;I&#39;]
&gt;&gt;&gt; for i in zip(list,str):
    print(i)

    
(2, &#39;H&#39;)
(4, &#39;U&#39;)
(67, &#39;A&#39;)
(3, &#39;W&#39;)
(7, &#39;E&#39;)
(3, &#39;I&#39;)</code></pre>
<h2 id="函数">函数</h2>
<h3 id="函数创建调用">函数创建、调用</h3>
<p>函数的含义就是将需要的且重复的功能代码封装在一个对象函数中，需要使用的时候直接调用即可。</p>
<pre><code><code>def out():
    print(&quot;Hello,World!&quot;)
    print(&quot;I am Mirror&quot;)
    
out() // 调用out函数
Hello,World!
I am Mirror</code></pre>
<h3 id="函数参数">函数参数</h3>
<p>在函数定义的时候，可以在括号内添加参数设置，为函数设置参数，在调用函数时就会要求传入参数，函数体内也可以引用这个参数值进行工作。</p>
<pre><code><code>def name(s):
    print(s)

def sum(x,y):
    print(x+y)

name(&quot;Mirror&quot;)
sum(1,2)
================ RESTART ================
Mirror
3</code></pre>
<p>函数可以接收零个或多个参数值，在函数定义的时候，参数的数据类型可以不定义</p>
<h3 id="函数返回值">函数返回值</h3>
<pre><code><code>def name(s):
    return &quot;I am {0}&quot;.format(s)

def sum(x,y):
    return &quot;SUM = {0}&quot;.format(x+y)

print (name(&quot;Mirror&quot;))
print (sum(1,2))
================ RESTART================
I am Mirror
SUM = 3</code></pre>
<h3 id="灵活的函数">灵活的函数</h3>
<h4 id="形参和实参">形参和实参</h4>
<p>从上例函数的参数认识到了参数的设置和传递，但是如果我们不知道我们传递多少个数据参数的时候怎么办？</p>
<ul>
<li>形参：函数创建时的参数定义</li>
<li>实参：函数调用过程中有调用出传递的参数</li>
</ul>
<h4 id="函数文档">函数文档</h4>
<ul>
<li>指在函数定义下方注明函数的具体作用，增加可读性</li>
</ul>
<p>一般情况下，在嗲吗开头的三引号里不会打印出来，但是依旧会被存储，和注释的功能非常的类似，我们可以在调用的时候获取这个三引中的内容，了解函数的作用</p>
<h5 id="doc-_-_获取函数">_ _ doc _ _：获取函数</h5>
<pre><code><code>def sum(x,y):
    &quot;&quot;&quot; 返回 x,y 的求和&quot;&quot;&quot;
    return &quot;SUM = {0}&quot;.format(x+y)

print (sum.__doc__)
================ RESTART ================
 返回 x,y 的求和</code></pre>
<h4 id="关键字函数">关键字函数</h4>
<pre><code><code>def sum(x,y):
    &quot;&quot;&quot; 返回 x,y 的求和&quot;&quot;&quot;
    return &quot;SUM = {0}&quot;.format(x+y)

print (sum(x=1,y=2))</code></pre>
<p>将形参的名称作为关键字，采用”赋值“模式对指定的形参传递实参</p>
<h4 id="默认参数">默认参数</h4>
<pre><code><code>def sum(x=1,y=2):
    &quot;&quot;&quot; 返回 x,y 的求和&quot;&quot;&quot;
    return &quot;SUM = {0}&quot;.format(x+y)

print (sum())</code></pre>
<p>默认参数：函数定义形参的同时给形参设置一个默认的参数，如果函数调用时为接收到实参传递则使用形参的默认参数进行运行</p>
<h4 id="可变参数">可变参数</h4>
<p>回到形参时提出的关于不知道传递参数：</p>
<blockquote>
<p>从上例函数的参数认识到了参数的设置和传递，但是如果我们不知道我们传递多少个数据参数的时候怎么办？</p>
</blockquote>
<p>这时候就需要我们设置一个可变的形参（参数）：</p>
<p>* 形参名</p>
<pre><code><code>def sum(* s):

    print(len(s))
    print(type(s))

sum(1,2,3,4,5,6,7)

================ RESTART ================
7
&lt;class &#39;tuple&#39;&gt;</code></pre>
<p>观察分析得出：使用星号表示的形参会自动将接收的实参序列压缩为一个”元组“，我们在没有使用可变参数的时候只可以传递单个（数字、字符、字符串）参数</p>
<ul>
<li>可变参数可以接收的是：可迭代的序列（列表，元组，字符，字符串……）</li>
</ul>
<h2 id="字典集合">字典集合</h2>
<ul>
<li>python的字典集合采用：（Key：Value）键值对进行保存、读取等操作</li>
</ul>
<h3 id="字典创建dict">字典创建（dict）</h3>
<pre><code><code>&gt;&gt;&gt; dict = {1:10086,&quot;a&quot;:&quot;CHINA&quot;}
&gt;&gt;&gt; dict
{1: 10086, &#39;a&#39;: &#39;CHINA&#39;}
&gt;&gt;&gt; dict[1]  // 根据Key索引并返回Value
10086
&gt;&gt;&gt; dict[&quot;a&quot;]
&#39;CHINA&#39;</code></pre>
<p>字典的标志特点就是：花括号包围的键值对序列</p>
<ul>
<li>Key：是独一无二的，在同一个字典集合中不会重复</li>
<li>Value：每一个Value对应一个Key，Value可以重复，但必须不可变</li>
</ul>
<h3 id="字典内置操作">字典内置操作</h3>
<h4 id="formkeys创建返回新字典">formkeys()：创建返回新字典</h4>
<ul>
<li>参数：
<ul>
<li>key：必须</li>
<li>Value：默认None</li>
</ul></li>
</ul>
<pre><code><code>&gt;&gt;&gt; del dict
&gt;&gt;&gt; dict.fromkeys((1,2,3))
{1: None, 2: None, 3: None}</code></pre>
<h4 id="返回字典内容">返回字典内容</h4>
<h5 id="keys返回字典所有key值">keys()：返回字典所有Key值</h5>
<pre><code><code>&gt;&gt;&gt; dict
{1: None, 2: None, 3: None}
&gt;&gt;&gt; dict.keys()
dict_keys([1, 2, 3])</code></pre>
<h5 id="values返回字典所有value值">values()：返回字典所有Value值</h5>
<pre><code><code>&gt;&gt;&gt; dict.values()
dict_values([None, None, None])</code></pre>
<h5 id="items返回字典所有项">items()：返回字典所有项</h5>
<pre><code><code>&gt;&gt;&gt; dict.items()
dict_items([(1, None), (2, None), (3, None)])</code></pre>
<h4 id="get查询一个key的value">get()：查询一个key的value</h4>
<pre><code><code>&gt;&gt;&gt; dict
{1: 10086, &#39;a&#39;: &#39;CHINA&#39;}
&gt;&gt;&gt; dict.get(&quot;a&quot;)
&#39;CHINA&#39;
&gt;&gt;&gt; dict.get(1)
10086
&gt;&gt;&gt; dict.get(&quot;CHINA&quot;)
&gt;&gt;&gt; dict.get(112)</code></pre>
<p>get()查询一个key，如果不存在不会返回报错！可以利用 in/not in 来实现判断是否存在</p>
<h4 id="claer清空字典">claer()：清空字典</h4>
<pre><code><code>&gt;&gt;&gt; dict.clear()
&gt;&gt;&gt; dict
{}</code></pre>
<p>ps： 是清空内容不是删除</p>
<h4 id="copy复制字典">copy()：复制字典</h4>
<pre><code><code>&gt;&gt;&gt; dict
{1: 10086, &#39;a&#39;: &#39;CHINA&#39;}
&gt;&gt;&gt; c = {} // 定义一个空字典
&gt;&gt;&gt; c
{}
&gt;&gt;&gt; type(c)
&lt;class &#39;dict&#39;&gt;
&gt;&gt;&gt; c = dict.copy()
&gt;&gt;&gt; c
{1: 10086, &#39;a&#39;: &#39;CHINA&#39;}</code></pre>
<h4 id="pop弹出删除值">pop()：弹出（删除）值</h4>
<ul>
<li>pop(key)：删除key和对应的value</li>
<li>popitem()：删除最后一个key和value</li>
</ul>
<pre><code><code>&gt;&gt;&gt; dict = {1:10086,&quot;a&quot;:&quot;CHINA&quot;}
&gt;&gt;&gt; dict.pop(1)
10086
&gt;&gt;&gt; dict
{&#39;a&#39;: &#39;CHINA&#39;}
&gt;&gt;&gt; dict = {1:10086,&quot;a&quot;:&quot;CHINA&quot;}
&gt;&gt;&gt; dict.popitem()
(&#39;a&#39;, &#39;CHINA&#39;)
&gt;&gt;&gt; dict
{1: 10086}</code></pre>
<h4 id="update更新字典">update()：更新字典</h4>
<ul>
<li>dict.update(dict)</li>
</ul>
<pre><code><code>&gt;&gt;&gt; dict.update({2:2019})
&gt;&gt;&gt; dict
{1: 10086, &#39;a&#39;: &#39;CHINA&#39;, 2: 2019}</code></pre>
<h3 id="集合创建set">集合创建（set）</h3>
<ul>
<li>先看dict和set的区别</li>
</ul>
<pre><code><code>&gt;&gt;&gt; dict1 = {}
&gt;&gt;&gt; dict2 = {1,2,3,4,5} // 集合创建
&gt;&gt;&gt; type(dict1)
&lt;class &#39;dict&#39;&gt;
&gt;&gt;&gt; type(dict2)
&lt;class &#39;set&#39;&gt;</code></pre>
<p>可以通过集合与字典的比较发现集合的特点：</p>
<p>​ 集合是使用花括号但不适用键值对，以逗号分隔的序列</p>
<ul>
<li>集合开始</li>
</ul>
<pre><code><code>&gt;&gt;&gt; set = {1,2,3,4,5,6}</code></pre>
<h4 id="访问集合">访问集合</h4>
<pre><code><code>&gt;&gt;&gt; set1
{1, 2, 3, 4, 5, 6}
&gt;&gt;&gt; for i in set1:
    print(i,end=&quot; &quot;)

1 2 3 4 5 6</code></pre>
<h2 id="python文件">Python文件</h2>
<h3 id="文件打开-open">文件打开 open()</h3>
<h4 id="操作符">操作符</h4>
<table>
<thead>
<tr class="header">
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>r</td>
<td>以只读方式打开文件</td>
</tr>
<tr class="even">
<td>w</td>
<td>以写入方式打开文件</td>
</tr>
<tr class="odd">
<td>x</td>
<td>文件存在会抛出异常</td>
</tr>
<tr class="even">
<td>a</td>
<td>以写入方式打开，已存在文件可追加</td>
</tr>
<tr class="odd">
<td>b</td>
<td>以二进制打开文件</td>
</tr>
<tr class="even">
<td>t</td>
<td>以文本方式打开</td>
</tr>
<tr class="odd">
<td>+</td>
<td>可读写模式</td>
</tr>
<tr class="even">
<td>U</td>
<td>通用换行符支持</td>
</tr>
</tbody>
</table>
<h4 id="open函数">open()函数</h4>
<p>open()：用于创建一个文件对象，以便其他操作使用该文件对象</p>
<ul>
<li>单参数：可以是文件的具体路径和文件名（如果只是文件名会索引当前目录）</li>
<li>操作符：决定文件的打开模式（默认为只读 ”r“）</li>
</ul>
<h3 id="操作函数">操作函数</h3>
<h4 id="close关闭文件">close()：关闭文件</h4>
<h4 id="read读取字符">read()：读取字符</h4>
<ul>
<li>read(size=-1)：从文件中读取size指定的字符内容大小；未赋值表示读取全部内容并作为String返回</li>
</ul>
<h4 id="readline读取一行字符串">readline()：读取一行字符串</h4>
<h4 id="write向文件输出内容">write()：向文件输出内容</h4>
<h4 id="writelines向文件输出序列">writelines()：向文件输出序列</h4>
<h4 id="seek移动文件指针">seek()：移动文件指针</h4>
<ul>
<li>seek(offset,form)：从form偏移offset字节
<ul>
<li>offset：0 = 起始；1 = 当前位置；2 = 末尾</li>
</ul></li>
</ul>
<h4 id="tell返回当前文件的位置">tell()：返回当前文件的位置</h4>
<h3 id="os-文件模块">OS 文件模块</h3>
<p>os模块；import os 导入os模块</p>
<h4 id="目录操作">目录操作</h4>
<h5 id="getcwd获取当前目录">getcwd()：获取当前目录</h5>
<h5 id="chdir切换目录">chdir()：切换目录</h5>
<h5 id="listdir查看任意目录内容">listdir()：查看任意目录内容</h5>
<h5 id="mkdir创建文件夹目录">mkdir()：创建文件夹（目录）</h5>
<h5 id="makedirs创建多级文件夹目录">makedirs()：创建多级文件夹（目录）</h5>
<h4 id="删除操作">删除操作</h4>
<h5 id="remove删除指定文件">remove()：删除指定文件</h5>
<h5 id="radir删除指定文件夹目录">radir()：删除指定文件夹（目录）</h5>
<h5 id="removedirs删除多级文件夹目录">removedirs()：删除多级文件夹（目录）</h5>
<h5 id="rename文件文件夹-重命名">rename()：文件/文件夹 重命名</h5>
<h4 id="系统操作">系统操作</h4>
<h5 id="system调用工具">system()：调用工具</h5>
<h5 id="walk遍历子目录返回三元组">walk()：遍历子目录返回三元组</h5>
<h4 id="path-路径操作">path 路径操作</h4>
<h5 id="path.basename获取文件名">path.basename()：获取文件名</h5>
<h5 id="path.dirname获取路径名">path.dirname()：获取路径名</h5>
<h5 id="path.join完整路径join">path.join()：完整路径join</h5>
<h5 id="path.split分隔路径和文件名">path.split()：分隔路径和文件名</h5>
<h5 id="path.splitext分隔文件名和扩展名">path.splitext()：分隔文件名和扩展名</h5>
<h5 id="path.getsize获取文件大小字节">path.getsize()：获取文件大小（字节）</h5>
<h4 id="path-时间函数">path 时间函数</h4>
<h5 id="path.getatime最近访问时间">path.getatime()：最近访问时间</h5>
<h5 id="path.getctime创建时间">path.getctime()：创建时间</h5>
<h5 id="path.getmtime修改时间">path.getmtime()：修改时间</h5>
<h3 id="prckle模块">prckle()模块</h3>
<p>可以将对象以文件的形式存放在磁盘中；是一种简单的持久化功能</p>
<p>python的所有数据类型都可以使用 prckle()来序列化存放磁盘</p>
<h2 id="异常处理">异常处理</h2>
<h3 id="assertionerror断言">AssertionError：断言</h3>
<p>assert在测试程序的时候，在代码植入检查点</p>
<pre><code><code>&gt;&gt;&gt; list = [&#39;Mirror&#39;]
&gt;&gt;&gt; assert len(list)&gt;0
&gt;&gt;&gt; list.pop()
&#39;Mirror&#39;
&gt;&gt;&gt; assert len(list)&gt;0
Traceback (most recent call last):
  File &quot;&lt;pyshell#3&gt;&quot;, line 1, in &lt;module&gt;
    assert len(list)&gt;0
AssertionError</code></pre>
<p>assert断言：在其语句后面的条件成立的时候则不会编译assert，若断言条件满足后则会在程序中报错。</p>
<p>如上例代码程序：原先list列表内有一个元素，assert没有报错，但是pop方法弹出（删除）元素后，assert的条件得不到满足就会报错</p>
<h3 id="try---except语句">try - except语句</h3>
<pre class="pyton"><code>try:
    检测范围
except exception[as e]:
    检测发现exception异常后的处理方法
finally:// 可选
    必须执行的代码块</code></pre>
<ul>
<li>范例：</li>
</ul>
<pre><code><code>&gt;&gt;&gt; try:
        file = open(&quot;a.txt&quot;)
        file.close()
    except OSError:
        print(&quot;Error&quot;)

    
Error</code></pre>
<p>如范例中的程序，检测到在调用file文件对象的时候发生了OSError错误，由此执行报错（异常）代码执行块</p>
<pre><code><code>&gt;&gt;&gt; try:
        file = open(&quot;a.txt&quot;)
        file.close
    except OSError as e:
        print(str(e) + &quot;Error&quot;)
    except TypeError as e:
        print(str(e) + &quot;Error&quot;)

    
[Errno 2] No such file or directory: &#39;a.txt&#39;Error</code></pre>
<p>如上；利用as error方法，将错误信息写入e变量中，在以str的类型输出错误信息；同时发现，可以定义多种不同的错误类型和报错输出。</p>
<h4 id="异常">异常</h4>
<p>Exception： 所有异常的基类（可以接收任何类的异常）</p>
<p>AssertionError：assert语句失败（assert条件不成立）</p>
<p>AttributeError：访问一个对象没有的属性（对象属性不存在）</p>
<p>IOError：输入输出操作异常</p>
<p>ImportError：无法引入模块或包（路径错误等）</p>
<p>IndexError：索引超出序列边界</p>
<p>KeyError：访问字典中不存在的key</p>
<p>KeyboardInterrupt：Ctrl+C被触发</p>
<p>NamError：使用的对象无变量</p>
<p>SyntaxError：代码逻辑语法错误</p>
<p>TypeError：对象类型和语句要求不符</p>
<p>UnboundLocalError：全局变量的异常</p>
<p>ValueError：传入的value值异常出错</p>
<p>ZeroDivisonError：触发除零的异常</p>
<h2 id="第三方gui模块easygui">第三方GUI模块：EasyGUI</h2>
<h2 id="类和对象">类和对象</h2>
<h3 id="认识类和对象">认识类和对象</h3>
<p>类：class 类名称:</p>
<p>对象：def 方法名():</p>
<p>一个程序可以由多个类组成，一个类由多个对象方法组成；</p>
<p>self关键字：代表自己的对象参数</p>
<p>类的方法与普通的函数只有一个区别：它们必须有一个额外的参数名称，但在调用这个方法的时候不可以为这个参数赋值，python会提供这个值。这个特别的变量指的是对象的本身，名为：self；</p>
<h3 id="初探python魔法方法">初探Python魔法方法</h3>
<h4 id="init__构造方法">__ init__()构造方法</h4>
<p>只要实例化一个对象前，这个方法就会在对象被创建前自动调用；参数形参也会自动传入该方法中；可以利用重写该方法实现初始化的操作</p>
<pre><code><code>class Potate:
    def __init__(self.name):
        self.name = name
    def kick(self):
        pirnt(self.name)</code></pre>
<h4 id="公有和私有">公有和私有</h4>
<p>public ：公有、公共</p>
<p>private：私有</p>
<p>以上是C++和Java方法；</p>
<p>在Python中表示私有的属性：变量名前两个下划线“__”</p>
<h2 id="继承">继承</h2>
<pre><code><code>class 类名(被继承的类):</code></pre>
<ul>
<li>self：只可以使用自己的类中的对象</li>
<li>super：可以从子类中调用父类中的属性对象</li>
</ul>
<p>Python支持多重继承，即一个类继承多个父类；【不建议使用】</p>

</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>