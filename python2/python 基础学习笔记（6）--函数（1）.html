<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修python 基础学习笔记（6）--函数（1）' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>python 基础学习笔记（6）--函数（1）</center></div><div class='banquan'>原文出处:本文由博客园博主好啊郝提供。<br/>
原文连接:https://www.cnblogs.com/haoshaoqian/p/11177412.html</div><br>
    <p style="text-align: center;"><strong>## **函数（1）**</strong></p>
<p><strong>**函数的定义：**</strong><br /> 1. [ ] 小时候大家应该都玩过乐高积木，只要通过想象和创意，可以用它怕拼凑出很多神奇的东西。随着学习的深入，编写的代码日益增加并且越来越复杂，所以需要找一个方法对这些复杂的代码进行重新组织。<br /> 2. [ ] 为了是使得程序的代码更为简单，就需要把程序分解成较小的组成部分。(三种方法 函数，对象和模块)<br /> 3. [ ] 函数就是把代码打包成了不同形状的乐高积木。之前接触的BIF（内置函数）就是python帮我们封装好的函数，用的时候很方便。简单来讲，一个程序可以按照不同功能的实现，分割许多代码块，每一个代码块就可以封装成一个函数。在python中创建一个函数用def关键字：</p>
<p>函数 模板</p>
<p>    &gt; def  函数名称（）：<br />    &gt;         函数内容</p>
<p><br />例如</p>
<p><br />```<br />&nbsp; &nbsp; def MyFirstFunction() :<br />&nbsp; &nbsp; print("这是我创建的第一个函数")<br />&nbsp; &nbsp; print("我很开心")<br />```</p>
<p>注意，在函数名后面要加上一对小括号。</p>
<p>- [ ]&nbsp; &nbsp;函数的调用：（既然创建了函数就要去使用）</p>
<p>```<br />&nbsp; &nbsp;&gt;&gt;&gt;def MyFirstFunction() :<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print("这是我创建的第一个函数")<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print("我很开心")</p>
<p>&nbsp; &nbsp;&gt;&gt;&gt;MyFirstFunction() <br />```</p>
<p> - [ ] 并且函数的调用还可以有返回值，例如<br />```<br />&nbsp; &nbsp;&gt;&gt;&gt;def MyFirstFunction() :<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return '函数调用成功'</p>
<p>&nbsp; &nbsp;&gt;&gt;&gt;str_list = MyFirstFunction() <br />&nbsp; &nbsp;&gt;&gt;&gt;print(str_list)  #'函数调用成功'<br />```<br />在你定义的函数下面输入函数的名称就可以进行调用。（函数的调用机制：当函数MyFirstFunction() 发生调用操作的时候，python会自动往上找到 def MyFirstFunction()  的定义过程，然后依次执行该函数所包含的代码块部分）<br />&gt; 总结：<br />&gt; 1.遇到return,此函数结束,return后面的东西将不会在执行<br />&nbsp; &nbsp;2.return 返回值<br />　　关于返回值:<br />　　　　　　如果return什么都不写或者干脆就没写return,返回的结果就是None<br />　　　　　　如果return后面写了一个值,返回给调用者这个值<br />　　　　　　如果return后面写了多个结果,,返回给调用者一个tuple(元祖),调用者可以直接使用解构获取多个变量</p>
<p><strong>**函数的参数**</strong></p>
<p> - [ ]&nbsp; &nbsp;为什么说函数名的后面一定要跟括号呢？因为括号里面还要放很重要的东西&mdash;&mdash;参数。（在参数刚开始被发明出来的时候，是没有参数，很快就引出来许多小伙伴们的质疑：函数不过是对做同样内容的代码进行打包，这样跟使用循环就没有什么本质上的区别了。所以为了使每次调用的函数可以有不同的实现，加入了参数的概念）<br /> 例如<br /> </p>
<p>&nbsp;</p>
<p>```<br />&nbsp; &nbsp;&gt;&gt;&gt;def MyFirstFunction(name):<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print(name + '是帅哥')<br />&nbsp; &nbsp;####################<br />&nbsp; &nbsp;&gt;&gt;&gt;def MyFIrstFunction('张三')##张三是帅哥<br />```</p>
<p>&nbsp;</p>
<p> - [ ]&nbsp; &nbsp; &nbsp; 刚刚的例子只有一个函数，当然也可以使用多个函数，使用多个参数，只需要用逗号隔开即可。</p>
<p>&nbsp;</p>
<p>```<br />&nbsp; &nbsp;&gt;&gt;&gt;def add_sum(num1,num2)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return(num1+num2)<br />&nbsp; &nbsp;########################<br />&nbsp; &nbsp;&gt;&gt;&gt;res = add_sum(1,2)<br />&nbsp; &nbsp;&gt;&gt;&gt;print(res) ## 3<br />```</p>
<p>&nbsp;</p>
<p> - [ ]&nbsp; &nbsp;参数：参数从调用的角度来说，分为形式参数和实际参数。跟绝大多数编程语言一样，形参指的是函数创建和定义过程中小括号里的参数，而实参指的是函数在被调用的过程中传递进来的参数。<br /> 例如。(还有一个传参：给函数传递信息的时候将实际参数交给形式参数的过程被称为传参.)<br /> </p>
<p>&nbsp;</p>
<p>```<br />&nbsp; &nbsp; &gt;&gt;&gt; def Function(name)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print(name)<br />&nbsp; &nbsp; &gt;&gt;&gt;Function('张三') <br />&nbsp; &nbsp; ##<br />&nbsp; &nbsp; 张三  <br />```</p>
<p> - [ ]&nbsp; 关键字参数：普通的参数叫做位置参数，通常在调用一个函数的时候，粗心的程序员会将容易搞乱位置参数的顺序，已致函数的调用无法达到预期的效果，因此为了准确的传递参数，便有了关键词参数。<br /> </p>
<p>&nbsp;</p>
<p>```<br />&nbsp; &nbsp;def yue(chat, address, age):<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print("拿出手机")<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print("打开"+chat)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print("找个"+address+"附近漂亮的"+str(age)+"岁妹子")<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; yue(chat="微信", age=18, address="北京")       # 关键字参数.<br />&nbsp; &nbsp; &nbsp;结果:<br />&nbsp; &nbsp; 拿出手机<br />&nbsp; &nbsp; 打开微信<br />&nbsp; &nbsp; 找个北京附近漂亮的18岁妹子<br />```</p>
<p><br /><strong>&gt; **总结**</strong><br />&gt; 1.位置参数<br />   2.关键字参数<br />   3.混合参数, 位置参数必须在关键字参数前面</p>
<p><br /> - [ ] 默认参数：在函数声明的时候, 就可以给出函数参数的默认值. 在调用的时候可以 给出具体的值, 也可以不给值,</p>
<p>&nbsp;</p>
<p>```<br />&nbsp; &nbsp; &nbsp;def stu_info(name, age, sex='男'):<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;print("录入学生信息")<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;print(name, age, sex)<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;print("录入完毕")<br />&nbsp; &nbsp; &nbsp;stu_info("张强", 18)<br />&nbsp; &nbsp; &nbsp;##############<br />&nbsp; &nbsp; &nbsp;录入学生信息<br />&nbsp; &nbsp; &nbsp;'张强',18,'男'<br />&nbsp; &nbsp; &nbsp; 录入完毕<br />```</p>
<p><br />当然如果输入 （&rsquo;张强&lsquo;，18，女）就可以将男覆盖掉</p>
<p>&gt; 综上:<br />&gt; 在形参的角度来看<br />&gt; 位置参数<br />&gt; 默认值参数(大多数传进来的参数都是一样的, 一般用默认参数</p>
<p> - [ ]&nbsp; 动态参数（可变参数/收集参数）：发明这种参数的目的是函数的作者有时候也不知道这个函数需要多少个参数。。。。。<br /> </p>
<p>&nbsp;</p>
<p>```<br />&nbsp; &nbsp; &nbsp;def eat(a,b,c):<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; print('我想吃%s%s%s'%(a,b,c))<br />&nbsp; &nbsp; &nbsp;eat('米饭','面条','饺子') <br />&nbsp; &nbsp; &nbsp;#############################   等价<br />&nbsp; &nbsp; &nbsp;def eat(*args):<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;print('我想吃',args)<br />&nbsp; &nbsp; &nbsp;eat('大米饭','中米饭','小米饭')  # 收到的结果是一个tuple元祖<br />&nbsp; &nbsp;（ 注意点：*号的变量会把所有的元素都存进元组中）<br />&nbsp; &nbsp; &nbsp;#################<br />&nbsp; &nbsp; def eat(*args,a,b):<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;print('我想吃',args,a,b)<br />&nbsp; &nbsp; &nbsp;eat('大米饭','中米饭','小米饭')<br />&nbsp; &nbsp; 结果:<br />&nbsp; &nbsp; TypeError: eat() missing 2 required keyword-only arguments: 'a' and 'b'<br />&nbsp; &nbsp;# eat函数在调用的时候发现缺少俩个位置参数没有进行传递</p>
<p>```</p>
<p>&nbsp;</p>
<p> - [ ] 动态接收关键字参数：在python中可以动态的位置参数,但是这种情况只能接收位置参数无法接收关键字参数,在python中使用*来接收动态关键字参数<br /> </p>
<p>&nbsp;</p>
<p>```</p>
<p><em id="__mceDel">def func(**kwargs):<br />&nbsp; &nbsp; &nbsp; &nbsp;print(kwargs)     <br />func(a=1, b=2, c=3)<br />结果:<br />{'a': 1, 'b': 2, 'c': 3}<br />```</em></p>
<p>&gt; 动态关键字参数最后获取的是一个dict字典形式　　<br />顺序的问题, 在函数调用的时候, 如果先给出关键字参数, 则整个参数列表会报错.</p>
<p>```<br />def func(a,b,c,d):<br />    print(a,b,c,d)<br />func(1,2,c=3,4)<br />结果:<br />  File "D:/python_object/path2/test.py", line 806<br />    func(1,2,c=3,4)              ^<br />SyntaxError: positional argument follows keyword argument<br />```</p>
<p>&gt;  关键参数必须要放在位置参数后边,由于实参是这个顺序,所以形参接收的时候也是这个顺序.也就是说位置参数必须在关键字参数前面.动态接收关键字参数也要在后面<br />&gt; <br />&gt; 最终顺序:<br />&gt; <br />&gt; 　　位置参数 &gt; args(动态位置参数) &gt; 默认值参数 &gt; *kwargs(动态默认参数)<br />&gt; <br />&gt; 　　这四种参数可以任意的使用</p>
<p> - [ ] 函数的文档（函数的注释）：</p>
<p>```<br />def exchangRate(dollar):<br />"""<br />美元---&gt;人民币<br />汇率暂定为6.5    (对函数的注释)<br />"""<br />return dollar * 6.5</p>
<p>```<br /><strong>**函数的作用域**</strong></p>
<p> - [ ]  作用域就是作用范围, 按照生效范围来看分为 全局作用域 和 局部作用域<br />　　 全局作用域: 包含内置命名空间和全局命名空间. 在整个文件的任何位置都可以使用(遵循 从上到下逐⾏执行).<br />　　 局部作用域: 在函数内部可以使用.<br /> - [ ] 变量的作用域也就是所说的变量可见性。</p>
<p>```<br />def fun():   <br />&nbsp; &nbsp;a = 10   <br />&nbsp; &nbsp; print(a)<br />fun()<br />print(a)    # a不存在了已经..<br />```</p>
<p> - [ ] 我们可以通过globals()函数来查看全局作⽤用域中的内容,也可以通过locals()来查看局部作 ⽤用域中的变量量和函数信息</p>
<p>```<br />a = 10<br />def func():   <br />&nbsp; &nbsp; a = 40   <br />&nbsp; &nbsp; b = 20   <br />&nbsp; &nbsp; print("哈哈")   <br />&nbsp; &nbsp; print(a, b)        <br />&nbsp; &nbsp; print(globals())    # 打印全局作用域中的内容   <br />&nbsp; &nbsp; print(locals())     # 打印局部作用域中的内容<br />func()<br />```<br /><strong>**以上就是函数的第一部分内容，感谢点击观看，欢迎评论**</strong></p>
</div>
</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>